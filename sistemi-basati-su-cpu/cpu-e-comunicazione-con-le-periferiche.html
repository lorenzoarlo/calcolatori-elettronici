<!DOCTYPE html>
<html lang="IT">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="stylesheet" href="../styles/style.css" />
    <link rel="stylesheet" href="../styles/index-style.css" />
    <link rel="stylesheet" href="../styles/content-style.css" />
    <link rel="icon" type="image/x-icon" href="../resources/favicon.ico">
    <link rel="apple-touch-icon" href="../resources/favicon.png" />
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-78NHLXDQD8"></script>
    <script src="../scripts/script.js"></script>
    <style>:root { --bg-clr: #FFD700; --fg-clr: #262626; }</style>
    <meta name="theme-color" content="#FFD700" />
    <meta name="keywords" content="calcolatori elettronici" />
    <meta name="description" content="Il seguente sito contiene gli appunti e le definizioni del corso 'Calcolatori elettronici T'.">
    <meta name="robots" content="index">
    <script defer async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <title>Calcolatori elettronici - Sistemi basati su CPU - CPU e comunicazione con le periferiche</title>
</head>
<body>
    <div class="container">
        <header class="header-wrapper">
            <div class="title-wrapper">
                <span class="title">
                    Calcolatori elettronici
                </span>
                <span class="subtitle">
                    by lorenzoarlo
                </span>
            </div>
            <span class="page-title">
                Sistemi basati su CPU
            </span>
        </header>
        <section class="content-wrapper">
            <h1 class="section-title content-width">CPU e comunicazione con le periferiche</h1>
            <article class="content-container content-width">
                <div class="definition environment" id="def1-1"><h2 class="environment-title">Definizione - Elaborazione delle informazioni e interazione con l'esterno</h2><div class="environment-body">     Gran parte dei sistemi esistenti a come obiettivo principe l'elaborazione delle informazioni: anche la quasi totalità dei sistemi elettronici digitali ha questo obiettivo.     <br/>     Come tutti i sistemi di questo tipo, una funzione essenziale è l'interazione con l'esterno per acquisire e/o fornire informazione. </div></div><div class="definition environment" id="def1-2"><h2 class="environment-title">Definizione - Architetture per elaboratori</h2><div class="environment-body">     Esistono diverse architetture di elaborazione in base alle diverse necessità, ad esempio:     <ul class="list-container"><li class="list-item">sistemi general purpose;         </li><li class="list-item">sistemi embedded;         </li><li class="list-item">ecc.     </li></ul>     I sistemi general purpose sono sicuramente i più diffusi e sono basati generalmente sul modello di Von Neumann, che ha come elemento base una CPU. </div></div><div class="definition environment" id="def1-3"><h2 class="environment-title">Definizione - Modello di Von-Neumann</h2><div class="environment-body">     Il modello di Von-Neumann descrive un'architettura generale mentre il funzionamento è descritto da una sequenza di istruzioni (un programma) memorizzate su un supporto di memoria.     <br/>     Il sistema di elaborazione può essere schematizzato in modo astratto come una Rete Sequenziale Sincrona (RSS) a cui è aggiunta un'unità di controllo (ovvero una RSS) che dopo aver interrogato (<strong>fetch</strong>) la memoria per le istruzioni del programma, governa la parte combinatoria del microprocessore attraverso appositi <strong>segnali di controllo</strong>.     <br/>     A livello di massima astrazione, il funzionamento dell'intero sistema può essere descritto da due stati in continua alternanza:     <ul class="list-container"><li class="list-item">lo stato di Instruction Fetch (IF) in cui si "prelevano" le istruzioni da eseguire (indicato da un apposito registro detto Program Counter, PC);         </li><li class="list-item">lo stato di Execute (EX).     </li></ul></div></div><div class="definition environment" id="def1-4"><h2 class="environment-title">Definizione - CISC e RISC</h2><div class="environment-body">     Le CPU possono eseguire istruzioni come somme, moltiplicazioni, confronti, letture e scritture in memoria e/o verso altri dispositivi, ecc.      <br/>     In base al set di istruzioni codificate, le CPU si dividono tra:     <ul class="list-container"><li class="list-item">RISC (Reduced Instruction Set Computer), dove le istruzioni sono poche e semplici. Tali CPU sono caratterizzate da reti logiche semplici ed efficienti;         </li><li class="list-item">CISC (Complex Instruction Set Computer), dove le istruzioni sono molte e complesse, comportando reti logiche più complesse e più grandi.     </li></ul>     Se inizialmente fu l'architettura CISC ad essere prevalente, in particolare con l'arrivo dei dispositivi mobili, l'architettura RISC è diventata la più utilizzata per questioni di efficienza energetica e spazio occupato.     <br/>     Inoltre, ad oggi, anche le architetture CISC (ancora necessarie per la grande quantità di software preesistente) sono realizzate internamente come RISC. </div></div><div class="definition environment" id="def1-5"><h2 class="environment-title">Definizione - Linguaggi per CPU</h2><div class="environment-body">     Indipendentemente dal tipo della CPU, le istruzioni sono in forma binaria rendendole quindi di difficile comprensione.      Per questo motivo si utilizza il linguaggio assembly (o assembler) che traduce il codice assembly in binario grazie ad apposite Look Up Table (LUT).     I linguaggi di programmazione ad alto livello non fanno altro che tradurre le istruzioni più complesse (di alto livello, appunto) in istruzioni per la CPU (attraverso il compilatore, ad esempio).  </div></div><div class="definition environment" id="def1-6"><h2 class="environment-title">Definizione - Comunicazione nel modello di Von-Neumann</h2><div class="environment-body">     Nel modello di Von-Neumann le istruzioni risiedono in memoria, ma per leggere (e scrivere) la CPU utilizza segnali predefiniti temporizzati da un preciso ciclo di bus.     <br/>     Esistono infatti tre tipi di bus di comunicazione tra CPU, Memoria e le varie periferiche:     <ul class="list-container"><li class="list-item">l'Address Bus (<span class="math-span">\( BA[\ldots]\)</span>) unidirezionale (da CPU a memoria e periferiche);         </li><li class="list-item">il Data Bus (<span class="math-span">\( BD[\ldots]\)</span>) bidirizionale;         </li><li class="list-item">il Control Bus composto dai segnali:         <ul class="list-container"><li class="list-item">Read e Write (da CPU a memoria e periferiche);             </li><li class="list-item">Ready e Int (da memoria e periferiche a CPU).         </li></ul></li></ul></div></div><div class="definition environment" id="def1-7"><h2 class="environment-title">Definizione - Ciclo di bus</h2><div class="environment-body">     L'evoluzione temporale di alcuni segnali che interagiscono con una CPU si definiscono come ciclo di bus.     <br/>     L'unico modo per interagire con un sistema di questo tipo, consiste nel seguire le regole descritte da tale ciclo ed indicate dal costruttore nel relativo data sheet.     <br/>     Ad ogni ciclo di bus si ha quindi che nell'Address Bus è presente l'indirizzo della memoria o della periferica, nel Data Bus le informazioni da leggere o da scrivere e il Control Bus fornisce informazioni sull'operazione da svolgere o sullo stato della periferiche.     <br/>     Un ciclo di bus può durare più cicli di clock e può anche terminare in maniera asincrona.  </div></div><div class="definition environment" id="def1-8"><h2 class="environment-title">Definizione - Indirizzamento e spazio di indirizzamento</h2><div class="environment-body">     La CPU "emette" sull'Address Bus diversi indirizzi, in particolare si ha che se il bus è composto da <span class="math-span">\( 20\)</span> bit, lo spazio di indirizzamento sarà composto da <span class="math-span">\( 2^20\)</span> indirizzi. Ipotizzando inoltre la grandezza del Data Bus di <span class="math-span">\( 1\)</span> Byte (scelta anacronistica ma conveniente per i ragionamenti), si avrà uno spazio di indirizzamento di <span class="math-span">\( 1\)</span> MegaByte.     <br/>     Dato tale spazio, affinchè un dispositivo fisico (ad esempio una memoria) possa essere accessibile, deve essere mappato nello spazio di indirizzamento (devono essergli assegnati degli indirizzi), ovvero deve essergli assegnata una finestra di indirizzi.     <div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Ad esempio</h3><div class="environment-body">         Considerando di avere una memoria da <span class="math-span">\( 64\)</span> MB (<span class="math-span">\( 2^6 \cdot 2^20\)</span> Byte, ovvero <span class="math-span">\( 2^36\)</span> Byte) ed un Address Bus di <span class="math-span">\( 1\)</span> Byte, per poter indirizzare tale memoria saranno necessari almeno <span class="math-span">\( 2^36\)</span> indirizzi (ad ogni "dato" un indirizzo).     </div></div></div></div><div class="definition environment" id="def1-9"><h2 class="environment-title">Definizione - Driver 3-state</h2><div class="environment-body">     Il driver 3-state è una rete logica     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/driver3state-disabled.png"/></div></div>     che è caratterizzata da:     <ul class="list-container"><li class="list-item">un ingresso <span class="math-span">\( I\)</span>;         </li><li class="list-item">un ingresso <span class="math-span">\( OE\)</span> (Output Enable);         </li><li class="list-item">un'uscita <span class="math-span">\( U\)</span></li></ul>     Tale driver (un componente che non altera il segnale logico) permette l'introduzione di un "terzo stato", detto di "alta impedenza", che ha un effetto logico paragonabile "all'interruzione del cavo": a livello fisico, la tensione non assume un valore preciso ma rende il segnale in uscita "neutrale" rispetto al valore fornito da un altro componente.     <br/>     Esso è quindi descritto dalla seguente tabella della verità:     <div class="image-environment"><div class="image-wrapper spaced-20"><img alt="Immagine" src="../resources/generated-0.png"/></div></div>     dove <span class="math-span">\( Z\)</span> indica lo stato di alta impedenza.     <br/>     Si ha quindi che con l'ingresso <span class="math-span">\( OE = 1\)</span>, ovvero     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/driver3state-enabled.png"/></div></div>     tale componente diventa "trasparente", altrimenti "blocca" il segnale </div></div><div class="definition environment" id="def1-10"><h2 class="environment-title">Definizione - Decoder di I e II livello</h2><div class="environment-body">     La CPU per poter scrivere e leggere dei dati, emette l'indirizzo della cella di memoria interessata: a questo punto tale indirizzo viene fornito in input ad un decoder di I livello che in base al valore dei bit più significativi di tale indirizzo, abiliterà o disabiliterà (grazie ad un driver 3-state) un apposito ingresso del dispositivo (detto "Chip Select", CS).     <br/>     A questo punto, l'indirizzo è ulteriormente decodificato da un decoder di II livello (interno al dispositivo) che "collegherà" la parte della memoria corretta. </div></div><div class="definition environment" id="def1-11"><h2 class="environment-title">Definizione - Struttura di una generico dispositivo collegato alla CPU</h2><div class="environment-body">     Considerando un sistema caratterizzato da <span class="math-span">\( n\)</span> bit di dati, un generico dispositivo compatibile sarà caratterizzato da:     <ul class="list-container"><li class="list-item">un segnale di Chip Select del dispotivo;         </li><li class="list-item">un bus di <span class="math-span">\( k\)</span> bit utili per la decodifica di II livello;         </li><li class="list-item">un segnale di controllo per indicare la lettura ed uno per indicare la scrittura;         </li><li class="list-item">un bus di <span class="math-span">\( n\)</span> bit di dati.     </li></ul></div></div>
            </article>
            <nav class="buttons-container content-width">
                <a class="navigation-button previous" href="index.html" rel="nofollow"><span>Sistemi basati su CPU</span></a>
                
            </nav>
        </section>
        <div class="scroll-to-bottom-button" onclick="scroll_to_bottom()">
            <span class="material-symbols-outlined">
                keyboard_double_arrow_down
            </span>
        </div>
        <footer class="footer-wrapper">
            <div class="copyright-wrapper">
                <span> &copy; Copyright 2023</span> /
                <span>made by lorenzoarlo</span>
            </div>
            /
            <div class="privacy-wrapper">
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/" rel="nofollow">Pannello preferenze cookie</a></span> /
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/privacy-policy.html" rel="nofollow" target="_blank" >Privacy Policy</a></span>
            </div>
        </footer>
    </div>
</body>
</html>