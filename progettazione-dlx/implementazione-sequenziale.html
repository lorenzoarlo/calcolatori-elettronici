<!DOCTYPE html>
<html lang="IT">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="stylesheet" href="./../styles/style.css" />
    <link rel="stylesheet" href="./../styles/index-style.css" />
    <link rel="stylesheet" href="./../styles/main-index-page-style.css" />
    
        <link rel="stylesheet" href="./../styles/content-style.css" />
    
    <style>:root { --bg-clr: #FFD700; --fg-clr: #262626; }</style>
    <meta name="application-name" content="Calcolatori elettronici" />
    <meta name="apple-mobile-web-app-title" content="Calcolatori elettronici" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="#FFD700" />
    <link rel="apple-touch-icon" sizes="144x144" href="./../apple-icon-144x144.png">
    <link rel="icon" type="image/x-icon" href="./../favicon.ico">
    <link rel="icon" type="image/png" sizes="192x192" href="./../android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="96x96" href="./../favicon-96x96.png">
    <meta name="msapplication-TileColor" content="#FFD700">
    <meta name="msapplication-TileImage" content="./../ms-icon-144x144.png">
    <link rel="manifest" href="./../manifest.json">
    <meta name="keywords" content="calcolatori elettronici" />
    <meta name="description" content="Il seguente sito contiene gli appunti e le definizioni del corso 'Calcolatori elettronici T'.">
    <meta name="robots" content="index">
    <meta name="format-detection" content="telephone=no">
    <meta name="themeColor" content="#FFD700">
    <script src="./../scripts/script.js"></script>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-78NHLXDQD8"></script>
    <script defer async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <title>Calcolatori elettronici - Progettazione DLX - Implementazione sequenziale </title>
</head>
<body>
    <div class="container">
        <header class="header-wrapper">
            <div class="title-wrapper">
                <span class="title">
                    Calcolatori elettronici
                </span>
                <span class="subtitle">
                    by lorenzoarlo
                </span>
            </div>
            <span class="page-title">
                Progettazione DLX
            </span>
        </header>
        <aside class="sidebar">
            <h2 class="sidebar-title">Calcolatori elettronici</h2>
            <div class="index-container">
                <ul class="parent-ul"><li class="section-li"><a href="../index.html" rel="nofollow">Indice</a></li><li class="section-li "><a href="../funzionamento-della-cpu-in-un-elaboratore/il-modello-della-cpu.html" rel="nofollow">Funzionamento della CPU in un elaboratore</a><ul><li class="subsection-li "><a href="../funzionamento-della-cpu-in-un-elaboratore/il-modello-della-cpu.html" rel="nofollow">Il modello della CPU</a></li><li class="subsection-li "><a href="../funzionamento-della-cpu-in-un-elaboratore/comunicazione-con-dispositivi.html" rel="nofollow">Comunicazione con dispositivi</a></li><li class="subsection-li "><a href="../funzionamento-della-cpu-in-un-elaboratore/instruction-set-architecture.html" rel="nofollow">Instruction Set Architecture</a></li><li class="subsection-li "><a href="../funzionamento-della-cpu-in-un-elaboratore/il-microprocessore-dlx.html" rel="nofollow">Il microprocessore DLX</a></li><li class="subsection-li "><a href="../funzionamento-della-cpu-in-un-elaboratore/eventi-e-interruzioni.html" rel="nofollow">Eventi e interruzioni</a></li><li class="subsection-li "><a href="../funzionamento-della-cpu-in-un-elaboratore/protocollo-di-comunicazione-handshake.html" rel="nofollow">Protocollo di comunicazione handshake</a></li></ul></li><li class="section-li current">Progettazione DLX<ul><li class="subsection-li current">Implementazione sequenziale<ul><li class="definition-li"><a href="#def2-1" rel="nofollow">Struttura di una CPU</a></li><li class="definition-li"><a href="#def2-2" rel="nofollow">Struttura dei registri e bus dati</a></li><li class="definition-li"><a href="#def2-3" rel="nofollow">ALU nel DLX</a></li><li class="definition-li"><a href="#def2-4" rel="nofollow">Trasferimento dati sul Datapath</a></li><li class="definition-li"><a href="#def2-5" rel="nofollow">Massima frequenza di clock</a></li><li class="definition-li"><a href="#def2-6" rel="nofollow">Struttura dell'unità di controllo</a></li><li class="definition-li"><a href="#def2-7" rel="nofollow">Esecuzione di un'istruzione</a></li><li class="definition-li"><a href="#def2-8" rel="nofollow">Logica di estensione del segno nel Datapath</a></li><li class="definition-li"><a href="#def2-9" rel="nofollow">Trasferimenti di Half-Word e Byte</a></li><li class="definition-li"><a href="#def2-10" rel="nofollow">Controllo per le istruzioni di Data Transfer</a></li><li class="definition-li"><a href="#def2-11" rel="nofollow">Controllo per le istruzioni ALU</a></li><li class="definition-li"><a href="#def2-12" rel="nofollow">Controllo per le istruzioni di Set</a></li><li class="definition-li"><a href="#def2-13" rel="nofollow">Controllo per le istruzioni di Jump</a></li><li class="definition-li"><a href="#def2-14" rel="nofollow">Controllo per le istruzioni di Branch</a></li><li class="definition-li"><a href="#def2-15" rel="nofollow">Problematiche dell'implementazione sequenziale</a></li></ul></li><li class="subsection-li "><a href="implementazione-pipelined.html" rel="nofollow">Implementazione pipelined</a></li></ul></li></ul>
            </div>
        </aside>
        <div class="sidebar-button" onclick="toggle_sidebar(this)" role="button" >
            keyboard_double_arrow_right
        </div>
        <section class="content-wrapper">
            <h1 class="section-title content-width">Implementazione sequenziale</h1>
            <article class="content-container content-width">
                <div class="definition environment" id="def2-1"><h2 class="environment-title">Definizione - Struttura di una CPU</h2><div class="environment-body">     Come è stato detto, la CPU è una rete logica sequenziale sincrona complessa con lo scopo principale di <strong>elaborare informazioni</strong>.     <br/>     A questo scopo, essa è composta di due parti:     <ul class="list-container"><li class="list-item">il <strong>Datapath</strong>, un insieme di unità di calcolo (come l'ALU, i registri, ecc.) necessari per l'<strong>esecuzione delle istruzioni</strong> dell'ISA.          Tali istruzioni, affinchè siano eseguite, sono suddivise in micro-operazioni più piccole;          </li><li class="list-item">l'<strong>unità di controllo</strong>, ovvero una RSS che ad ogni ciclo di clock determina diversi segnali di controllo che condizioneranno quali micro-operazioni dovranno essere eseguite dal Datapath.     </li></ul>     Oltre a queste componenti, la CPU necessita anche di una <strong>memoria esterna</strong> in cui risiede il <strong>programma da eseguire</strong> (ovvero le istruzioni) e i <strong>dati</strong>.     <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/generated-14.png"/></div></div> </div></div><div class="definition environment" id="def2-2"><h2 class="environment-title">Definizione - Struttura dei registri e bus dati</h2><div class="environment-body">     Al fine di eseguire le diverse istruzioni, il DLX necessita di diversi registri (per conservare le informazioni) e di diversi bus (per il trasporto di tali dati).     <br/>     I bus (tutti dotati di parallelismo a <span class="math-span">\( 32 \mathrm{ \, bit }\)</span>) necessari sono:     <ul class="list-container"><li class="list-item">i bus <span class="mono">S1</span> e <span class="mono">S2</span>, che trasportano i dati <strong>dai registri</strong> (ad esempio verso l'ALU);         </li><li class="list-item">il bus <span class="mono">DEST</span>, utile per trasportare i dati <strong>verso i registri</strong>.     </li></ul>     Considerando ciò, è evidente il motivo per cui tramite le istruzioni è possibile leggere da due registri e scrivere solo verso uno.     <br/>     Oltre a questi, sono presenti altri registri (sempre a <span class="math-span">\( 32 \mathrm{ \, bit }\)</span>), ovvero:     <ul class="list-container"><li class="list-item">il <i>Register File</i>, ovvero i trentadue registri general purpose accedibile direttamente dal programmatore;         </li><li class="list-item">i registri <span class="mono">A</span> e <span class="mono">B</span>, ovvero i registri che permettono di "ritirare" i dati dal Register File;         </li><li class="list-item">il registro <span class="mono">C</span>, ovvero un registro che permette di inserire i dati nel Register File;          </li><li class="list-item">il <i><strong>P</strong>rogram <strong>C</strong>ounter</i> (anche detto <span class="mono">PC</span>);         </li><li class="list-item">l'<i><strong>I</strong>nstruction <strong>A</strong>ddress <strong>R</strong>egister</i> (anche detto <span class="mono">IAR</span>), in cui è depositato il valore del <span class="mono">PC</span> in caso di ricezione dell'interrupt;         </li><li class="list-item">il <i>Temporary Register</i> (anche detto <span class="mono">TEMP</span>), utile per il deposito temporaneo di risultati intermedi;         </li><li class="list-item">il <i><strong>M</strong>emory <strong>A</strong>ddress <strong>R</strong>egister</i> (anche detto <span class="mono">MAR</span>), contenente l'indirizzo destinazione di un ciclo di bus di lettura/scrittura;         </li><li class="list-item">il<i> <strong>M</strong>emory <strong>D</strong>ata <strong>R</strong>egister</i> (anche detto <span class="mono">MDR</span>), contenente i dati di transito temporaneo di un ciclo di bus di lettura/scrittura;         </li><li class="list-item">l'<i><strong>I</strong>nstruction <strong>R</strong>egister</i> (anche detto <span class="mono">IR</span>), contenuto nell'unità di controllo e contenente l'istruzione attualmente in esecuzione.     </li></ul>     In generale, la struttura può essere così schematizzata     <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/generated-15.png"/></div></div>     Da notare che la memoria comunica con:     <ul class="list-container"><li class="list-item">il registro <span class="mono">MAR</span> per poter leggere l'indirizzo desiderato dei cicli di lettura e scrittura;         </li><li class="list-item">il registro <span class="mono">MDR</span> in input per poter fornire i dati durante i cicli di scrittura e in output per poter fornire i dati letti;         </li><li class="list-item">il registro <span class="mono">IR</span> per poter fornire le istruzioni da eseguire durante la fase di fetch.     </li></ul> </div></div><div class="definition environment" id="def2-3"><h2 class="environment-title">Definizione - ALU nel DLX</h2><div class="environment-body">     L'ALU è una rete combinatoria facente parte del Datapath del DLX.      Essa permette di eseguire le istruzioni aritmetico-logiche utilizzando i dati forniti dai bus <span class="mono">S1</span> e <span class="mono">S2</span>.     Ad esempio può eseguire:     <ul class="list-container"><li class="list-item">la somma (e differenza) tra <span class="mono">S1</span> e <span class="mono">S2</span>;         </li><li class="list-item">l'AND, l'OR, lo XOR bit-a-bit tra <span class="mono">S1</span> e <span class="mono">S2</span>;         </li><li class="list-item">lo shift logico e aritmetico;         </li><li class="list-item">ecc.     </li></ul>     Oltre a questo, fornisce diversi flag in uscita, come:     <ul class="list-container"><li class="list-item">lo <i>Zero Flag</i>, che segnala se il risultato è <span class="mono">0</span>;         </li><li class="list-item">il <i>Sign Flag</i>, che segnala se il risultato è negativo (considerando la rappresentazione in complemento a <span class="math-span">\( 2\)</span>);         </li><li class="list-item">il <i>Carry Flag</i>, che segnala la presenza del riporto.     </li></ul>     Nonostante siano presenti questi flag, non sono presenti registri accedibili dal programmatore per conoscerne il valore. </div></div><div class="definition environment" id="def2-4"><h2 class="environment-title">Definizione - Trasferimento dati sul Datapath</h2><div class="environment-body">     La comunicazione interna al DLX è basata sullo scambio di informazioni tra i bus <span class="mono">S1</span>, <span class="mono">S2</span> e <span class="mono">DEST</span> e i diversi registri.     <br/>     I registri  sono tutti caratterizzati da un <strong>comportamento edge-triggered</strong> e sono collegati direttamente al clock interno del DLX.      Si ha quindi che in input, per quanto riguarda i dati, hanno un collegamento diretto (ovvero non è interposto un driver 3-state) ma è effettuato il campionamento solamente se l'unità di controllo asserisce il segnale <i>Write Enable</i>.     <div class="image-environment"><div class="image-wrapper spaced-60"><img alt="Immagine" src="../resources/comunicazione-registri.png"/></div></div>     Non è possibile ragionare nello stesso modo per l'output: si ha infatti che i registri incorporano al loro interno uscite con 3-state che "permetteranno il passaggio" del segnale solamente se asseriti i rispettivi segnali <i>Output Enable</i> (ovvero <span class="mono">OE1</span> ed <span class="mono">OE2</span>). </div></div><div class="definition environment" id="def2-5"><h2 class="environment-title">Definizione - Massima frequenza di clock</h2><div class="environment-body">     Conoscendo il funzionamento del trasferimento dati sul Datapath, è possibile capire da cosa dipende la frequenza di clock.      Si ha infatti che il periodo di clock <span class="math-span">\( T_{CK}\)</span> deve essere almeno maggiore della somma tra:     <ul class="list-container"><li class="list-item">tempo (massimo) per la <strong>validità dei segnali di controllo</strong> <span class="math-span">\( T_C\)</span>, ovvero il ritardo massimo tra il fronte di salita del clock e l'istante in cui i segnali di controllo generati risultino validi;         </li><li class="list-item">tempo (massimo) per la <strong>validità dei dati in output</strong> <span class="math-span">\( T_{OE}\)</span>, ovvero il ritardo massimo tra l'arrivo del segnale di Output Enable e l'istante in cui i dati sono presenti sul bus;         </li><li class="list-item">tempo (massimo) per la <strong>validità del risultato ottenuto dall'ALU</strong> <span class="math-span">\( T_{ALU}\)</span>;         </li><li class="list-item">tempo (minimo) di <strong>set-up dei registri</strong> <span class="math-span">\( T_{SU}\)</span>, ovvero il tempo minimo affinché il dato possa essere campionato dai registri.     </li></ul>     Detto ciò, si ha quindi che     <span class="math-block">\[         T_{CK} \gt T_C + T_{OE} + T_{ALU} + T_{SU}       \]</span> </div></div><div class="definition environment" id="def2-6"><h2 class="environment-title">Definizione - Struttura dell'unità di controllo</h2><div class="environment-body">     Dopo aver definito il set di istruzioni e aver progettato il Datapath, è necessario progettare l'unità di controllo.      <br/>     Tale rete è una rete sequenziale sincrona il cui funzionamento può essere specificato tramite un diagramma degli stati: dato che consideriamo come segnale sincrono il clock, si avrà che ad ogni ciclo di clock corrisponde uno stato.     <br/>     Come ogni rete sequenziale, sarà necessario tenere conto dello stato presente e degli ingressi per generare lo stato futuro.      In base allo stato, saranno poi generati appositi segnali di controllo diretti al Datapath.     <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/generated-16.png"/></div></div>     Da notare che la struttura di questa rete non è diversa dalla struttura di una generica macchina a stati finiti (<i>Finite State Machine</i>). </div></div><div class="definition environment" id="def2-7"><h2 class="environment-title">Definizione - Esecuzione di un'istruzione</h2><div class="environment-body">     Considerando una generica istruzione, è possibile identificare cinque diverse fasi che descrivono il suo completamento (anche se non sempre sono tutte necessarie).      Si ha infatti:     <ul class="list-container"><li class="list-item">la fase di <i>Instruction Fetch</i> (sempre eseguita) in cui viene <strong>prelevata l'istruzione da eseguire</strong> dalla memoria e "depositata" nell'Instruction Register;         </li><li class="list-item">la fase di <i>Instruction Decode</i> (sempre eseguita) in cui l'<strong>istruzione</strong> presente nell'Instruction Register è <strong>decodificata</strong>;         </li><li class="list-item">la fase di <i>Execute</i> in cui vi è l'<strong>elaborazione aritmetico-logica che utilizza l'ALU</strong>;         </li><li class="list-item">la fase di <i>Memory</i> in cui è eseguito l'<strong>accesso in memoria</strong>;         </li><li class="list-item">la fase di <i>Write Back</i> in cui si <strong>riportano i risultati ottenuti</strong> nel Register File.     </li></ul>     Consideriamo ora il diagramma degli stati delle due fasi sempre eseguite.     <h3 class="inner-title">Fase di Istruction Fetch</h3>     La fase di Instruction Fetch è la prima fase dell'esecuzione di ogni istruzione.      <br/>     Principalmente essa consiste nell'<strong>effettuare un accesso in memoria al fine di "prelevare" l'istruzione da eseguire</strong>.     Inoltre, in questa fase è necessario <strong>intercettare eventuali interrupt</strong> al fine di eseguire poi i relativi handler.     <br/>     Il diagramma degli stati (in cui ad ogni blocco corrisponde un ciclo di clock) di questa fase è quindi il seguente     <div class="image-environment"><div class="image-wrapper spaced-75"><img alt="Immagine" src="../resources/state-diagram-if-sequenziale.png"/></div></div>     È da notare che il comportamento è differente in base alla ricezione o meno di un interrupt e se la sua ricezione sia abilitata o meno (ovvero il segnale <i><strong>I</strong>nterrupt <strong>En</strong>able</i> <span class="mono">IEN</span> è attivo).     <br/>     Nel caso si stesse vivendo una situazione "regolare", è necessario effettuare un ciclo di lettura in memoria all'indirizzo del <i>Program Counter</i> <span class="mono">PC</span>: sarà quindi necessario "caricare" nel <i>Memory Address Register</i> (<span class="mono">MAR</span>) il valore di <span class="mono">PC</span> e leggere tale indirizzo dalla memoria (che fornirà il dato solo quando il segnale <span class="mono">READY</span> sarà asserito dal <i>Memory Controller</i>, come in un tipico ciclo di lettura).     <br/>     Nel caso invece si debba gestire un interrupt, la situazione è differente.     È necessario infatti salvare il valore di <span class="mono">PC</span> nel registro <i>Interrupt Address Register</i> <span class="mono">IAR</span>, assegnare il valore <span class="mono">0000 0000h</span> al <span class="mono">PC</span> e asserire <span class="mono">IEN = 0</span> (in quanto <strong>non prevediamo il nesting</strong>).      Una volta fatto ciò, è possibile ricominciare la fase di Instruction Fetch.     <div class="mynote environment"><h3 class="environment-title">Nota bene - Un approccio più veloce</h3><div class="environment-body">         Considerando questa soluzione più "classica", si ha che la lettura dell'istruzione è fatta attraverso un tipico ciclo di lettura che prevede il caricamento sul registro <span class="mono">MAR</span> di <span class="mono">PC</span> per effettuare solo successivamente la richiesta di accesso alla memoria.         <br/>         Ciò risulta però non essere la soluzione più efficiente, in quanto conosciamo a priori il registro sorgente di quell'assegnamento ed è quindi possibile modificare il Datapath per poter <strong>indirizzare la memoria direttamente dal <span class="mono">PC</span></strong>.          Si avrebbe quindi un diagramma degli stati così modificato         <div class="image-environment"><div class="image-wrapper spaced-75"><img alt="Immagine" src="../resources/state-diagram-if-sequenziale-modificato.png"/></div></div>         in cui per ogni istruzione si risparmia un ciclo di clock.     </div></div>     <h3 class="inner-title">Fase di Istruction Decode</h3>     La fase di Instruction Decode è eseguita immediatamente dopo la fase di Instruction Fetch.      Tale fase risulta essere particolarmente semplice e immediata grazie alla struttura delle istruzioni.     <br/>     Come abbiamo già detto, infatti, si ha che ogni istruzione è a lunghezza fissa (ovvero occupa precisamente <span class="math-span">\( 4 \mathrm{ \, Byte }\)</span>) e presenta le informazioni in posizioni predefinite.      Ciò, ci permette di ridurre questa fase a     <div class="image-environment"><div class="image-wrapper spaced-75"><img alt="Immagine" src="../resources/state-diagram-id-sequenziale.png"/></div></div>     Come è evidente dal diagramma, si ha che è possibile eseguire questa fase in un singolo ciclo di clock, in quanto le operazione possono essere eseguite in parallelo.     In particolare si ha che:     <ul class="list-container"><li class="list-item">il <span class="mono">PC</span> è incrementato di <span class="mono">+4</span> (utilizzando l'ALU);         </li><li class="list-item">ignorando quale istruzione è da eseguire, sono "estratti" i valori dei due registri indicati dall'istruzione (nel caso di istruzioni di formato <span class="mono">R</span>) e posti nei registri <span class="mono">A</span> e <span class="mono">B</span>.          Si fa ciò per risparmiare successivamente un ciclo di clock, in quanto nel caso peggiore si ha che la sequenza di bit prelevata non indica dei registri ma altro (caso in cui tali valori saranno ignorati);         </li><li class="list-item">grazie ad un decoder, è possibile comprendere con una semplice logica combinatoria quale operazione si vuole eseguire.     </li></ul> </div></div><div class="definition environment" id="def2-8"><h2 class="environment-title">Definizione - Logica di estensione del segno nel Datapath</h2><div class="environment-body">     Considerando le istruzioni di formato <span class="mono">I</span> e <span class="mono">J</span>, si ha che all'interno dell'istruzione è <strong>codificato anche un immediato</strong>.      <br/>     Tale valore, al fine di essere poi utilizzabile dall'ALU, deve essere esteso a <span class="math-span">\( 32 \mathrm{ \, bit }\)</span>.     Per farlo (nel caso di immediati a <span class="math-span">\( 16 \mathrm{ \, bit }\)</span> ma in maniera non dissimile per gli immediati a <span class="math-span">\( 26 \mathrm{ \, bit }\)</span>) si utilizza una rete logica simile alla seguente (ipotizzando che l'immediato sia posizionato nei bit <span class="mono">IR[15..0]</span>)     <div class="image-environment"><div class="image-wrapper spaced-60"><img alt="Immagine" src="../resources/sign-extension.png"/></div></div> </div></div><div class="definition environment" id="def2-9"><h2 class="environment-title">Definizione - Trasferimenti di Half-Word e Byte</h2><div class="environment-body">     Considerando le <strong>istruzioni di Data Transfer</strong> (ovvero le Load e le Store) si ha che deve essere possibile il trasferimento di stringhe con lunghezza minore a <span class="math-span">\( 32 \mathrm{ \, bit }\)</span> (ovvero la dimensione dei registri).      Come sappiamo, tale meccanismo è realizzato con la <strong>logica dei Bus Enable</strong> che attivano le rispettive memorie fisiche legate ad un certo indirizzo.      Sappiamo inoltre che il registro preposto al trasferimento di dati durante i cicli di bus è il registro <span class="mono">MDR</span>: è necessario quindi gestire i diversi trasferimenti di dato.     <br/>     Considerando <strong>il caso delle Load</strong> (ovvero quando il trasferimento va dalla memoria al registro <span class="mono">MDR</span>) è necessario utilizzare una serie di multiplexer per gestire come il segno deve essere esteso e da quali memorie fisiche leggere il dato.      Ad esempio, ipotizzando di voler leggere un singolo Byte, si vorrà inserire nell'<span class="mono">MDR</span> il valore contenuto nella memoria parallela che si è attivata (in base all'indirizzo a cui si è effettuato il ciclo di lettura).      Sempre considerando il caso di lettura di un singolo Byte, è necessario discriminare per i restanti tre Byte più significativi come effettuare l'estensione del segno: nel caso si volesse eseguire un'istruzione <span class="code-inline">LB</span> (ovvero il trasferimento di un Byte signed), sarà necessario estendere il bit più significativo del Byte.      Nel caso invece si volesse eseguire una <span class="code-inline">LBU</span> (ovvero il trasferimento di un Byte unsigned) sarà sufficiente concatenare diversi bit <span class="mono">0</span>.     <br/>     Considerando invece il <strong>caso delle Store</strong> (ovvero quando il trasferimento va dal registro <span class="mono">MDR</span> alla memoria) è necessario utilizzare una serie di demultiplexer per gestire dove il dato dovrà essere posizionato nella memoria, al fine di sovrascrivere solo i Byte espressi tramite il comando.      Ad esempio, considerando l'esecuzione di una <span class="code-inline">SH</span> (ovvero il trasferimento di <span class="math-span">\( 2 \mathrm{ \, Byte }\)</span>) saranno trasferiti i <span class="math-span">\( 2 \mathrm{ \, Byte }\)</span> meno significativi dell'<span class="mono">MDR</span> verso le giuste memorie fisiche che si vogliono sovrascrivere (lasciando invariati i Byte non interessati a quell'indirizzo di memoria). </div></div><div class="definition environment" id="def2-10"><h2 class="environment-title">Definizione - Controllo per le istruzioni di Data Transfer</h2><div class="environment-body">     Le <strong>istruzioni di Data Transfer</strong> (ovvero quelle che coinvolgono cicli di bus) hanno in generale la stessa struttura: sono infatti tutte istruzioni di formato <span class="mono">I</span>, ovvero attraverso l'istruzione saranno forniti due registri (caricati su <span class="mono">A</span> e <span class="mono">B</span>) e un immediato (esteso a <span class="math-span">\( 32 \mathrm{ \, bit }\)</span>).     <h3 class="inner-title">Istruzioni di Load</h3>     Considerando le <strong>istruzioni di Load</strong>, il diagramma degli stati associato sarà il seguente:     <div class="image-environment"><div class="image-wrapper spaced-95"><img alt="Immagine" src="../resources/state-diagram-load.png"/></div></div>     In questo tipo di istruzioni si ha che saranno quindi eseguiti i seguenti passaggi:     <ul class="list-container"><li class="list-item">inizialmente è caricato nel registro <span class="mono">MAR</span> il risultato della somma tra il registro e l'immediato esteso con segno;         </li><li class="list-item">una volta fatto ciò, si effettua l'accesso in memoria;         </li><li class="list-item">una volta letto tale valore (presente nell'<span class="mono">MDR</span>), in base all'istruzione che si deve eseguire, sarà inserito nel registro <span class="mono">C</span> il valore dell'<span class="mono">MDR</span> (esteso in maniera appropriata se necessario);         </li><li class="list-item">infine, durante la fase di Write Back, sarà trasferito nel registro destinazione il valore presente in <span class="mono">C</span>.     </li></ul>     <h3 class="inner-title">Istruzioni di Store</h3>     Considerando ora le <strong>istruzioni di Store</strong>, il diagramma degli stati associato sarà il seguente:     <div class="image-environment"><div class="image-wrapper spaced-60"><img alt="Immagine" src="../resources/state-diagram-store.png"/></div></div>     Per questo tipo di istruzioni si ha che saranno quindi eseguiti i seguenti passaggi:     <ul class="list-container"><li class="list-item">inizialmente è caricato nel registro <span class="mono">MAR</span> il risultato della somma tra il registro e l'immediato esteso con segno;         </li><li class="list-item">viene quindi inserito il valore di <span class="mono">B</span> nell'<span class="mono">MDR</span>;         </li><li class="list-item">tramite un'apposita rete logica, sono attivati i corretti Bus Enable e viene effettuato l'accesso in memoria (in scrittura).     </li></ul> </div></div><div class="definition environment" id="def2-11"><h2 class="environment-title">Definizione - Controllo per le istruzioni ALU</h2><div class="environment-body">     Le <strong>istruzioni ALU</strong> (ovvero quelle che coinvolgono operazioni aritmetiche) possono essere di formato <span class="mono">I</span> e di formato <span class="mono">R</span>.     <br/>     Il diagramma degli stati ad esse associato sarà quindi il seguente:     <div class="image-environment"><div class="image-wrapper spaced-75"><img alt="Immagine" src="../resources/state-diagram-alu.png"/></div></div>     Dato ciò, si ha che si adotta la seguente strategia per uniformare l'esecuzione:     <ul class="list-container"><li class="list-item">inseriamo il valore del secondo operando nel registro <span class="mono">TEMP</span>: nel caso stessimo eseguendo una istruzione <span class="mono">R</span> utilizzeremo direttamente il valore, altrimenti il suo segno sarebbe esteso in maniera appropriata;         </li><li class="list-item">calcoliamo il risultato utilizzando l'ALU a cui sono inviati appositi segnali di controllo;         </li><li class="list-item">il risultato ottenuto (che risiede in <span class="mono">C</span>), sarà inserito nel registro destinazione <span class="mono">RD</span> indicato nell'istruzione.     </li></ul>     <div class="mynote environment"><h3 class="environment-title">Nota bene - Un'alternativa</h3><div class="environment-body">         Per rendere queste istruzioni più efficienti di un ciclo di clock, sarebbe possibile eliminare il registro <span class="mono">TEMP</span> e duplicare i percorsi.     </div></div> </div></div><div class="definition environment" id="def2-12"><h2 class="environment-title">Definizione - Controllo per le istruzioni di Set</h2><div class="environment-body">     Le <strong>istruzioni di Set</strong> (ovvero quelle che coinvolgono operazioni logiche) possono essere di formato <span class="mono">I</span> e di formato <span class="mono">R</span>.     <br/>     Il diagramma degli stati ad esse associato sarà quindi il seguente:     <div class="image-environment"><div class="image-wrapper spaced-75"><img alt="Immagine" src="../resources/state-diagram-set.png"/></div></div>     Dato ciò, si ha che si adotta la seguente strategia per uniformare l'esecuzione:     <ul class="list-container"><li class="list-item">inseriamo il valore del secondo operando nel registro <span class="mono">TEMP</span>: nel caso stessimo eseguendo una istruzione <span class="mono">R</span> utilizzeremo direttamente il valore, altrimenti il suo segno sarebbe esteso in maniera appropriata;         </li><li class="list-item">calcoliamo il risultato utilizzando l'ALU a cui sono inviati appositi segnali di controllo;         </li><li class="list-item">il risultato (inviato all'unità di controllo) sarà utilizzato per sovrascrivere il valore di <span class="mono">C</span> e sarà successivamente inserito nel registro destinazione <span class="mono">RD</span> indicato nell'istruzione.     </li></ul> </div></div><div class="definition environment" id="def2-13"><h2 class="environment-title">Definizione - Controllo per le istruzioni di Jump</h2><div class="environment-body">     Le <strong>istruzioni di Jump</strong> (ovvero quelle di salto incondizionato) possono essere di formato <span class="mono">J</span> e di formato <span class="mono">R</span>.      Esistono inoltre del tipo "<i>Jump</i>" e del tipo "<i>Jump And Link</i>" (in cui il valore del <span class="mono">PC</span> è salvato nel registro <span class="mono">R31</span>).     <br/>     Il diagramma degli stati associato alle istruzioni di "Jump" sarà quindi il seguente:     <div class="image-environment"><div class="image-wrapper spaced-75"><img alt="Immagine" src="../resources/state-diagram-jump.png"/></div></div>     mentre quello associato alle istruzioni di "Jump And Link" è il seguente:     <div class="image-environment"><div class="image-wrapper spaced-75"><img alt="Immagine" src="../resources/state-diagram-jump-and-link.png"/></div></div>     Si ha quindi che l'esecuzione di entrambi i tipi di istruzione risulta essere piuttosto simile, in generale si ha infatti che:     <ul class="list-container"><li class="list-item">nel caso fosse una istruzione di "Jump And Link", è necessario salvare il valore attuale del <span class="mono">PC</span>;         </li><li class="list-item">in base al formato dell'istruzione, è necessario calcolare il valore del <span class="mono">PC</span> di destinazione.          Si avrà infatti che il valore destinazione sarà uguale al valore del registro indicato oppure come somma tra l'attuale valore del <span class="mono">PC</span> e l'immediato a <span class="math-span">\( 26 \mathrm{ \, bit }\)</span>;         </li><li class="list-item">utilizzando quindi il risultato calcolato e presente nel registro <span class="mono">TEMP</span>, si sovrascrive il valore di <span class="mono">PC</span> e, nel caso di istruzioni "Jump And Link", si sovrascrive il valore di <span class="mono">R31</span> con quello del precedente <span class="mono">PC</span> presente nel registro <span class="mono">C</span>.     </li></ul> </div></div><div class="definition environment" id="def2-14"><h2 class="environment-title">Definizione - Controllo per le istruzioni di Branch</h2><div class="environment-body">     Le <strong>istruzioni di Branch</strong> (ovvero quelle di salto condizionato) sono di due tipi differenti (in base al valore che il registro fornito deve avere affinchè il salto sia preso).      <br/>     Si ha infatti che il diagramma degli stati associato a questo tipo di istruzioni è così formato:     <div class="image-environment"><div class="image-wrapper spaced-75"><img alt="Immagine" src="../resources/state-diagram-branch.png"/></div></div>     Si ha quindi che:     <ul class="list-container"><li class="list-item">inizialmente, ancora ignorando il valore del registro fornito, è calcolato e salvato in <span class="mono">TEMP</span>, il valore destinazione del <span class="mono">PC</span>;         </li><li class="list-item">in base all'istruzione, è valutato il valore del registro (il controllo è effettuato su tutto il registro e non solo sul valore dell'ultimo bit);         </li><li class="list-item">considerando quindi il risultato della valutazione, nel caso il Branch fosse "taken", è trasferito il valore di <span class="mono">TEMP</span> nel <span class="mono">PC</span>.     </li></ul> </div></div><div class="definition environment" id="def2-15"><h2 class="environment-title">Definizione - Problematiche dell'implementazione sequenziale</h2><div class="environment-body">     Considerando questa implementazione, è possibile notare che la logica di progettazione e di funzionamento sono particolarmente semplici.      È tuttavia possibile notare anche che risulta essere particolarmente lenta l'esecuzione di un qualsiasi programma.     <br/>     Infatti, data l'esecuzione di un generico programma, è possibile calcolare il <strong>CPI<sub>medio</sub></strong> (<i><strong>C</strong>ost <strong>P</strong>er <strong>I</strong>nstruction<sub>medio</sub></i>) come     <span class="math-block">\[         CPI_{\text{medio}} = \sum_{i = 1}^n \frac{CPI_i \cdot N_i}{T}       \]</span>     dove <span class="math-span">\( n\)</span> è il numero di istruzioni dell'ISA, <span class="math-span">\( CPI_i\)</span> indica il costo della <span class="math-span">\( i\)</span>-esima istruzione, <span class="math-span">\( N_i\)</span> indica quante volte compare l'<span class="math-span">\( i\)</span>-esima istruzione nel programma e <span class="math-span">\( T\)</span> è il numero totale di istruzioni.     <br/>     Considerando questa implementazione, si ottiene un <span class="math-span">\( CPI\)</span> molto alto che rende molto lenta l'esecuzione di un qualsiasi programma. </div></div>
            </article>
            <nav class="buttons-container content-width">
                <a class="navigation-button previous" href="../funzionamento-della-cpu-in-un-elaboratore/protocollo-di-comunicazione-handshake.html" rel="nofollow"><span>Protocollo di comunicazione handshake</span></a>
                <a class="navigation-button next" href="implementazione-pipelined.html" rel="nofollow"><span>Implementazione pipelined</span></a>
            </nav>
        </section>
        <div class="scroll-to-bottom-button" onclick="scroll_to_bottom()">
            <span class="material-symbols-outlined">
                keyboard_double_arrow_down
            </span>
        </div>
            <footer class="footer-wrapper">
                <div class="copyright-wrapper">
                    <span> &copy; Copyright 2024</span> /
                    <span>made by <a href="https://github.com/lorenzoarlo" rel="nofollow">lorenzoarlo</a></span>
                </div>
                /
                <div class="privacy-wrapper">
                    <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/" rel="nofollow">Pannello preferenze
                            cookie</a></span> /
                    <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/privacy-policy.html" rel="nofollow"
                            target="_blank">Privacy Policy</a></span>
                </div>
            </footer>
    </div>
</body>
</html>