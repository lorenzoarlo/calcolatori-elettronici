<!DOCTYPE html>
<html lang="IT">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="stylesheet" href="../styles/style.css" />
    <link rel="stylesheet" href="../styles/index-style.css" />
    <link rel="stylesheet" href="../styles/content-style.css" />
    <link rel="icon" type="image/x-icon" href="../resources/favicon.ico">
    <meta name="application-name" content="Calcolatori elettronici" />
    <meta name="apple-mobile-web-app-title" content="Calcolatori elettronici" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="#FFD700" />
    <link rel="apple-touch-icon" href="../resources/favicon.png" />
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-78NHLXDQD8"></script>
    <script src="../scripts/script.js"></script>
    <style>:root { --bg-clr: #FFD700; --fg-clr: #262626; }</style>
    <meta name="theme-color" content="#FFD700" />
    <meta name="keywords" content="calcolatori elettronici" />
    <meta name="description" content="Il seguente sito contiene gli appunti e le definizioni del corso 'Calcolatori elettronici T'.">
    <meta name="robots" content="index">
    <script defer async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <title>Calcolatori elettronici - Progettazione DLX - Implementazione sequenziale</title>
</head>
<body>
    <div class="container">
        <header class="header-wrapper">
            <div class="title-wrapper">
                <span class="title">
                    Calcolatori elettronici
                </span>
                <span class="subtitle">
                    by lorenzoarlo
                </span>
            </div>
            <span class="page-title">
                Progettazione DLX
            </span>
        </header>
        <section class="content-wrapper">
            <h1 class="section-title content-width">Implementazione sequenziale</h1>
            <article class="content-container content-width">
                <div class="definition environment" id="def4-1"><h2 class="environment-title">Definizione - Struttura di una CPU</h2><div class="environment-body">     Come è stato detto, la CPU è una rete logica sequenziale sincrona complessa con lo scopo principale di elaborare informazioni.     <br/>     A questo scopo, essa è composta di due parti:     <ul class="list-container"><li class="list-item">il Datapath, un insieme di unità di calcolo (come l'ALU, i registri, ecc.) necessari per l'esecuzione delle istruzioni dell'ISA. Tali istruzioni, affinchè siano eseguite, sono suddivise in micro-operazioni più piccole;          </li><li class="list-item">l'unità di controllo, ovvero una RSS che ad ogni ciclo di clock determina diversi segnali di controllo che condizioneranno quali micro-operazioni dovranno essere eseguite dal Datapath.     </li></ul>     Oltre a queste componenti, la CPU necessita anche di una memoria esterna in cui risiede il programma da eseguire (ovvero le istruzioni) e i dati.     <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/generated-19.png"/></div></div></div></div><div class="definition environment" id="def4-2"><h2 class="environment-title">Definizione - Struttura dei registri e bus dati</h2><div class="environment-body">     Al fine di eseguire le diverse istruzioni, il DLX necessita di diversi registri per conservare le informazioni e di diversi bus per il trasporto di tali dati.     <br/>     I bus (tutti dotati di parallelismo a <span class="math-span">\( 32 \mathrm{ \, bit }\)</span>) necessari sono:     <ul class="list-container"><li class="list-item">i bus <span class="mono">S1</span> e <span class="mono">S2</span>, che trasportano i dati dai registri (ad esempio verso l'ALU);         </li><li class="list-item">il bus <span class="mono">DEST</span>, utile per trasportare i dati verso i registri.     </li></ul>     Considerando ciò, è evidente il motivo per cui tramite le istruzioni è possibile leggere da due registri e scrivere solo verso uno.     <br/>     Oltre a questi, sono presenti diversi registri (sempre a <span class="math-span">\( 32 \mathrm{ \, bit }\)</span>), ovvero:     <ul class="list-container"><li class="list-item">il Register File, ovvero i trentadue registri general purpose accedibile direttamente dal programmatore;         </li><li class="list-item">i registri <span class="mono">A</span> e <span class="mono">B</span>, ovvero i registri che permettono di "ritirare" i dati dal Register File;         </li><li class="list-item">il registro <span class="mono">C</span>, ovvero un registro che permette di inserire i dati nel Register File;          </li><li class="list-item">il Program Counter (anche detto <span class="mono">PC</span>);         </li><li class="list-item">l'Instruction Address Register (anche detto <span class="mono">IAR</span>), in cui è depositato il valore del <span class="mono">PC</span> in caso di ricezione dell'interrupt;         </li><li class="list-item">il Temporary Register (anche detto <span class="mono">TEMP</span>), utile per il deposito temporaneo di risultati intermedi;         </li><li class="list-item">il Memory Address Register (anche detto <span class="mono">MAR</span>), contenente l'indirizzo destinazione di un ciclo di bus di lettura/scrittura;         </li><li class="list-item">il Memory Data Register (anche detto <span class="mono">MDR</span>), contenente i dati di transito temporaneo di un ciclo di bus di lettura/scrittura;         </li><li class="list-item">l'Instruction Register (anche detto <span class="mono">IR</span>), contenuto nell'unità di controllo e contenente l'istruzione attualmente in esecuzione.     </li></ul>     In generale, la struttura può essere così schematizzata     <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/generated-20.png"/></div></div>     Da notare la presenza della memoria, che comunica con:     <ul class="list-container"><li class="list-item">il registro <span class="mono">MAR</span> per poter leggere l'indirizzo desiderato dei cicli di lettura e scrittura;         </li><li class="list-item">il registro <span class="mono">MDR</span> in input per poter fornire i dati durante i cicli di scrittura e in output per poter fornire i dati letti;         </li><li class="list-item">il registro <span class="mono">IR</span> per poter fornire le istruzioni da eseguire durante la fase di fetch.     </li></ul></div></div><div class="definition environment" id="def4-3"><h2 class="environment-title">Definizione - ALU nel DLX</h2><div class="environment-body">     L'ALU è una rete combinatoria facente parte del Datapath del DLX. Essa permette di eseguire le istruzioni aritmetico-logiche utilizzando i dati forniti dai bus <span class="mono">S1</span> e <span class="mono">S2</span>, ad esempio può eseguire:     <ul class="list-container"><li class="list-item">la somma (e differenza) tra <span class="mono">S1</span> e <span class="mono">S2</span>;         </li><li class="list-item">l'AND, l'OR, lo XOR bit-a-bit tra <span class="mono">S1</span> e <span class="mono">S2</span>;         </li><li class="list-item">lo shift logico e aritmetico     </li></ul>     Oltre a questo, fornisce diversi flag in uscita, come:     <ul class="list-container"><li class="list-item">lo Zero Flag, che segnala se il risultato è <span class="mono">0</span>;         </li><li class="list-item">il Sign Flag, che segnala se il risultato è negativo (considerando la rappresentazione in complemento a <span class="math-span">\( 2\)</span>);         </li><li class="list-item">il Carry Flag, che segnala la presenza del riporto.     </li></ul>     Nonostante siano presenti questi flag, non sono presenti registri accedibili dal programmatore per conoscerne il valore. </div></div><div class="definition environment" id="def4-4"><h2 class="environment-title">Definizione - Trasferimento dati sul Datapath</h2><div class="environment-body">     La comunicazione interna al DLX è basata sullo scambio di informazioni tra i bus <span class="mono">S1</span>, <span class="mono">S2</span> e <span class="mono">DEST</span> e i diversi registri.     <br/>     I registri  sono tutti caratterizzati da un comportamento edge-triggered e sono collegati direttamente al clock interno del DLX.      Si ha quindi che in input hanno un collegamento diretto (ovvero non è interposto un driver 3-state) ma è effettuato il campionamento solamente se l'unità di controllo asserisce il segnale Write Enable (tramite appositi segnali).     <div class="image-environment"><div class="image-wrapper spaced-60"><img alt="Immagine" src="../resources/comunicazione-registri.png"/></div></div>     Non è possibile ragionare nello stesso modo per l'output: si ha infatti che i registri incorporano al loro interno uscite con 3-state che "permetteranno il passaggio" del segnale solamente se asseriti i rispettivi segnali Output Enable (ovvero <span class="mono">OE1</span> ed <span class="mono">OE2</span>). </div></div><div class="definition environment" id="def4-5"><h2 class="environment-title">Definizione - Massima frequenza di clock</h2><div class="environment-body">     Conoscendo il funzionamento del trasferimento dati sul Datapath, è possibile capire da cosa dipende la frequenza di clock.      Si ha infatti che il periodo di clock <span class="math-span">\( T_{CK}\)</span> deve essere almeno maggiore della somma tra:     <ul class="list-container"><li class="list-item">tempo (massimo) per la validità dei segnali di controllo <span class="math-span">\( T_C\)</span>, ovvero il ritardo massimo tra il fronte di salita del clock e l'istante in cui i segnali di controllo generati risultino validi;         </li><li class="list-item">tempo (massimo) per la validità dei dati in output <span class="math-span">\( T_{OE}\)</span>, ovvero il ritardo massimo tra l'arrivo del segnale di Output Enable e l'istante in cui i dati sono presenti sul bus;         </li><li class="list-item">tempo (massimo) per la validità del risultato ottenuto dall'ALU <span class="math-span">\( T_{ALU}\)</span>;         </li><li class="list-item">tempo (minimo) di set-up dei registri <span class="math-span">\( T_{SU}\)</span>, ovvero il tempo minimo affinché il dato possa essere campionato dai registri.     </li></ul>     Detto ciò, si ha quindi che     <span class="math-block">\[         T_{CK} \gt T_C + T_{OE} + T_{ALU} + T_{SU}       \]</span></div></div><div class="definition environment" id="def4-6"><h2 class="environment-title">Definizione - Struttura unità di controllo</h2><div class="environment-body">     Dopo aver definito il set di istruzioni e aver progettato il Datapath, è necessario progettare l'unità di controllo.      Tale rete è una rete sequenziale sincrona il cui funzionamento può essere specificato tramite un diagramma degli stati: dato che consideriamo come segnale sincrono il clock, si avrà che ad ogni ciclo di clock corrisponde uno stato.     Come ogni rete sequenziale, sarà necessario tenere conto dello stato presente e degli ingressi per generare lo stato futuro.      In base allo stato, saranno poi generati appositi segnali di controllo diretti al Datapath.     <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/generated-21.png"/></div></div>     Da notare che la struttura di questa rete non è diversa dalla struttura di una generica macchina a stati finiti (Finite State Machine). </div></div><div class="definition environment" id="def4-7"><h2 class="environment-title">Definizione - Esecuzione di un'istruzione</h2><div class="environment-body">     Considerando una generica istruzione, è possibile identificare cinque diverse fasi che descrivono il suo completamento (anche se non sempre sono tutte necessarie).      Si ha infatti:     <ul class="list-container"><li class="list-item">la fase di Instruction Fetch (sempre eseguita) in cui viene prelevata l'istruzione da eseguire dalla memoria e "deposita" nell'Instruction Register;         </li><li class="list-item">la fase di Instruction Decode (sempre eseguita) in cui l'istruzione presente nell'Instruction Register viene decodificata;         </li><li class="list-item">la fase di Execute in cui vi è l'elaborazione aritmetico-logica che utilizza l'ALU;         </li><li class="list-item">la fase di Memory in cui è eseguito l'accesso in memoria;         </li><li class="list-item">la fase di Write-Back in cui si riportano i risultati ottenuti nel Register File.     </li></ul>     Consideriamo ora il diagramma degli stati delle due fasi sempre eseguite.     <span class="inner-title">Fase di Istruction Fetch</span>     La fase di Instruction Fetch è la prima fase per l'esecuzione di ogni istruzione.      Principalmente essa consiste nell'effettuare un accesso in memoria al fine di "prelevare" l'istruzione da eseguire.     Inoltre, in questa fase è necessario intercettare la presenza di eventuali interrupt al fine di eseguire poi i relativi handler.     <br/>     Il diagramma degli stati (in cui ad ogni blocco corrisponde un ciclo di clock) di questa fase è quindi il seguente     <div class="image-environment"><div class="image-wrapper spaced-75"><img alt="Immagine" src="../resources/state-diagram-if-sequenziale.png"/></div></div>     È da notare che il comportamento è differente in base alla ricezione o meno di un interrupt e se la sua ricezione sia abilitata o meno (ovvero il segnale Interrupt Enable <span class="mono">IEN</span> è attivo).     <br/>     Nel caso si stia vivendo una situazione "regolare" si ha che è necessario effettuare un ciclo di lettura alla memoria all'indirizzo del Program Counter <span class="mono">PC</span>: sarà quindi necessario assegnare al Memory Address Register (<span class="mono">MAR</span>) il valore di <span class="mono">PC</span> e leggere tale indirizzo dalla memoria (che fornirà il dato solo quando il segnale <span class="mono">READY</span> sarà asserito dal Memory Controller, come in un tipico ciclo di lettura).     <br/>     Nel caso invece si debba gestire un interrupt, la situazione è differente.     È necessario infatti salvare il valore di <span class="mono">PC</span> nel registro Interrupt Address Register <span class="mono">IAR</span>, assegnare il valore <span class="mono">0000 0000h</span> al <span class="mono">PC</span> (in quanto posizioniamo il codice di gestione degli handler a tale indirizzo) e asserire <span class="mono">IEN = 0</span> (in quanto non prevediamo il nesting). Una volta fatto ciò, è possibile ricominciare la fase di Instruction Fetch.     <div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Un approccio più veloce</h3><div class="environment-body">         Considerando questa soluzione più "classica", si ha che la lettura dell'istruzione è fatta attraverso un tipico ciclo di lettura che prevede il caricamento sul registro <span class="mono">MAR</span> di <span class="mono">PC</span> per effettuare solo successivamente la richiesta di accesso alla memoria.         <br/>         Ciò risulta però non essere la soluzione più efficiente in quanto conosciamo a priori il registro sorgente di quell'assegnamento ed è quindi possibile modificare il Datapath per poter indirizzare la memoria direttamente dal <span class="mono">PC</span>.          Si avrebbe quindi un diagramma degli stati così modificato         <div class="image-environment"><div class="image-wrapper spaced-75"><img alt="Immagine" src="../resources/state-diagram-if-sequenziale-modificato.png"/></div></div>         in cui per ogni istruzione si risparmia un ciclo di clock.     </div></div><span class="inner-title">Fase di Istruction Decode</span>     La fase di Instruction Decode è eseguita immediatamente dopo alla fase di Instruction Fetch. Tale fase risulta essere particolarmente semplice e immediata grazie a diverse scelte fatte sulla struttura delle istruzioni.     <br/>     Come abbiamo già detto, infatti, si ha che ogni istruzione è a lunghezza fissa (ovvero occupa precisamente <span class="math-span">\( 4 \mathrm{ \, Byte }\)</span>) e presenta le informazioni in posizioni predefinite.      Ciò, ci permette di ridurre questa fase a     <div class="image-environment"><div class="image-wrapper spaced-75"><img alt="Immagine" src="../resources/state-diagram-id-sequenziale.png"/></div></div>     Come è evidente dal diagramma, si ha che è possibile eseguire questa fase in un singolo ciclo di clock, in quanto le operazione possono essere eseguite in parallelo. In particolare si ha che:     <ul class="list-container"><li class="list-item">il <span class="mono">PC</span> è incrementato di <span class="mono">+4</span>;         </li><li class="list-item">ignorando quale istruzione è da eseguire, sono "estratti" i valori dei due registri indicati dall'istruzione (nel caso di istruzioni di formato <span class="mono">R</span>) e posti nei registri <span class="mono">A</span> e <span class="mono">B</span>. Si fa ciò per risparmiare successivamente un ciclo di clock, in quanto il caso peggiore che può capitare è il fatto che la sequenza di bit considerata non indicasse dei registri ma altro (in questo caso tali valori non sono utilizzati);         </li><li class="list-item">grazie ad un decoder, è possibile comprendere con una semplice logica combinatoria quale operazione è necessario fare.     </li></ul></div></div><div class="definition environment" id="def4-8"><h2 class="environment-title">Definizione - Logica di estensione del segno nel Datapath</h2><div class="environment-body">     Considerando le istruzioni di formato <span class="mono">I</span> e <span class="mono">J</span>, si ha che all'interno dell'istruzione è codificato anche un immediato.      Tale valore, al fine di essere poi "trasportabile" dai bus dell'ALU, deve essere esteso a <span class="math-span">\( 32 \mathrm{ \, bit }\)</span>.     Per farlo (nel caso di immediati a <span class="math-span">\( 16 \mathrm{ \, bit }\)</span> ma in maniera non dissimile per gli immediati a <span class="math-span">\( 26 \mathrm{ \, bit }\)</span>) si utilizza una rete logica simile a questa (ipotizzando che l'immediato sia posizionato nei bit <span class="mono">IR[15..0]</span>)     <div class="image-environment"><div class="image-wrapper spaced-60"><img alt="Immagine" src="../resources/sign-extension.png"/></div></div>     In quanto gli immediati sono sempre interpretati come valori signed, si ha che è possibile effettuare l'estensione del segno copiando nei bit rimanenti il bit più significativo dell'immediato. </div></div><div class="definition environment" id="def4-9"><h2 class="environment-title">Definizione - Controllo per le istruzioni di Data Transfer</h2><div class="environment-body">     Le istruzioni di Data Transfer (ovvero quelle che coinvolgono cicli di bus) hanno in generale la stessa struttura: sono infatti tutte istruzioni di formato <span class="mono">I</span>, ovvero attraverso l'istruzione saranno forniti due registri (caricati su <span class="mono">A</span> e <span class="mono">B</span>) e un immediato (esteso a <span class="math-span">\( 32 \mathrm{ \, bit }\)</span>).     Considerando le istruzioni di load, il diagramma degli stati associato sarà il seguente:     <div class="image-environment"><div class="image-wrapper spaced-95"><img alt="Immagine" src="../resources/state-diagram-load.png"/></div></div></div></div>
            </article>
            <nav class="buttons-container content-width">
                <a class="navigation-button previous" href="index.html" rel="nofollow"><span>Progettazione DLX</span></a>
                
            </nav>
        </section>
        <div class="scroll-to-bottom-button" onclick="scroll_to_bottom()">
            <span class="material-symbols-outlined">
                keyboard_double_arrow_down
            </span>
        </div>
        <footer class="footer-wrapper">
            <div class="copyright-wrapper">
                <span> &copy; Copyright 2023</span> /
                <span>made by lorenzoarlo</span>
            </div>
            /
            <div class="privacy-wrapper">
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/" rel="nofollow">Pannello preferenze cookie</a></span> /
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/privacy-policy.html" rel="nofollow" target="_blank" >Privacy Policy</a></span>
            </div>
        </footer>
    </div>
</body>
</html>