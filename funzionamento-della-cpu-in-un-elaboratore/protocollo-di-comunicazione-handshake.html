<!DOCTYPE html>
<html lang="IT">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="stylesheet" href="../styles/style.css" />
    <link rel="stylesheet" href="../styles/index-style.css" />
    <link rel="stylesheet" href="../styles/content-style.css" />
    <link rel="icon" type="image/x-icon" href="../resources/favicon.ico">
    <meta name="application-name" content="Calcolatori elettronici" />
    <meta name="apple-mobile-web-app-title" content="Calcolatori elettronici" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="#FFD700" />
    <link rel="apple-touch-icon" href="../resources/favicon.png" />
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-78NHLXDQD8"></script>
    <script src="../scripts/script.js"></script>
    <style>:root { --bg-clr: #FFD700; --fg-clr: #262626; }</style>
    <meta name="theme-color" content="#FFD700" />
    <meta name="keywords" content="calcolatori elettronici" />
    <meta name="description" content="Il seguente sito contiene gli appunti e le definizioni del corso 'Calcolatori elettronici T'.">
    <meta name="robots" content="index">
    <script defer async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <title>Calcolatori elettronici - Funzionamento della CPU in un elaboratore - Protocollo di comunicazione handshake</title>
</head>
<body>
    <div class="container">
        <header class="header-wrapper">
            <div class="title-wrapper">
                <span class="title">
                    Calcolatori elettronici
                </span>
                <span class="subtitle">
                    by lorenzoarlo
                </span>
            </div>
            <span class="page-title">
                Funzionamento della CPU in un elaboratore
            </span>
        </header>
        <section class="content-wrapper">
            <h1 class="section-title content-width">Protocollo di comunicazione handshake</h1>
            <article class="content-container content-width">
                <div class="definition environment" id="def1-41"><h2 class="environment-title">Definizione - Problemi di comunicazione gestita con buffer</h2><div class="environment-body">     Fino a questo momento, abbiamo considerato che la CPU gestisca la comunicazione con qualsiasi periferica esterna e che sia utilizzato come tramite un buffer.     Tale metodologia comporta tuttavia alcune problematiche, ad esempio     <ul class="list-container"><li class="list-item">nessuno garantisce (alla CPU) che la periferica esterna abbia scritto nel buffer, rendendo quindi necessario un continuo controllo dei dati sul buffer (cosa a cui è possibile porre rimedio implementando un segnale di interrupt);         </li><li class="list-item">nella fase di lettura (della CPU) nessuno garantisce (alla periferica) che la CPU abbia letto le informazioni nel buffer (informazione utile per evitare di sovrascrivere informazioni che andrebbero perse) e, analogamente, nessuno garantisce che la periferica abbia letto il dato nella fase di scrittura (della CPU).     </li></ul>     Per risolvere ciò è necessario adottare una forma di sincronizzazione tra produttore (del dato) e consumatore: una possibilità è adottare il protocollo handshake. </div></div><div class="definition environment" id="def1-42"><h2 class="environment-title">Definizione - Protocollo handshake - Porta per input</h2><div class="environment-body">     L'utilizzo del protocollo handshake in input necessita, oltre che entrambi i dispositivi rispettino le temporizzazioni, un dispositivo di interfaccia, ovvero una "porta".     <div class="image-environment"><div class="image-wrapper spaced-75"><img alt="Immagine" src="../resources/handshake-porta-input.png"/></div></div>     Il flusso del funzionamento di tale porta può essere suddiviso in fasi:     <ul class="list-container"><li class="list-item">una fase di "quiete", in cui il buffer interno alla porta non contiene alcun dato interessante.          In questa fase il segnale <span class="mono">IBF</span> (<i><strong>I</strong>nput <strong>B</strong>uffer <strong>F</strong>ull</i>) asserito dalla portà avrà valore <span class="mono">0</span>;         </li><li class="list-item">una fase di scrittura da parte dell'unità esterna nella porta (possibile solo se il buffer è "vuoto", ovvero <span class="mono">IBF = 0</span>) segnata dall'asserzione del segnale <span class="mono">STB</span> (<i><strong>St</strong>ro<strong>b</strong>e</i>).         Al fronte di salita di <span class="mono">STB</span> (ovvero nel momento in cui l'unità esterna sta "esprimendo la volontà" di voler scrivere il dato nel buffer), si ha che sarà asserito anche <span class="mono">IBF = 1</span> (per indicare la presenza di dati);         </li><li class="list-item">terminata la scrittura del dato nel buffer (al fronte di discesa di <span class="mono">STB</span>), la porta dovrà segnalare la presenza di un nuovo dato interno al buffer, asserendo quindi il segnale <span class="mono">INT_R</span> (<i><strong>Int</strong>errupt <strong>R</strong>equest</i>);         </li><li class="list-item">tale richiesta di interrupt rimarrà a valore alto fino a che non inizierà la lettura di questo dato (ovvero al fronte di salita di <span class="mono">RD</span>);         </li><li class="list-item">una volta terminata la lettura (al fronte di discesa di <span class="mono">RD</span>) si avrà che il buffer interno sarà vuoto, segnalando quindi <span class="mono">IBF = 0</span>.     </li></ul>     Riassumendo, si avrà che un tipico ciclo di lettura sarà caratterizzato dal seguente andamento dei segnali:     <div class="image-environment"><div class="image-wrapper spaced-80"><img alt="Immagine" src="../resources/generated-14.png"/></div></div><span class="inner-title">Realizzazione</span>     Realizzare la rete logica che ha questo comportamento risulta essere particolarmente complicato, in quanto è necessario gestire diversi fronti di salita e di discesa contemporaneamente.     Una realizzazione classica porterebbe infatti a clock gating (causato dalla presenza di gate sul clock) o alla necessità di utilizzare segnali asincroni, scelta non felice.     <br/>     Una metodologia per realizzare ciò, è riconoscere i diversi fronti di salita e discesa dato che:     <ul class="list-container"><li class="list-item">il segnale <span class="mono">IBF</span> dovrà avere valore <span class="mono">1</span> al fronte di salita di <span class="mono">STB</span> e valore <span class="mono">0</span> al fronte di discesa di <span class="mono">RD</span>;         </li><li class="list-item">il segnale <span class="mono">INT_R</span> dovrà avere valore <span class="mono">1</span> al fronte di discesa di <span class="mono">STB</span> e valore <span class="mono">0</span> al fronte di salita di <span class="mono">RD</span>.     </li></ul>     Un metodo per riconoscere tali comportamenti è utilizzare un flip-flop D per ogni fronte, ovvero     <div class="image-environment"><div class="image-wrapper spaced-75"><img alt="Immagine" src="../resources/hanshake-input-fronti.png"/></div></div>     In questo modo, tuttavia, si ha che alla fine di ogni "ciclo", i segnali logici rimangono tutti a livello "alto": è possibile ora però ragionare con logica negata per effettuare le relative attivazioni.     <div class="image-environment"><div class="image-wrapper spaced-80"><img alt="Immagine" src="../resources/generated-15.png"/></div></div>     Si avrà quindi che:     <ul class="list-container"><li class="list-item">il segnale <span class="mono">IBF</span> dovrà essere attivo al fronte di salita di <span class="mono">STB</span> ed essere attivo basso al fronte di discesa di <span class="mono">RD</span><div class="center"><span class="mono">IBF = STBSALITA ·  RDDISCESA' + STBSALITA' ·  RDDISCESA</span></div>         in quanto è necessario discriminare anche durante al secondo "ciclo" di lettura (in cui i segnali sono negati);         </li><li class="list-item">il segnale <span class="mono">INT_R</span> dovrà essere attivo al fronte di discesa di <span class="mono">STB</span> ed essere attivo basso al fronte di salita di <span class="mono">RD</span><div class="center"><span class="mono">INT_R = STBDISCESA ·  RDSALITA' + STBDISCESA' ·  RDSALITA</span></div>         in quanto è necessario discriminare anche durante al secondo "ciclo" di lettura (in cui i segnali sono negati);     </li></ul>     Per quanto riguarda il collegamento dati, si ha che i dati sono sicuramente presenti al fronte di discesa di <span class="mono">STB</span>, ovvero si avrà     <div class="image-environment"><div class="image-wrapper spaced-60"><img alt="Immagine" src="../resources/handshake-input-buffer.png"/></div></div></div></div><div class="definition environment" id="def1-43"><h2 class="environment-title">Definizione - Protocollo handshake - Porta per output</h2><div class="environment-body">     L'utilizzo del protocollo handshake in output necessita, oltre che entrambi i dispositivi rispettino le temporizzazioni, un dispositivo di interfaccia, ovvero una "porta".     <div class="image-environment"><div class="image-wrapper spaced-75"><img alt="Immagine" src="../resources/handshake-porta-output.png"/></div></div>     Il flusso del funzionamento di tale porta può essere suddiviso in fasi:     <ul class="list-container"><li class="list-item">una fase di "quiete", in cui il buffer interno alla porta non contiene alcun dato interessante.          In questa fase il segnale <span class="mono">OBF</span> (<i><strong>O</strong>utput <strong>B</strong>uffer <strong>F</strong>ull</i>) asserito dalla portà avrà valore <span class="mono">0</span>. Si avrà quindi che il segnale di <span class="mono">INT_R</span> avrà valore <span class="mono">1</span>, in quanto segnala la possibilità di ricevere un dato;         </li><li class="list-item">una fase di scrittura da parte del processore segnata dall'asserzione del segnale <span class="mono">WR</span>.         Al fronte di salita di <span class="mono">WR</span> (ovvero nel momento in cui il processore sta "esprimendo la volontà" di voler scrivere il dato nel buffer), si ha che sarà asserito anche <span class="mono">INT_R = 0</span>;         </li><li class="list-item">terminata la scrittura del dato nel buffer (al fronte di discesa di <span class="mono">WR</span>), la porta dovrà segnalare la presenza di un nuovo dato interno al buffer, asserendo quindi il segnale <span class="mono">OBF</span> (<i><strong>O</strong>utput <strong>B</strong>uffer <strong>F</strong>ull</i>);         </li><li class="list-item">in questo momento sarà quindi l'unità esterna a dover leggere il dato: tale lettura sarà confermata con il segnale <span class="mono">ACK</span> (<i><strong>Ack</strong>nowledge</i>). Si avrà quindi che al fronte di salita di <span class="mono">ACK</span> il segnale <span class="mono">OBF</span> sarà asserito a valore <span class="mono">0</span> (dato che l'unità esterna ne ha "preso coscienza");         </li><li class="list-item">al termine della lettura (ovvero al fronte di discesa di <span class="mono">ACK</span>) il buffer interno sarà vuoto, segnalando quindi <span class="mono">INT_R = 1</span>.     </li></ul>     Riassumendo, si avrà che un tipico ciclo di scrittura sarà caratterizzato dal seguente andamento dei segnali:     <div class="image-environment"><div class="image-wrapper spaced-80"><img alt="Immagine" src="../resources/generated-16.png"/></div></div><span class="inner-title">Realizzazione</span>     Realizzare la rete logica che ha questo comportamento risulta essere particolarmente complicato, in quanto è necessario gestire diversi fronti di salita e di discesa contemporaneamente.     Una realizzazione classica porterebbe infatti a clock gating (causato dalla presenza di gate sul clock) o alla necessità di utilizzare segnali asincroni, scelta non felice.     <br/>     Una metodologia per realizzare ciò, è riconoscere i diversi fronti di salita e discesa dato che:     <ul class="list-container"><li class="list-item">il segnale <span class="mono">INT_R</span> dovrà avere valore <span class="mono">1</span> di default, valore <span class="mono">0</span> al fronte di salita di <span class="mono">WR</span> e ritornare al valore <span class="mono">1</span> al fronte di salita di <span class="mono">ACK</span>;         </li><li class="list-item">il segnale <span class="mono">OBF</span> dovrà avere valore <span class="mono">1</span> al fronte di discesa di <span class="mono">WR</span> e valore <span class="mono">0</span> al fronte di salita di <span class="mono">ACK</span>.     </li></ul>     Un metodo per riconoscere tali comportamenti è utilizzare un flip-flop D per ogni fronte, ovvero     <div class="image-environment"><div class="image-wrapper spaced-75"><img alt="Immagine" src="../resources/hanshake-input-fronti.png"/></div></div>     In questo modo, tuttavia, si ha che alla fine di ogni "ciclo", i segnali logici rimangono tutti a livello "alto": è possibile ora però ragionare con logica negata per effettuare le relative attivazioni.     <div class="image-environment"><div class="image-wrapper spaced-80"><img alt="Immagine" src="../resources/generated-17.png"/></div></div>     Si avrà quindi che:     <ul class="list-container"><li class="list-item">il segnale <span class="mono">INT_R</span> dovrà essere attivo basso al fronte di salita di <span class="mono">WR</span> ed essere nuovamente attivo alto al fronte di discesa di <span class="mono">ACK</span><div class="center"><span class="mono">INT_R = ((WRSALITA ·  ACKDISCESA') + (WRSALITA ·  ACKDISCESA'))'</span><br/><span class="mono">INT_R = (WRSALITA ·  ACKDISCESA')' ·  (WRSALITA ·  ACKDISCESA')'</span><br/><span class="mono">INT_R = (WRSALITA' + ACKDISCESA) ·  (WRSALITA' + ACKDISCESA)</span></div>         (utilizzando le leggi di De Morgan);         </li><li class="list-item">il segnale <span class="mono">OBF</span> dovrà essere attivo alto al fronte di discesa di <span class="mono">WR</span> ed essere attivo basso al fronte di salita di <span class="mono">ACK</span><div class="center"><span class="mono">OBF = WRDISCESA ·  ACKSALITA' + WRDISCESA' ·  ACKSALITA</span></div>         in quanto è necessario discriminare anche durante al secondo "ciclo" di lettura (in cui i segnali sono negati);     </li></ul>     Per quanto riguarda il collegamento dati, si ha che i dati sono sicuramente presenti al fronte di discesa di <span class="mono">WR</span>, ovvero si avrà     <div class="image-environment"><div class="image-wrapper spaced-60"><img alt="Immagine" src="../resources/handshake-output-buffer.png"/></div></div><div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Sempre ad interrompere...</h3><div class="environment-body">         Considerando questo dispositivo, si ha che continuerebbe a "inviare" segnali di interrupt indipendentemente dalla volontà di scrivere informazioni o meno.         Per risolvere ciò, potrebbe essere utile utilizzare un dispositivo intermedio che attiva o meno la ricezione di questo segnale.     </div></div></div></div><div class="myexample environment" id="example6"><h2 class="environment-title">Esempio - Progetto di sistema basato su DLX con un pulsante, una porta in input e rete di startup</h2><div class="environment-body collapsed">     Progettare un sistema basato sul processore DLX con:     <ul class="list-container"><li class="list-item"><span class="math-span">\( 1 \mathrm{ \, GB }\)</span> di EPROM mappata agli indirizzi bassi;         </li><li class="list-item"><span class="math-span">\( 2 \mathrm{ \, GB }\)</span> di RAM mappata agli indirizzi alti;         </li><li class="list-item">un pulsante <span class="mono">P</span>;         </li><li class="list-item">una porta in input <span class="mono">INPUT_PORT</span> a <span class="math-span">\( 8 \mathrm{ \, bit }\)</span> già progettata che implementa il protocollo di handshake.     </li></ul>     Si ha inoltre che:     <ul class="list-container"><li class="list-item">ad ogni pressione del pulsante <span class="mono">P</span> il registro <span class="mono">R20</span>, che all'avvio deve essere inizializzato al valore <span class="mono">0</span>, è incrementato di <span class="mono">+1</span>.          Si ha inoltre che durante la gestione dell'handler che gestisce tale incremento che è prioritario rispetto alla porta, un LED deve essere accesso.         </li><li class="list-item">il byte (unsigned) letto dalla porta in input deve essere memorizzato all'indirizzo <span class="mono">0xFFFF 0020</span>.         </li><li class="list-item">i registri <span class="mono">R21</span>, <span class="mono">R22</span>, <span class="mono">R23</span>, <span class="mono">R24</span> e <span class="mono">R25</span> possono essere utilizzati senza necessità di essere ripristinati.     </li></ul><span class="inner-title">Spazio di indirizzamento</span>     Per risolvere questo problema, consideriamo innanzitutto gli intervalli di indirizzamento dei dispositivi, si avrà quindi:     <ul class="list-container"><li class="list-item">una memoria EPROM da <span class="math-span">\( 1 \mathrm{ \, GB }\)</span> mappata agli indirizzi bassi, ovvero         <div class="center"><span class="mono">EPROM = [ 0000 0000h, 0000 0000h + 2<sup>30</sup> ] = [ 0000 0000h, 0000 0000h + 3FFF FFFFh ] = [ 0000 0000h, 3FFF FFFFh ]</span></div></li><li class="list-item">una memoria RAM da <span class="math-span">\( 2 \mathrm{ \, GB }\)</span> mappata agli indirizzi alti, ovvero         <div class="center"><span class="mono">RAM = [ FFFF FFFFh - 2<sup>31</sup>, FFFF FFFFh ] = [ FFFF FFFFh - 7FFF FFFF, FFFF FFFFh ] = [ 8000 0000h, FFFF FFFFh ]</span></div></li><li class="list-item">due istruzioni per la gestione della rete di <span class="mono">STARTUP</span>, ovvero la lettura e la scrittura del segnale;         </li><li class="list-item">per la gestione del pulsante <span class="mono">P</span> sono necessarie le seguenti istruzioni:         <ul class="list-container"><li class="list-item">un'istruzione per l'azzeramento del segnale di interrupt del pulsante;             </li><li class="list-item">un'istruzione per la lettura del valore del segnale di interrupt generato dal pulsante;             </li><li class="list-item">un'istruzione utile per il campionamento del segnale di interrupt ed evitare la metastabilità (in quanto potrebbe variare anche durante il campionamento).         </li></ul></li><li class="list-item">un'istruzione per poter attivare la porta in input;     </li></ul>     Avremo quindi una situazione del genere     <div class="image-environment"><div class="image-wrapper spaced-90"><img alt="Immagine" src="../resources/generated-18.png"/></div></div>     Dato ciò, si ha che fisicamente avremo:     <ul class="list-container"><li class="list-item">quattro EPROM da <span class="math-span">\( 2^{28} \text{indirizzi} = 256 \mathrm{ \, MB }\)</span> (che sono disponibili);         </li><li class="list-item">quattro RAM da <span class="math-span">\( 2^{29} \text{indirizzi} = 512 \mathrm{ \, MB }\)</span> (che sono disponibili).     </li></ul><span class="inner-title">Calcolo dei chip select</span>     Ora che abbiamo suddiviso lo spazio di indirizzamento, è possibile procedere al calcolo dei chip select, ovvero     <ul class="list-container"><li class="list-item">per la EPROM, è possibile considerare i seguenti chip select (dato <span class="math-span">\( i \in \{ 0, 1, 2, 3 \}\)</span>)         <div class="center"><span class="mono">CS_EPROM_i = BA[31]' ·  BA[30]' ·  BEi</span></div></li><li class="list-item">per la rete di <span class="mono">STARTUP</span> saranno necessari         <div class="center"><span class="mono">CS_STARTUP_READ = BA[31]' ·  BA[30] ·  BA[29]' ·  BE0 ·  MEMRD</span><br/><span class="mono">CS_STARTUP_WRITE = BA[31]' ·  BA[30] ·  BA[29]' ·  BE2</span></div></li><li class="list-item">per la gestione del pulsante <span class="mono">P</span> avremo         <div class="center"><span class="mono">CS_READ_INT_P = BA[31]' ·  BA[30] ·  BA[29] ·  BA[28]' ·  BE0 ·  MEMRD</span><br/><span class="mono">CS_RESET_INT_P = BA[31]' ·  BA[30] ·  BA[29] ·  BA[28]' ·  BE1 ·  MEMWR</span><br/><span class="mono">CS_FREEZE_INT_P = BA[31]' ·  BA[30] ·  BA[29] ·  BA[28]' ·  BE2 ·  MEMRD</span></div></li><li class="list-item">per l'attivazione di <span class="mono">INPUT_PORT</span> si avrà         <div class="center"><span class="mono">CS_READ_INPUT_PORT = BA[31]' ·  BA[30] ·  BA[29] ·  BA[28]</span></div></li><li class="list-item">per la RAM, è possibile considerare i seguenti chip select (dato <span class="math-span">\( i \in \{ 0, 1, 2, 3 \}\)</span>)         <div class="center"><span class="mono">CS_RAM_i = BA[31] ·  BEi</span></div></li></ul><span class="inner-title">Rete di <span class="mono">STARTUP</span></span>     Per gestire il segnale di <span class="mono">STARTUP</span>, è possibile considerare la seguente rete logica     <div class="image-environment"><div class="image-wrapper spaced-80"><img alt="Immagine" src="../resources/rete-startup-esercizio-handshake.png"/></div></div>     che permette la lettura e la scrittura di tale segnale. Durante l'avvio, si avrà quindi che <span class="mono">STARTUP = 1</span>.     <span class="inner-title">Rete per la gestione di <span class="mono">P</span></span>     Per quanto riguarda la gestione del pulsante <span class="mono">P</span>, sarà necessario utilizzare la seguente rete:     <div class="image-environment"><div class="image-wrapper spaced-80"><img alt="Immagine" src="../resources/rete-button-esercizio-handshake.png"/></div></div>     Considerando tale rete, si ha che può essere vista come divisa in diverse parti. La prima è la rete per la conversione fronte/livello che trasforma, appunto, il segnale di fronte del pulsante in un segnale a livello (chiamato <span class="mono">INT_BUTTON_LEVELED</span>).      Tale segnale è utilizzato inoltre per segnalare l'esecuzione dell'handler tramite il LED.     <br/>     Una volta ottenuto questo segnale, è necessario creare un'altra rete per evitare di campionare un segnale metastabile: utilizziamo quindi un ulteriore flip-flop D che attraverso un ciclo di lettura dummy (ovvero che non trasporta alcun dato importante) campiona il livello del segnale (è necessario attivare <span class="mono">CS_FREEZE_INT_P</span>). Una volta fatto ciò, sarà possibile leggere il valore dell'interrupt (<span class="mono">CS_READ_INT_P</span>).     <span class="inner-title">Collegamenti con i dispositivi</span>     Considerando lo spazio di indirizzamento descritto in precedenza, si avranno i seguenti collegamenti con le memorie e la porta in input, ovvero:     <ul class="list-container"><li class="list-item">considerando le EPROM si avrà         <div class="image-environment"><div class="image-wrapper spaced-60"><img alt="Immagine" src="../resources/eprom-esercizio-handshake.png"/></div></div></li><li class="list-item">considerando le RAM si avrà         <div class="image-environment"><div class="image-wrapper spaced-60"><img alt="Immagine" src="../resources/ram-esercizio-handshake.png"/></div></div></li><li class="list-item">considerando <span class="mono">INPUT_PORT</span> si avrà         <div class="image-environment"><div class="image-wrapper spaced-60"><img alt="Immagine" src="../resources/rete-porta-input-esercizio-handshake.png"/></div></div>         dove il segnale di interrupt generato da <span class="mono">INPUT_PORT</span> è chiamato <span class="mono">INT_PORT</span>;         </li><li class="list-item">considerando l'ingresso <span class="mono">INT</span> del DLX, si ha che esso sarà uguale a         <div class="center"><span class="mono">(DLX'S) INT = (INT_BTN_SYNC + INT_PORT) ·  STARTUP'</span></div>         Da notare che è presente il condizionamento del segnale <span class="mono">STARTUP</span>, in quanto si vuole disabilitare la gestione degli interrupt durante la fase di avvio.     </li></ul><span class="inner-title">Codice di avvio e interrupt handlers</span>     Date le diverse reti e ricordando la necessità di inizializzare all'avvio il registro <span class="mono">R20</span>, di gestire il l'interrupt generato dal pulsante in maniera prioritaria, si avrà che il codice posto a partire dall'indirizzo <span class="mono">0x0000 0000</span> sarà il seguente     <pre class="code-block"><code>            LHI R21, 0x4000         ; R21 = 4000 0000h per il segnale STARTUP
            LB R22, 0x0000(R21)     ; Lettura di STARTUP
            BNEZ R22, ON_STARTUP    ; Salta a ON_STARTUP se STARTUP != 0 

            LHI R21, 0x6000         ; R21 = 6000 0000h per i segnali su INT_BUTTON
            LB R25, 0x0002(R21)     ; Istruzione dummy per il FREEZE dell'interrupt
            LB R22, 0x0000(R21)     ; Lettura di INT_P
            BEQZ R22, PORT_HANDL    ; Salta a PORT_HANDL se INT_P = 0
            ADDUI R20, 0x0001       ; R20 = R20 + 1
            SB R0, 0x0001(R21)      ; Reset di INT_P
            RFE                     ; Termina handler

PORT_HANDL: LHI R21, 0x7000         ; R21 = 7000 0000h per attivare INPUT_PORT
            LBU R22, 0x0000(R21)    ; Lettura da INPUT_PORT
            LHI R21, 0xFFFF         ; R21 = FFFF 0000h per scrittura in memoria
            SBU R22, 0x0020(R21)    ; Scrittura in memoria del dato
            RFE

ON_STARTUP: ADD R20, R0, R0         ; R20 = 0
            SB R0, 0x0002(R21)      ; Imposta STARTUP = 0 </code></pre></div><div class="environment-tail"><span class="material-symbols-outlined body-visibility-icon" onclick="expand_environment(event)">expand_more</span></div></div>
            </article>
            <nav class="buttons-container content-width">
                <a class="navigation-button previous" href="eventi-e-interruzioni.html" rel="nofollow"><span>Eventi e interruzioni</span></a>
                <a class="navigation-button next" href="../progettazione-dlx/index.html" rel="nofollow"><span>Progettazione DLX</span></a>
            </nav>
        </section>
        <div class="scroll-to-bottom-button" onclick="scroll_to_bottom()">
            <span class="material-symbols-outlined">
                keyboard_double_arrow_down
            </span>
        </div>
        <footer class="footer-wrapper">
            <div class="copyright-wrapper">
                <span> &copy; Copyright 2023</span> /
                <span>made by lorenzoarlo</span>
            </div>
            /
            <div class="privacy-wrapper">
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/" rel="nofollow">Pannello preferenze cookie</a></span> /
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/privacy-policy.html" rel="nofollow" target="_blank" >Privacy Policy</a></span>
            </div>
        </footer>
    </div>
</body>
</html>