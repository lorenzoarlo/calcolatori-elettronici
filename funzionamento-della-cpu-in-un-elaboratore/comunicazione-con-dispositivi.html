<!DOCTYPE html>
<html lang="IT">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="stylesheet" href="../styles/style.css" />
    <link rel="stylesheet" href="../styles/index-style.css" />
    <link rel="stylesheet" href="../styles/content-style.css" />
    <link rel="icon" type="image/x-icon" href="../resources/favicon.ico">
    <meta name="application-name" content="Calcolatori elettronici" />
    <meta name="apple-mobile-web-app-title" content="Calcolatori elettronici" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="#FFD700" />
    <link rel="apple-touch-icon" href="../resources/favicon.png" />
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-78NHLXDQD8"></script>
    <script src="../scripts/script.js"></script>
    <style>:root { --bg-clr: #FFD700; --fg-clr: #262626; }</style>
    <meta name="theme-color" content="#FFD700" />
    <meta name="keywords" content="calcolatori elettronici" />
    <meta name="description" content="Il seguente sito contiene gli appunti e le definizioni del corso 'Calcolatori elettronici T'.">
    <meta name="robots" content="index">
    <script defer async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <title>Calcolatori elettronici - Funzionamento della CPU in un elaboratore - Comunicazione con dispositivi</title>
</head>
<body>
    <div class="container">
        <header class="header-wrapper">
            <div class="title-wrapper">
                <span class="title">
                    Calcolatori elettronici
                </span>
                <span class="subtitle">
                    by lorenzoarlo
                </span>
            </div>
            <span class="page-title">
                Funzionamento della CPU in un elaboratore
            </span>
        </header>
        <section class="content-wrapper">
            <h1 class="section-title content-width">Comunicazione con dispositivi</h1>
            <article class="content-container content-width">
                <div class="definition environment" id="def1-6"><h2 class="environment-title">Definizione - Comunicazione nel modello di Von-Neumann</h2><div class="environment-body">     Nel modello di Von-Neumann le istruzioni risiedono in memoria, ma per leggere (e scrivere) la CPU utilizza segnali predefiniti temporizzati da un preciso ciclo di bus.     <br/>     Esistono infatti tre tipi di bus di comunicazione tra CPU, Memoria e le varie periferiche:     <ul class="list-container"><li class="list-item">l'<strong>Address Bus</strong> (<span class="mono">BA[...]</span>) <strong>unidirezionale</strong> (da CPU a memoria e periferiche);         </li><li class="list-item">il <strong>Data Bus</strong> (<span class="mono">BD[...]</span>) <strong>bidirezionale</strong>;         </li><li class="list-item">il <strong>Control Bus</strong> composto dai segnali:         <ul class="list-container"><li class="list-item"><strong>Read</strong> e <strong>Write</strong> (da CPU a memoria e periferiche), per indicare la volontà di lettura o scrittura verso le periferiche;             </li><li class="list-item"><strong>Ready</strong> e <strong>Int</strong> (da memoria e periferiche a CPU), per indicare il momento in cui la periferica è "pronta" a ricevere o fornire i dati (il segnale <strong>Ready</strong>) e per allertare la CPU di qualcosa che è accaduto (il segnale <strong>Int</strong>, <strong>Interrupt</strong>) .         </li></ul></li></ul><div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Ad esempio - Segnale di Interrupt</h3><div class="environment-body">         Un utilizzo del segnale di Interrupt può essere legato alla gestione di segnali temporali (ad esempio una sveglia).          Si evita infatti di far "contare il tempo che passa" al processore ma si "delega" tale compito, per esempio, ad un contatore esterno che una volta terminato il conteggio invierà un segnale di Interrupt al processore, che verificherà poi il motivo di tale interruzione.     </div></div></div></div><div class="definition environment" id="def1-7"><h2 class="environment-title">Definizione - Ciclo di bus</h2><div class="environment-body">     L'<strong>evoluzione temporale</strong> di alcuni segnali che interagiscono con una CPU si definiscono come <strong>ciclo di bus</strong>.     <br/>     L'unico modo per interagire con un sistema di questo tipo, consiste nel seguire le <strong>regole descritte</strong> da tale ciclo ed indicate dal costruttore nel relativo data sheet.     <br/>     Ad ogni ciclo di bus si ha quindi che nell'Address Bus è presente l'<strong>indirizzo della memoria o della periferica</strong>, nel Data Bus le <strong>informazioni da leggere o da scrivere</strong> e il Control Bus fornisce <strong>informazioni sull'operazione da svolgere o sullo stato della periferiche</strong>.     <br/>     Un ciclo di bus può durare più cicli di clock e può anche terminare in maniera asincrona.      <div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Ad esempio - Ciclo di bus di lettura</h3><div class="environment-body">         Consideriamo un prototipo di ciclo di bus di lettura         <div class="image-environment"><div class="image-wrapper spaced-90"><img alt="Immagine" src="../resources/generated-0.png"/></div></div>         Si ha quindi che la CPU emette l'indirizzo sull'Address Bus e negli istanti successivi la sua intenzione di lettura (segnale <span class="mono">Read</span>).          A questo punto, la CPU aspetta il segnale di <span class="mono">Ready</span> per poter "ritirare" il dato immesso dalla periferica (sul Data Bus).     </div></div><div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Ad esempio - Ciclo di bus di scrittura</h3><div class="environment-body">         Consideriamo un prototipo di ciclo di bus di scrittura         <div class="image-environment"><div class="image-wrapper spaced-90"><img alt="Immagine" src="../resources/generated-1.png"/></div></div>         Si ha quindi che la CPU emette l'indirizzo sull'Address Bus e negli istanti successivi la sua intenzione di scrittura (segnale <span class="mono">Write</span>).          A questo punto, la CPU aspetta il segnale di <span class="mono">Ready</span> per poter "inserire" il dato nella periferica (già caricato in precedenza sul Data Bus).     </div></div></div></div><div class="definition environment" id="def1-8"><h2 class="environment-title">Definizione - Indirizzamento e spazio di indirizzamento</h2><div class="environment-body">     La CPU "emette" sull'Address Bus diversi indirizzi: in particolare si ha che se il bus è composto da <span class="math-span">\( 20\)</span> bit, lo spazio di indirizzamento sarà composto da <span class="math-span">\( 2^{20}\)</span> indirizzi.      Ipotizzando inoltre la grandezza del Data Bus di <span class="math-span">\( 1 \mathrm{ \, Byte }\)</span> (scelta anacronistica ma conveniente per i ragionamenti), si avrà (nel caso dei <span class="math-span">\( 20\)</span> bit di indirizzo) uno spazio di indirizzamento di <span class="math-span">\( 1 \mathrm{ \, MB }\)</span>.     <br/>     Dato tale spazio, affinchè un dispositivo fisico (ad esempio una memoria) possa essere accessibile, deve essere <strong>mappato nello spazio di indirizzamento</strong>, ovvero deve essergli assegnata una finestra di indirizzi.     <div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Ad esempio</h3><div class="environment-body">         Considerando di avere una memoria da <span class="math-span">\( 64 \mathrm{ \, MB }\)</span> (<span class="math-span">\( 2^6 \cdot 2^{20} \mathrm{ \, Byte }\)</span>, ovvero <span class="math-span">\( 2^36 \mathrm{ \, Byte }\)</span>) ed un Address Bus di <span class="math-span">\( 1 \mathrm{ \, Byte }\)</span>, per poter indirizzare tale memoria saranno necessari almeno <span class="math-span">\( 2^36\)</span> indirizzi (ad ogni "dato" un indirizzo).     </div></div></div></div><div class="definition environment" id="def1-9"><h2 class="environment-title">Definizione - Driver 3-state</h2><div class="environment-body">     Il <strong>driver 3-state</strong> è una rete logica     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/driver3state-disabled.png"/></div></div>     che è caratterizzata da:     <ul class="list-container"><li class="list-item">un ingresso <span class="mono">I</span>;         </li><li class="list-item">un ingresso <span class="mono">OE</span> (<i>Output Enable</i>);         </li><li class="list-item">un'uscita <span class="mono">U</span></li></ul>     Tale driver (un componente che non altera il segnale logico) permette l'introduzione di un "terzo stato", detto di "<strong>alta impedenza</strong>", che ha un effetto logico paragonabile "all'interruzione del cavo": a livello fisico, la tensione non assume un valore preciso ma rende il segnale in uscita "neutrale" rispetto al valore fornito da un altro componente.     <br/>     Esso è quindi descritto dalla seguente tabella della verità:     <div class="image-environment"><div class="image-wrapper spaced-20"><img alt="Immagine" src="../resources/generated-2.png"/></div></div>     dove <span class="mono">Z</span> indica lo stato di alta impedenza.     <br/>     Si ha quindi che con l'ingresso <span class="mono">OE = 1</span>, ovvero     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/driver3state-enabled.png"/></div></div>     tale componente diventa "trasparente", altrimenti "blocca" il segnale </div></div><div class="definition environment" id="def1-10"><h2 class="environment-title">Definizione - Decoder di I e II livello</h2><div class="environment-body">     La CPU per poter scrivere e leggere dei dati, emette l'indirizzo della cella di memoria interessata: a questo punto tale indirizzo viene fornito in input ad un decoder di I livello che in base al valore dei bit più significativi di tale indirizzo, abiliterà o disabiliterà (grazie ad un driver 3-state) un apposito ingresso del dispositivo (detto "Chip Select" o "Chip Enable", CS o CE).     <br/>     A questo punto, l'indirizzo è ulteriormente decodificato da un decoder di II livello (interno al dispositivo) che "collegherà" la parte corretta della memoria. </div></div><div class="definition environment" id="def1-11"><h2 class="environment-title">Definizione - Struttura di una generico dispositivo collegato alla CPU</h2><div class="environment-body">     Considerando un sistema caratterizzato da <span class="math-span">\( n\)</span> bit di dati, un generico dispositivo compatibile sarà caratterizzato da:     <ul class="list-container"><li class="list-item">un segnale di <span class="mono">Chip Select</span> (<strong>CS</strong>) del dispositivo;         </li><li class="list-item">un bus di <span class="math-span">\( k\)</span> bit utili per la decodifica di II livello;         </li><li class="list-item">un segnale di controllo per indicare la lettura ed uno per indicare la scrittura;         </li><li class="list-item">un bus di <span class="math-span">\( n\)</span> bit di dati.     </li></ul></div></div><div class="definition environment" id="def1-12"><h2 class="environment-title">Definizione - Memorie EPROM</h2><div class="environment-body">     Le memorie <strong>EPROM</strong> (<i>Erasable Programmable Read Only Memory</i>), sono memorie non volatili a sola lettura (durante l'utilizzo).     <br/>     Esse sono caratterizzate dai segnali:     <ul class="list-container"><li class="list-item"><span class="mono">CE</span> (<i>Chip Enable</i>), per abilitare o meno il dispositivo;         </li><li class="list-item"><span class="mono">OE</span> (<i>Output Enable</i>), per connettere "l'output" del dispositivo con il Bus Dati (sarà quindi attivo nel caso della lettura).     </li></ul>     Tali segnali devono variare seguendo i vari tempi indicati nel data-sheet.     <br/>     Per motivi storici, tali memorie hanno solitamente capacità il cui valore è multiplo di <span class="math-span">\( 2\)</span> (ad esempio <span class="math-span">\( 32\mathrm{ \, KB }\)</span>, <span class="math-span">\( 64\mathrm{ \, KB }\)</span>, <span class="math-span">\( 128\mathrm{ \, KB }\)</span>, eccetera). </div></div><div class="definition environment" id="def1-13"><h2 class="environment-title">Definizione - Memorie SRAM</h2><div class="environment-body">     Le memorie <strong>SRAM</strong> (<i>Static Random Access Memory</i>), sono memorie volatili leggibili e scrivibili.      Si differenziano dalle <strong>DRAM</strong> (<i>Dynamic RAM</i>) per la tecnologia impiegata (le DRAM utilizzano condensatori in modo da essere meno energivore).     <br/>     Esse sono caratterizzate dai segnali:     <ul class="list-container"><li class="list-item"><span class="mono">CE</span> (<i>Chip Enable</i>), per abilitare o meno il dispositivo;         </li><li class="list-item"><span class="mono">OE</span> (<i>Output Enable</i>), per connettere "l'output" del dispositivo con il Bus Dati (attivo quindi nel caso della lettura);         </li><li class="list-item"><span class="mono">WE</span> (<i>Write Enable</i>), per connettere "l'input" del dispositivo con il Bus Dati (attivo quindi nel caso della scrittura).     </li></ul>     Tali segnali devono variare seguendo i vari tempi indicati nel data-sheet.     <br/>     Per motivi storici, tali memorie hanno solitamente capacità distanti un multiplo di <span class="math-span">\( 4\)</span> (ad esempio <span class="math-span">\( 8\mathrm{ \, KB }\)</span>, <span class="math-span">\( 32\mathrm{ \, KB }\)</span>, <span class="math-span">\( 128\mathrm{ \, KB }\)</span>).     <br/>     A livello strutturale, una singolo bit di una SRAM (la <span class="math-span">\( j\)</span>-esima cella composta da <span class="math-span">\( k\)</span> bit) è così composto     <div class="image-environment"><div class="image-wrapper spaced-80"><img alt="Immagine" src="../resources/cella-sram.png"/></div></div>     in particolare si ha che     <ul class="list-container"><li class="list-item">il segnale <span class="mono">DECODER II LIVELLO</span> sarà fornito dal decoder in base all'indirizzo e abiliterà le <span class="math-span">\( k\)</span> celle (dato che ad ogni indirizzo è composto da <span class="math-span">\( k\)</span> celle) del <span class="math-span">\( j\)</span>-esimo indirizzo.         </li><li class="list-item">il segnale <span class="mono">OE</span> rende (nel caso la cella sia all'indirizzo desiderato) il driver 3-state trasparente permettendo quindi l'inserimento sul Data Bus;         </li><li class="list-item">il segnale <span class="mono">WE</span> rende (nel caso la cella sia all'indirizzo desiderato) il driver 3-state bloccante e collega il dato presente sul Data Bus all'ingresso <span class="mono">D</span> del Latch (che sovrascriverà il dato presente in precedenza).     </li></ul></div></div><div class="definition environment" id="def1-14"><h2 class="environment-title">Definizione - Mappatura di dispositivi</h2><div class="environment-body">     Affinchè la CPU possa comunicare con un dispositivo, è necessario che esso sia mappato nello spazio di indirizzamento. Si ha inoltre che tali finestre di indirizzi da assegnare devono essere contigue.     <br/>     Si consideri un sistema ad <span class="math-span">\( n\)</span> bit ed un dispositivo con <span class="math-span">\( k\)</span> bit di indirizzo interno (ovvero che "andranno in pasto" al decoder di II livello).      In totale, tali dispositivi occuperanno <span class="mono">M = <span class="math-span">\( 2^k\)</span></span> indirizzi nello spazio di indirizzamento.     Un dispositivo si dice mappato ad un certo indirizzo <span class="mono">A</span> se gli indirizzi del dispositivo sono compresi tra <span class="mono">A</span> e <span class="mono">A + (M - 1)</span>.     <br/>     Si dice inoltre che un certo indirizzo è allineato se <span class="mono">A</span> è multiplo di <span class="mono">M</span>, ovvero se     <div class="center"><span class="mono">M modulo A = 0</span></div>     In questo caso, se un dispositivo è allineato, il primo indirizzo a lui corrispondente (<span class="math-span">\( A\)</span>) avrà i <span class="math-span">\( k\)</span> bit meno significativi (degli <span class="math-span">\( n\)</span> totali) a <span class="math-span">\( 0\)</span>.     <br/>     È possibile quindi dividere un generico indirizzo <span class="math-span">\( X\)</span> per il dispositivo in due parti     <span class="math-block">\[         X = \alpha \mid \beta       \]</span>     La parte <span class="math-span">\( \beta\)</span> è composta dai <span class="math-span">\( k\)</span> bit del dispositivo, mentre la parte <span class="math-span">\( \alpha\)</span> è composta dagli <span class="math-span">\( n - k\)</span> bit.      <br/>     In questo modo si avrà quindi che la decodifica della parte <span class="math-span">\( \alpha\)</span> è quella detta di I livello (a carico del progettista del sistema) mentre quella della parte <span class="math-span">\( \beta\)</span> è a carico del dispositivo.     <br/>     Una decodifica si dice completa se nella decodifica si utilizzano tutti i <span class="math-span">\( n - k\)</span> bit di <span class="math-span">\( \alpha\)</span>. Se non è questo il caso, si dice che la decodifica è semplificata. </div></div><div class="myexample environment" id="example1"><h2 class="environment-title">Esempio - "Mappare" dei dispositivi</h2><div class="environment-body collapsed">     Considerando un sistema con un Address Bus di <span class="math-span">\( 16 \mathrm{ \, bit }\)</span> e un Data Bus di <span class="math-span">\( 8 \mathrm{ \, bit }\)</span>, scrivere le espressioni di decodifica di I livello completa e semplificata nei casi:     <ul class="list-container"><li class="list-item">è presente un solo dispositivo di memoria da <span class="math-span">\( 16 \mathrm{ \, KB }\)</span> mappato all'indirizzo esadecimale <span class="mono">8000h</span>;         </li><li class="list-item">è presente un solo dispositivo di memoria da <span class="math-span">\( 8 \mathrm{ \, KB }\)</span> mappato all'indirizzo esadecimale <span class="mono">0000h</span>;         </li><li class="list-item">sono presenti un dispositivo di memoria <span class="mono">A</span> da <span class="math-span">\( 16 \mathrm{ \, KB }\)</span> mappato all'indirizzo esadecimale <span class="mono">8000h</span> e un dispositivo di memoria <span class="mono">B</span> da <span class="math-span">\( 8 \mathrm{ \, KB }\)</span> mappato all'indirizzo esadecimale <span class="mono">0000h</span>.     </li></ul>     Consideriamo il primo caso, ovvero il dispositivo di memoria da <span class="math-span">\( 16 \mathrm{ \, KB }\)</span> mappato all'indirizzo esadecimale <span class="mono">8000h</span>.      In questo caso, si ha che tale dispositivo necessita di <span class="math-span">\( 2^4 \cdot 2^{10} = 2^{14}\)</span> indirizzi.      Si ha quindi che la decodifica di I livello potrà coinvolgere solo i <span class="math-span">\( 16 - 14 = 2\)</span> bit di indirizzo più significativi.     Considerando inoltre il primo indirizzo <span class="mono">8000h</span> si avrà che     <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/generated-3.png"/></div></div>     È necessario quindi scrivere le espressioni corrispondenti ad <span class="math-span">\( \alpha\)</span>. La decodifica completa si ha che deve utilizzare entrambi i bit di <span class="math-span">\( \alpha\)</span>: in questo caso si avrà che l'espressione completa per il chip select è data da     <div class="center"><span class="mono">CS<sub>COMPLETA</sub> = BA[15] <span class="math-span">\( \cdot\)</span> BA[14]'</span></div>     mentre quella semplice (minima) è     <div class="center"><span class="mono">CS<sub>SEMPLICE</sub> = 1</span></div>     in quanto è presente un solo dispositivo (si ha quindi che corrisponde a tutto lo spazio di indirizzamento).     <br/>     Consideriamo ora il secondo caso, ovvero il dispositivo di memoria da <span class="math-span">\( 8\mathrm{ \, KB }\)</span> mappato all'indirizzo esadecimale <span class="mono">0000h</span>.      In questo caso, si ha che tale dispositivo necessita di <span class="math-span">\( 2^3 \cdot 2^{10} = 2^{13}\)</span> indirizzi e si ha che la decodifica di I livello potrà coinvolgere solo i <span class="math-span">\( 16 - 13 = 3\)</span> bit di indirizzo più significativi.      Considerando quindi il primo indirizzo <span class="mono">0000h</span> si ha che     <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/generated-4.png"/></div></div>     Le espressioni corrispondenti ad <span class="math-span">\( \alpha\)</span> saranno quindi     <div class="center"><span class="mono">CS<sub>COMPLETA</sub> = BA[15]' <span class="math-span">\( \cdot\)</span> BA[14]' <span class="math-span">\( \cdot\)</span> BA[13]'</span></div>     e     <div class="center"><span class="mono">CS<sub>SEMPLICE</sub> = 1</span></div>     per gli stessi motivi del caso precedente.     <br/>     Considerando invece l'ultimo caso, in cui i dispositivi devono convivere, si ha che le espressioni di decofica completa saranno identiche ai casi precedenti, ovvero     <div class="center"><span class="mono">CS_A<sub>COMPLETA</sub> = BA[15] <span class="math-span">\( \cdot\)</span> BA[14]'</span><br/><span class="mono">CS_B<sub>COMPLETA</sub> = BA[15]' <span class="math-span">\( \cdot\)</span> BA[14]' <span class="math-span">\( \cdot\)</span> BA[13]'</span></div>     mentre per la decodifica semplice si ha che è possibile considerare le differenze nei bit più significativi, ovvero si ha che     <div class="center"><span class="mono">CS_A<sub>SEMPLICE</sub> = BA[15]</span><br/><span class="mono">CS_B<sub>SEMPLICE</sub> = BA[15]'</span></div></div><div class="environment-tail"><span class="material-symbols-outlined body-visibility-icon" onclick="expand_environment(event)">expand_more</span></div></div><div class="myexample environment" id="example2"><h2 class="environment-title">Esempio - Comandare un Flip-Flop D con una CPU</h2><div class="environment-body collapsed">     Considerando un sistema con un Address Bus di <span class="math-span">\( 20 \mathrm{ \, bit }\)</span> e un Data Bus di <span class="math-span">\( 8 \mathrm{ \, bit }\)</span> con:     <ul class="list-container"><li class="list-item"><span class="math-span">\( 64 \mathrm{ \, KB }\)</span> di memoria EPROM posizionati negli "indirizzi bassi";          </li><li class="list-item"><span class="math-span">\( 64 \mathrm{ \, KB }\)</span> di memoria RAM posizionati negli "indirizzi alti".     </li></ul>     Si vuole comunicare con un Flip Flop D      <div class="image-environment"><div class="image-wrapper spaced-30"><img alt="Immagine" src="../resources/flip-flop-d-set-reset.png"/></div></div>     e impartigli i comandi di:     <ul class="list-container"><li class="list-item">scrittura nel Flip-flop;         </li><li class="list-item">lettura nel Flip-flop;         </li><li class="list-item">set asincrono del Flip-flop;         </li><li class="list-item">reset asincrono del Flip-flop.     </li></ul><span class="inner-title">Mappatura</span>     Per risolvere questo problema, consideriamo innanzitutto la mappatura dei dispositivi.      <br/>     La EPROM necessita di <span class="math-span">\( 2^6 \cdot 2^{10} = 2^{16}\)</span> indirizzi e sappiamo inoltre che è posizionata negli indirizzi bassi (ovvero a partire da <span class="mono">00000h</span>).     Considerando ciò, si ha che la EPROM occuperà l'intervallo di indirizzi     <div class="center"><span class="mono">EPROM = [ 00000h, 00000h + 2<sup>16</sup> ] = [ 00000h, 00000h + 0FFFFh ] = [ 00000h, 0FFFFh ]</span></div>     Per quanto riguarda la RAM, si ha che non sono disponibili memorie RAM di <span class="math-span">\( 64\mathrm{ \, KB }\)</span>.     Per risolvere ciò è tuttavia possibile considerare di utilizzare due memorie da <span class="math-span">\( 32 \mathrm{ \, KB }\)</span> l'una.     Per trovare il primo loro indirizzo, è possibile considerare che il loro ultimo indirizzo è <span class="mono">FFFFFh</span> e occupano <span class="math-span">\( 2^{15}\)</span> indirizzi l'una.      Si avrà quindi che la prima RAM (quella più "in alto") occuperà gli indirizzi     <div class="center"><span class="mono">RAM_1 = [ FFFFFh - 2<sup>15</sup>, FFFFFh ] = [ FFFFFh - 0EFFFh, FFFFFh ] = [ F8000h, FFFFFh ]</span></div>     mentre la seconda (quella più "in basso") avrà come indirizzo superiore il primo disponibile al di sotto della <span class="math-span">\( RAM_1\)</span>, ovvero <span class="math-span">\( F8000h - 00001h = F7FFFh\)</span>, da cui     <div class="center"><span class="mono">RAM_2 = [ F7FFFh - 2<sup>15</sup>, F7FFFh ] = [ F7FFFh - 0EFFFh, F7FFFh ] = [ F0000h, F7FFFh ]</span></div>     Sono ora necessari quattro indirizzi per i quattro comandi che si vogliono impartire al Flip-Flop. È possibile scegliere degli indirizzi tra tutti quelli non utilizzati.     Scegliamo arbitrariamente i seguenti indirizzi:     <ul class="list-container"><li class="list-item">il comando di lettura sincrona all'indirizzo <span class="mono">80000h</span>;         </li><li class="list-item">il comando di scrittura sincrona all'indirizzo <span class="mono">80001h</span>;         </li><li class="list-item">il comando di reset asincrono all'indirizzo <span class="mono">80002h</span>;         </li><li class="list-item">il comando di set asincrono all'indirizzo <span class="mono">80003h</span>.     </li></ul>     Possiamo ora calcolare le espressioni di decodifica (utilizzando una decodifica semplice) di ogni dispositivo.      <br/>     In particolare consideriamo di avere un solo dispositivo nella prima metà dello spazio d'indirizzamento (la EPROM), per cui è possibile assegnargli l'intera metà, ovvero     <div class="center"><span class="mono">CS_EPROM = BA[19]'</span></div>     Considerando invece la seconda metà in cui convivono i vari comandi e le due RAM:     <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/generated-5.png"/></div></div>     Si ha quindi che:     <ul class="list-container"><li class="list-item">il bit <span class="mono">BA[19]</span> (evidenziato in rosso) è necessario per identificare la seconda metà dello spazio di indirizzamento;         </li><li class="list-item">il bit <span class="mono">BA[18]</span> (evidenziato in arancione) è necessario per distinguere tra i dispositivi RAM (<span class="mono">BA[18]</span>) e i comandi (<span class="mono">BA[18]'</span>);         </li><li class="list-item">il bit <span class="mono">BA[15]</span> (evidenziato in blu) è necessario per distinguere tra le due RAM (<span class="mono">BA[15]</span> per <span class="mono">RAM_1</span>, <span class="mono">BA[15]'</span> per <span class="mono">RAM_2</span>);         </li><li class="list-item">i bit <span class="mono">BA[1]</span> e <span class="mono">BA[0]</span> (evidenziati in verde) sono necessari per distinguere i vari comandi.     </li></ul>     Si avrà quindi che i chip select saranno uguali a:     <ul class="list-container"><li class="list-item">il chip select della <span class="mono">RAM_1</span> sarà         <div class="center"><span class="mono">CS_RAM_1 = BA[19] <span class="math-span">\( \cdot\)</span> BA[18] <span class="math-span">\( \cdot\)</span> BA[15]</span></div></li><li class="list-item">il chip select della <span class="mono">RAM_2</span> sarà         <div class="center"><span class="mono">CS_RAM_2 = BA[19] <span class="math-span">\( \cdot\)</span> BA[18] <span class="math-span">\( \cdot\)</span> BA[15]'</span></div></li><li class="list-item">il chip select del comando di lettura sincrono sarà         <div class="center"><span class="mono">CS_READ = BA[19] <span class="math-span">\( \cdot\)</span> BA[18]' <span class="math-span">\( \cdot\)</span> BA[1]' <span class="math-span">\( \cdot\)</span> BA[0]' <span class="math-span">\( \cdot\)</span> MEMREAD</span></div>         Oltre all'espressione di decodifica è presente anche il comando di <span class="mono">MEMREAD</span> per evitare malfunzionamenti durante i transitori;         </li><li class="list-item">il chip select del comando di scrittura sincrono sarà         <div class="center"><span class="mono">CS_READ = BA[19] <span class="math-span">\( \cdot\)</span> BA[18]' <span class="math-span">\( \cdot\)</span> BA[1]' <span class="math-span">\( \cdot\)</span> BA[0]</span></div></li><li class="list-item">il chip select del comando di reset asincrono sarà         <div class="center"><span class="mono">CS_RESET_ASYNC = BA[19] <span class="math-span">\( \cdot\)</span> BA[18]' <span class="math-span">\( \cdot\)</span> BA[1] <span class="math-span">\( \cdot\)</span> BA[0]' <span class="math-span">\( \cdot\)</span> MEMWRITE</span></div>         Oltre all'espressione di decodifica è presente anche il comando di <span class="mono">MEMWRITE</span> per evitare malfunzionamenti durante i transitori;         </li><li class="list-item">il chip select del comando di set asincrono sarà         <div class="center"><span class="mono">CS_SET_ASYNC = BA[19] <span class="math-span">\( \cdot\)</span> BA[18]' <span class="math-span">\( \cdot\)</span> BA[1] <span class="math-span">\( \cdot\)</span> BA[0] <span class="math-span">\( \cdot\)</span> MEMWRITE</span></div>         Oltre all'espressione di decodifica è presente anche il comando di <span class="mono">MEMWRITE</span> per evitare malfunzionamenti durante i transitori.     </li></ul><span class="inner-title">Progetto</span>     Dati questi segnali, si avrà quindi la seguente rete     <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/ffd-exercise.png"/></div></div>     Con questa rete è possibile comandare un flip-flop tramite i cicli di bus.      In particolare si ha che al clock del flip-flop è collegato il negato di <span class="mono">MEMWRITE</span> in quanto si vuole che il segnale sia campionato sul fronte di discesa di <span class="mono">MEMWRITE</span> (in quanto è solo in quel momento che si è sicuri che i dati siano presenti sul Bus Dati).      Altra particolarità è la presenza di un multiplexer. Ciò è causato dal segnale <span class="mono">MEMWRITE</span> sul clock: se il multiplexer non ci fosse, il dato sul Bus Dati sarebbe campionato ogni volta che la CPU vuole scrivere su una memoria qualsiasi. </div><div class="environment-tail"><span class="material-symbols-outlined body-visibility-icon" onclick="expand_environment(event)">expand_more</span></div></div><div class="definition environment" id="def1-15"><h2 class="environment-title">Definizione - Incrementare il parallelismo dei dati</h2><div class="environment-body">     Considerando le specifiche fino ad ora utilizzate, si ha che ad ogni ciclo di bus è possibile ottenere <span class="math-span">\( 1 \mathrm{ \, Byte }\)</span> di informazione.      <br/>     Con l'evolversi della tecnologia, le CPU hanno presentato frequenze di clock sempre maggiori mentre le memorie risultano avere tempi di accesso lenti (rispetto al clock), andando a creare un vero e proprio "collo di bottiglia".     È evidente che ciò rappresenti un rallentamento importante per buona parte degli applicativi.      <br/>     Per risolvere ciò, si potrebbe aumentare la grandezza del Data Bus, in modo da trasferire ad ogni ciclo più dati.      Se è possibile fare ciò per quanto riguarda la CPU, non è possibile per quanto riguarda il Bus Dati delle memorie (che sono vincolate ad un Bus Dati a <span class="math-span">\( 8 \mathrm{ \, bit }\)</span>, per evitare problemi di compatibilità della CPU con altre periferiche).     <br/>     Dato il vincolo, un'idea potrebbe essere utilizzare per la stessa capacità, più memorie (memorie di porta dati a <span class="math-span">\( 8 \mathrm{ \, bit }\)</span> e capacità minore) per ottenere ad ogni ciclo di bus più dati (da ogni memoria <span class="math-span">\( 1 \mathrm{ \, byte }\)</span>).     <br/>     Esisterà quindi una <strong>memoria logica</strong> (considerata come un unico blocco contiguo) e una <strong>memoria fisica</strong> (organizzata in blocchi separati).     <br/>     Aumentando il numero di dispositivi di memoria, ognuno di essi avrà meno indirizzi rispetto al caso di un unico dispositivo (in quanto le memorie hanno capacità minore): in questo caso sarebbe quindi sufficiente utilizzare un Address Bus più piccolo (in quanto allo stesso indirizzo corrispondono più dispositivi, ognuno dei quali ci fornirà un Byte in più).     Nonostante ciò, può essere di nostro interesse anche "prelevare/inserire" meno dati della capacità totale del nostro Bus (ad esempio se si ha un Bus Dati a <span class="math-span">\( 2 \mathrm{ \, Byte }\)</span>, in alcuni casi potremmo voler scrivere solo <span class="math-span">\( 1 \mathrm{ \, Byte }\)</span>): è necessario quindi introdurre ulteriori bit di "indirizzamento" (detti di <i>Bus Enable</i>, <strong>BE</strong>) che "decidono" con quali dei dispositivi più piccoli "attivare" per comunicare.     <div class="mynote environment"><h3 class="environment-title">Osservazioni personali - In pratica - Parallelismo dei dati a <span class="math-span">\( 16 \mathrm{ \, bit }\)</span></h3><div class="environment-body">         Consideriamo il caso del parallismo dati a <span class="math-span">\( 16 \mathrm{ \, bit }\)</span>.          Per sfruttare ciò con una memoria di <span class="math-span">\( 2^N\)</span> informazioni (vincolata ad un Bus Dati a <span class="math-span">\( 8 \mathrm{ \, bit }\)</span>) è possibile utilizzare due memorie da <span class="math-span">\( 2^{N - 1}\)</span> informazioni (collegate rispettivamente da un Bus Alto e un Bus Basso)         <div class="image-environment"><div class="image-wrapper spaced-90"><img alt="Immagine" src="../resources/generated-6.png"/></div></div>         Considerando questa situazione, sarebbero necessari <span class="math-span">\( N \mathrm{ \, bit }\)</span> di indirizzamento per mappare (nel caso del disegno, <span class="math-span">\( N = 3\)</span>) tutta la memoria logica, mentre per indirizzare le due memorie più piccole sono sufficienti solo <span class="math-span">\( N - 1 \mathrm{ \, bit }\)</span> (nel caso del disegno, <span class="math-span">\( N - 1 = 2\)</span>)         <div class="image-environment"><div class="image-wrapper spaced-90"><img alt="Immagine" src="../resources/generated-7.png"/></div></div>         Come è stato detto, è tuttavia necessario aggiungere altri due segnali di Bus Enable per manifestare la volontà di:         <ul class="list-container"><li class="list-item">selezionare <strong>solo il Byte del bus alto</strong>;             </li><li class="list-item">selezionare <strong>solo il Byte del bus basso</strong>;             </li><li class="list-item">selezionare <strong>entrambi i Byte</strong>;             </li><li class="list-item">non ottenere nessun Byte (anche se sarebbe un'azione insensata).         </li></ul>         Per mantenere tuttavia la contiguità degli indirizzi nell'accesso (ovvero per accedere ad indirizzi contigui nello stesso ciclo di bus) è necessario che i <strong>due indirizzi contigui siano su memorie distinte</strong>, ovvero         <div class="image-environment"><div class="image-wrapper spaced-90"><img alt="Immagine" src="../resources/generated-8.png"/></div></div>         In questo caso si ha che in un banco di memoria saranno presenti tutti gli indirizzi pari (in questo caso sul Bus Basso) e sull'altro tutti gli indirizzi dispari (sul Bus Alto).          <br/>         Con il parallelismo dei dati raddoppiato si ha che l'indirizzo fisico (corrispondente agli indirizzi <span class="mono">A[...]</span> della memoria) di ogni banco sarà dato dall'indirizzo logico diviso per <span class="math-span">\( 2\)</span>, equivalente a considerare i bit più significativi dell'indirizzo logico (<span class="mono">BA[...]</span>): ciò significa che al "piedino" della memoria <span class="mono">A0</span> sarà collegato il segnale <span class="mono">BA1</span> e al segnale <span class="mono">A1</span> sarà collegato il segnale <span class="mono">BA2</span>.         <span class="inner-title">Un esempio</span>         Considerando un caso reale, consideriamo di voler utilizzare <span class="math-span">\( 128 \mathrm{ \, KB }\)</span> di memoria EPROM in un sistema a parallelismo a <span class="math-span">\( 16 \mathrm{ \, bit }\)</span> con Bus Address a <span class="math-span">\( 20 \mathrm{ \, bit }\)</span>.          Si vuole mappare tale memoria all'indirizzo <span class="mono">00000h</span>.         <br/>         Effettuando la decodifica di I livello completa, si ha che per indirizzare completamente tale spazio sono necessari <span class="math-span">\( 2^7 \cdot 2^{10} = 2^{17}\)</span> indirizzi.          Si avrà quindi che per la decodifica completa sono necessari <span class="math-span">\( 20 - 17 = 3 \mathrm{ \, bit }\)</span>. Si ha quindi che la EPROM sarà individuata dal segnale:         <div class="center"><span class="mono">CS_EPROM = BA19' <span class="math-span">\( \cdot\)</span> BA18' <span class="math-span">\( \cdot\)</span> BA17'</span></div>         Tuttavia, come detto, per poter implementare il parallelismo a <span class="math-span">\( 16 \mathrm{ \, bit }\)</span> è necessario utilizzare due EPROM da <span class="math-span">\( 64 \mathrm{ \, KB }\)</span>, il cui collegamento è individuato dai segnali <span class="mono">BE0</span> (per il Bus Basso, corrispondente alla <span class="mono">EPROM0</span>) e <span class="mono">BE1</span> (per il Bus Basso, corrispondente alla <span class="mono">EPROM1</span>).          Si ha quindi che i due chip select saranno uguali a         <div class="center"><span class="mono">CS_EPROM0 = BA19' <span class="math-span">\( \cdot\)</span> BA18' <span class="math-span">\( \cdot\)</span> BA17' <span class="math-span">\( \cdot\)</span> BE0</span><br/><span class="mono">CS_EPROM1 = BA19' <span class="math-span">\( \cdot\)</span> BA18' <span class="math-span">\( \cdot\)</span> BA17' <span class="math-span">\( \cdot\)</span> BE1</span></div>         È necessario anche ricordare di collegare al Bus Address della memoria il nostro Bus Address a partire dall'indirizzo <span class="mono">BA[1]</span> in modo da rendere coerente il sistema.     </div></div></div></div><div class="myexample environment" id="example3"><h2 class="environment-title">Esempio - Mappatura di dispositivi in un sistema a <span class="math-span">\( 32 \mathrm{ \, bit }\)</span></h2><div class="environment-body collapsed">     Considerando un sistema con un Address Bus a <span class="math-span">\( 32 \mathrm{ \, bit }\)</span> ed un Data Bus da <span class="math-span">\( 32 \mathrm{ \, bit }\)</span> si vuole creare la mappatura del sistema inserendo:     <ul class="list-container"><li class="list-item"><span class="math-span">\( 1 \mathrm{ \, GB }\)</span> di memoria EPROM mappata agli indirizzi bassi;         </li><li class="list-item"><span class="math-span">\( 1 \mathrm{ \, GB }\)</span> di memoria RAM mappata agli indirizzi alti.     </li></ul><span class="inner-title">Spazio di indirizzamento</span>     Per risolvere questo problema, partiamo dalla mappatura della EPROM.      Per mappare <span class="math-span">\( 1 \mathrm{ \, GB }\)</span> di EPROM sono necessari <span class="math-span">\( 2^{30}\)</span> indirizzi e sappiamo inoltre che sono posizionati agli indirizzi bassi (ovvero a partire da <span class="mono">0000 0000h</span>).      Considerando ciò, si ha che la EPROM occuperà l'intervallo     <div class="center">         EPROM = [ 0000 0000h, 0000 0000h + 2<sup>30</sup> ] = [ 0000 0000h, 0000 0000h + 3FFFFFFFh ] = [ 0000 0000h, 3FFF FFFFh ]     </div>     Si ha tuttavia che il sistema che stiamo trattando ha Bus Dati a <span class="math-span">\( 32 \mathrm{ \, bit }\)</span>: ciò implica che dovremo utilizzare quattro memorie da <span class="math-span">\( 256 \mathrm{ \, MB }\)</span>.     <br/>     Consideriamo ora dove mappare la RAM.      Da consegna si ha che dovrebbero essere necessari <span class="math-span">\( 2^{30}\)</span> indirizzi: ciò implica che non esiste una RAM di questa taglia (in quanto esistono RAM con capienza di una "potenza dispari" di <span class="math-span">\( 2\)</span>).     Possiamo tuttavia utilizzare due RAM più piccole da <span class="math-span">\( 512 \mathrm{ \, MB }\)</span> (<span class="math-span">\( 2^{29}\)</span>).      Sappiamo inoltre che la RAM è posizionata negli indirizzi alti (ovvero l'ultimo indirizzo è <span class="mono">FFFF FFFFh</span>). Dato ciò, si ha che la prima RAM delle due (<span class="mono">RAM_H</span>) occuperà gli indirizzi     <div class="center"><span class="mono">RAM_H = [ FFFF FFFFh - 2<sup>29</sup>, FFFF FFFFh ] = [ FFFF FFFFh - 1FFF FFFFh, FFFF FFFFh ] = [ E000 0000h, FFFF FFFFh ]</span></div>      L'altra RAM, <span class="mono">RAM_L</span>, avrà come ultimo indirizzo il primo indirizzo disponibile "sotto" a <span class="mono">RAM_H</span>, ovvero <span class="mono">DFFF FFFFh</span> (<span class="mono">E000 0000h - 0000 0001h</span>) da cui     <div class="center"><span class="mono">RAM_L = [ DFFF FFFFh - 2<sup>29</sup>, DFFF FFFFh ] = [ DFFF FFFFh - 1FFF FFFFh, DFFF FFFFh ] = [ C000 0000h, DFFF FFFFh ]</span></div>     Dato che il sistema è a <span class="math-span">\( 32 \mathrm{ \, bit }\)</span> di Bus Dati, si ha che è necessario utilizzare per ognuna delle RAM quattro memorie RAM più piccole da <span class="math-span">\( 128 \mathrm{ \, MB }\)</span>, per un totale di otto RAM da <span class="math-span">\( 128 \mathrm{ \, MB }\)</span>.     <span class="inner-title">Calcolo dei Chip Select</span>     Ora che abbiamo distribuito lo spazio di indirizzamento, è necessario calcolare i Chip Select semplificati per i vari dispositivi, da cui:     <div class="center"><span class="mono">CS_EPROM (0000 0000h) = BA[31]'</span><br/><span class="mono">CS_RAM_L (C000 0000h) = BA[31] <span class="math-span">\( \cdot\)</span> BA[29]'</span><br/><span class="mono">CS_RAM_H (E000 0000h) = BA[31] <span class="math-span">\( \cdot\)</span> BA[29]</span></div>     dove:     <ul class="list-container"><li class="list-item">il bit <span class="mono">BA[31]</span> discrimina quale metà dello spazio di indirizzamento considerare;         </li><li class="list-item">il bit <span class="mono">BA[29]</span> discrimina quale delle due RAM utilizzare.     </li></ul>     È ora semplice dedurre i Chip Select definitivi per il parallelismo a <span class="math-span">\( 32 \mathrm{ \, bit }\)</span>, ovvero i Chip Select della <span class="mono">EPROM</span> saranno     <div class="center"><span class="mono">CS_EPROM_0 = BA[31]' <span class="math-span">\( \cdot\)</span> BE0</span><br/><span class="mono">CS_EPROM_1 = BA[31]' <span class="math-span">\( \cdot\)</span> BE1</span><br/><span class="mono">CS_EPROM_2 = BA[31]' <span class="math-span">\( \cdot\)</span> BE2</span><br/><span class="mono">CS_EPROM_3 = BA[31]' <span class="math-span">\( \cdot\)</span> BE3</span></div>     mentre per la <span class="mono">RAM_L</span> saranno     <div class="center"><span class="mono">CS_RAM_L_0 = BA[31] <span class="math-span">\( \cdot\)</span> BA[29]' <span class="math-span">\( \cdot\)</span> BE0</span><br/><span class="mono">CS_RAM_L_1 = BA[31] <span class="math-span">\( \cdot\)</span> BA[29]' <span class="math-span">\( \cdot\)</span> BE1</span><br/><span class="mono">CS_RAM_L_2 = BA[31] <span class="math-span">\( \cdot\)</span> BA[29]' <span class="math-span">\( \cdot\)</span> BE2</span><br/><span class="mono">CS_RAM_L_3 = BA[31] <span class="math-span">\( \cdot\)</span> BA[29]' <span class="math-span">\( \cdot\)</span> BE3</span></div>     e infine per la <span class="mono">RAM_H</span> saranno     <div class="center"><span class="mono">CS_RAM_H_0 = BA[31] <span class="math-span">\( \cdot\)</span> BA[29] <span class="math-span">\( \cdot\)</span> BE0</span><br/><span class="mono">CS_RAM_H_1 = BA[31] <span class="math-span">\( \cdot\)</span> BA[29] <span class="math-span">\( \cdot\)</span> BE1</span><br/><span class="mono">CS_RAM_H_2 = BA[31] <span class="math-span">\( \cdot\)</span> BA[29] <span class="math-span">\( \cdot\)</span> BE2</span><br/><span class="mono">CS_RAM_H_3 = BA[31] <span class="math-span">\( \cdot\)</span> BA[29] <span class="math-span">\( \cdot\)</span> BE3</span></div><span class="inner-title">Collegamenti logici</span>     Una volta calcolati i Chip Select, è possibile effettuare il collegamento logico alle memorie, ovvero si ha che la <span class="math-span">\( i\)</span>-esima <span class="mono">EPROM</span> (con <span class="math-span">\( i \in \{ 0, 1, 2, 3 \}\)</span>) sarà uguale a     <div class="image-environment"><div class="image-wrapper spaced-60"><img alt="Immagine" src="../resources/eprom-256MB-32bitSystem.png"/></div></div>     mentre la <span class="math-span">\( i\)</span>-esima <span class="mono">RAM_L</span> (e in maniera non dissimile anche la <span class="mono">RAM_H</span>) sarà uguale a     <div class="image-environment"><div class="image-wrapper spaced-60"><img alt="Immagine" src="../resources/ram-128MB-32bitSystem.png"/></div></div>     In entrambi i casi vi è la particolarità che agli indirizzi delle memorie sia collegato l'Address Bus a partire dal terzo bit (da <span class="mono">BA[2]</span> in poi), ma ciò è dovuto al fatto che tali memorie siano poste in parallelo in un sistema a <span class="math-span">\( 32 \mathrm{ \, bit }\)</span>. </div><div class="environment-tail"><span class="material-symbols-outlined body-visibility-icon" onclick="expand_environment(event)">expand_more</span></div></div>
            </article>
            <nav class="buttons-container content-width">
                <a class="navigation-button previous" href="il-modello-della-cpu.html" rel="nofollow"><span>Il modello della CPU</span></a>
                <a class="navigation-button next" href="instruction-set-architecture.html" rel="nofollow"><span>Instruction Set Architecture</span></a>
            </nav>
        </section>
        <div class="scroll-to-bottom-button" onclick="scroll_to_bottom()">
            <span class="material-symbols-outlined">
                keyboard_double_arrow_down
            </span>
        </div>
        <footer class="footer-wrapper">
            <div class="copyright-wrapper">
                <span> &copy; Copyright 2023</span> /
                <span>made by lorenzoarlo</span>
            </div>
            /
            <div class="privacy-wrapper">
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/" rel="nofollow">Pannello preferenze cookie</a></span> /
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/privacy-policy.html" rel="nofollow" target="_blank" >Privacy Policy</a></span>
            </div>
        </footer>
    </div>
</body>
</html>