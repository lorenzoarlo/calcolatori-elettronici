<!DOCTYPE html>
<html lang="IT">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="stylesheet" href="./../styles/style.css" />
    <link rel="stylesheet" href="./../styles/index-style.css" />
    <link rel="stylesheet" href="./../styles/main-index-page-style.css" />
    
        <link rel="stylesheet" href="./../styles/content-style.css" />
    
    <style>:root { --bg-clr: #FFD700; --fg-clr: #262626; }</style>
    <meta name="application-name" content="Calcolatori elettronici" />
    <meta name="apple-mobile-web-app-title" content="Calcolatori elettronici" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="#FFD700" />
    <link rel="apple-touch-icon" sizes="144x144" href="./../apple-icon-144x144.png">
    <link rel="icon" type="image/x-icon" href="./../favicon.ico">
    <link rel="icon" type="image/png" sizes="192x192" href="./../android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="96x96" href="./../favicon-96x96.png">
    <meta name="msapplication-TileColor" content="#FFD700">
    <meta name="msapplication-TileImage" content="./../ms-icon-144x144.png">
    <link rel="manifest" href="./../manifest.json">
    <meta name="keywords" content="calcolatori elettronici" />
    <meta name="description" content="Il seguente sito contiene gli appunti e le definizioni del corso 'Calcolatori elettronici T'.">
    <meta name="robots" content="index">
    <meta name="format-detection" content="telephone=no">
    <meta name="themeColor" content="#FFD700">
    <script src="./../scripts/script.js"></script>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-78NHLXDQD8"></script>
    <script defer async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <title>Calcolatori elettronici - Funzionamento della CPU in un elaboratore - Eventi e interruzioni </title>
</head>
<body>
    <div class="container">
        <header class="header-wrapper">
            <div class="title-wrapper">
                <span class="title">
                    Calcolatori elettronici
                </span>
                <span class="subtitle">
                    by lorenzoarlo
                </span>
            </div>
            <span class="page-title">
                Funzionamento della CPU in un elaboratore
            </span>
        </header>
        <aside class="sidebar">
            <h2 class="sidebar-title">Calcolatori elettronici</h2>
            <div class="index-container">
                <ul class="parent-ul"><li class="section-li"><a href="../index.html" rel="nofollow">Indice</a></li><li class="section-li current">Funzionamento della CPU in un elaboratore<ul><li class="subsection-li "><a href="il-modello-della-cpu.html" rel="nofollow">Il modello della CPU</a></li><li class="subsection-li "><a href="comunicazione-con-dispositivi.html" rel="nofollow">Comunicazione con dispositivi</a></li><li class="subsection-li "><a href="instruction-set-architecture.html" rel="nofollow">Instruction Set Architecture</a></li><li class="subsection-li "><a href="il-microprocessore-dlx.html" rel="nofollow">Il microprocessore DLX</a></li><li class="subsection-li current">Eventi e interruzioni<ul><li class="definition-li"><a href="#def1-30" rel="nofollow">Controllare il verificarsi di eventi</a></li><li class="definition-li"><a href="#def1-31" rel="nofollow">Gestione di eventi</a></li><li class="definition-li"><a href="#def1-32" rel="nofollow">Segnale di interrupt</a></li><li class="definition-li"><a href="#def1-33" rel="nofollow">Gestione di più sorgenti di interrupt</a></li><li class="definition-li"><a href="#def1-34" rel="nofollow">Gestione eventi in DLX</a></li><li class="definition-li"><a href="#def1-35" rel="nofollow">Rete logica per la trasformazione fronte-livello</a></li><li class="definition-li"><a href="#def1-36" rel="nofollow">Approcci per la gestione di eventi con priorità differenti</a></li><li class="definition-li"><a href="#def1-37" rel="nofollow">PIC</a></li><li class="definition-li"><a href="#def1-38" rel="nofollow">Consistenza dei dati a seguito di interruzioni</a></li><li class="definition-li"><a href="#def1-39" rel="nofollow">Codice di inizializzazione e interrupt handler</a></li></ul></li><li class="subsection-li "><a href="protocollo-di-comunicazione-handshake.html" rel="nofollow">Protocollo di comunicazione handshake</a></li></ul></li><li class="section-li "><a href="../progettazione-dlx/implementazione-sequenziale.html" rel="nofollow">Progettazione DLX</a><ul><li class="subsection-li "><a href="../progettazione-dlx/implementazione-sequenziale.html" rel="nofollow">Implementazione sequenziale</a></li><li class="subsection-li "><a href="../progettazione-dlx/implementazione-pipelined.html" rel="nofollow">Implementazione pipelined</a></li></ul></li></ul>
            </div>
        </aside>
        <div class="sidebar-button" onclick="toggle_sidebar(this)" role="button" >
            keyboard_double_arrow_right
        </div>
        <section class="content-wrapper">
            <h1 class="section-title content-width">Eventi e interruzioni</h1>
            <article class="content-container content-width">
                <div class="definition environment" id="def1-30"><h2 class="environment-title">Definizione - Controllare il verificarsi di eventi</h2><div class="environment-body">     In un sistema a microprocessore è essenziale poter <strong>gestire eventi</strong>.     I possibili eventi interessanti possono essere classificati in base alla "sorgente", che può essere:     <ul class="list-container"><li class="list-item"><strong>esterna</strong>, solitamente generata da perifiche;         </li><li class="list-item"><strong>interna</strong>, detta anche eccezione ("<i>exception</i>"), che può informare di situazioni critiche che si sono verificate.     </li></ul>       Per poter "venire a conoscenza" di tali eventi esistono due approcci differenti:     <ul class="list-container"><li class="list-item">il <strong>polling</strong>, che consiste nel controllo periodico dello stato di questi eventi;         </li><li class="list-item">l'utilizzo di uno o più segnali di <strong><span class="mono">INT</span></strong> ("<i>Interrupt</i>"), che indicano la presenza di un evento da gestire.     </li></ul>     Per quanto possano essere entrambi metodi funzionanti, la scelta più efficiente risulta essere l'utilizzo dell'interrupt.     <br/>     Il controllo periodico (<strong>polling</strong>) consiste infatti in una serie di istruzioni che "rallentano" il normale flusso del codice e che sono eseguite in ogni caso, anche se non necessarie.      <div class="mynote environment"><h3 class="environment-title">Nota bene - Ad esempio</h3><div class="environment-body">         Un esempio molto comune di segnale di interrupt generato è il mouse, che informa il processore di eventi come lo spostamento, la pressione di un tasto, ecc.     </div></div> </div></div><div class="definition environment" id="def1-31"><h2 class="environment-title">Definizione - Gestione di eventi</h2><div class="environment-body">     Una volta presa coscienza dell'evento, è necessario (se è abilitata la gestione) reagire:      per farlo si esegue automaticamente una porzione di codice detta <strong>interrupt handler</strong> che si comporterà in maniera adeguata.  </div></div><div class="definition environment" id="def1-32"><h2 class="environment-title">Definizione - Segnale di interrupt</h2><div class="environment-body">     Il segnale di interrupt permette la segnalazione di un evento esterno ed è paragonabile ad una "notifica push" hardware.       Dovendo segnalare un evento anche proveniente dall'esterno, esso ha una natura <strong>asincrona</strong> e non segue la temporizzazione del clock.      <br/>     Tale segnale, inoltre, può essere soggetto a diverse scelte progettuali:     <ul class="list-container"><li class="list-item">è possibile che siano presenti <strong>uno o più ingressi di interrupt</strong>, per discriminare diverse priorità.          È comune infatti anche il segnale <span class="mono">NMI</span> (<i><strong>N</strong>on <strong>M</strong>askable <strong>I</strong>nterrupt</i>) per segnalare interruzioni particolarmente importanti.         </li><li class="list-item">è possibile che il sistema sia <strong>sensibile al fronte di salita del segnale</strong> oppure che sia necessario che esso venga mantenuto <strong>a livello</strong> fino a quando non sono state gestite tutte le sorgenti di interrupt (ma eventualmente è possibile anche che si rispettino entrambe le condizioni);         </li><li class="list-item">è possibile che il segnale di interrupt possa essere generato anche da <strong>istruzioni software</strong> (ad esempio per invocare <strong>system calls</strong>).         </li><li class="list-item">è possibile che il segnale di interrupt <strong>interrompa l'istruzione in esecuzione</strong> oppure che aspetti la sua terminazione.     </li></ul> </div></div><div class="definition environment" id="def1-33"><h2 class="environment-title">Definizione - Gestione di più sorgenti di interrupt</h2><div class="environment-body">     In un qualsiasi sistema è comune la presenza di diverse sorgenti di interruzione (anche con <strong>priorità differente</strong>) nonostante sia presente un unico ingresso per la segnalazione.     A proposito di ciò, ogni sistema può adottare diverse politiche di gestione delle priorità, ad esempio:     <ul class="list-container"><li class="list-item">a <strong>priorità fissa</strong>;         </li><li class="list-item">a<strong> priorità variabile</strong>;         </li><li class="list-item">ecc.     </li></ul>      Dato ciò (in particolare nei casi di priorità variabile), esistono alcune alternative per trattare questo problema.     <br/>     La scelta più "auspicabile" sarebbe la possibilità di alternare l'esecuzione di un'altro interrupt handler associato ad eventi con priorità maggiore.      Per fare ciò, deve essere  permesso l'annidamento (<strong>nesting</strong>) del codice, implementabile tramite uno stack.     <br/>     Senza creare questa complessità, un'alternativa potrebbe essere rendere "indivisibile" ogni interrupt handler, ovvero <strong>disabilitare la gestione degli interrupt durante l'esecuzione di un altro handler</strong>.      Ovviamente, la gestione della priorità in questo caso dovrà essere fatta "a monte": ovvero, nel caso di invocazione simultanea di eventi con priorità differente, dovrà essere data precedenza all'evento con priorità maggiore (facilmente realizzabile via software).  </div></div><div class="definition environment" id="def1-34"><h2 class="environment-title">Definizione - Gestione eventi in DLX</h2><div class="environment-body">     Considerando il processore DLX, per la gestione degli eventi (detti genericamente <i>exception</i> anche se provenienti da sorgenti esterne), si ha che:     <ul class="list-container"><li class="list-item">esiste <strong>un unico segnale</strong> di interrupt <span class="mono">INT</span> sensibile al livello del segnale;         </li><li class="list-item">assumeremo, per semplicità, che l'<strong>istruzione in esecuzione</strong> al momento della segnalazione <strong>termini</strong> prima che sia eseguito l'interrupt handler;         </li><li class="list-item"><strong>non è permesso l'annidamento</strong> degli interrupt handler (si ha infatti che in DLX non è implementato alcuno stack hardware).          Nel caso si volesse permettere l'annidamento sarebbe necessario implementare uno stack di tipo software utilizzando le istruzioni <span class="code-inline">MOVS2I</span> e <span class="code-inline">MOVI2S</span> per salvare lo storico dei valori del registro <span class="mono">IAR</span>.          Oltre a questo, sarebbero inoltre necessarie istruzioni software per <strong>abilitare e disabilitare</strong> la gestione degli interrupt.      </li></ul>     Ad ogni segnalazione di interrupt, si avrà che il DLX:     <ul class="list-container"><li class="list-item">salva il valore del Program Counter nel registro <span class="mono">IAR</span> (<i><strong>I</strong>nterrupt <strong>A</strong>ddress <strong>R</strong>egister</i>);         </li><li class="list-item">è effettuato un salto all'indirizzo <span class="mono">0x0000 0000</span>, in cui è presente l'interrupt handler (oltre al codice di inizializzazione del sistema);         </li><li class="list-item">in caso di interruzioni multiple, è stabilito quale degli interrupt ricevuti ha priorità maggiore;         </li><li class="list-item">viene <strong>disabilitata la gestione di ulteriori interrupt</strong>;         </li><li class="list-item">una volta gestito l'evento è necessario utilizzare l'istruzione <span class="code-inline">RFE</span> (<i><strong>R</strong>eturn <strong>F</strong>rom <strong>E</strong>xception</i>) per ripristinare il valore del Program Counter, riabilitare la gestione degli interrupt e riprendere la normale esecuzione.     </li></ul> </div></div><div class="definition environment" id="def1-35"><h2 class="environment-title">Definizione - Rete logica per la trasformazione fronte-livello</h2><div class="environment-body">     Dato che considereremo la sensibilità al livello del segnale <span class="mono">INT</span>, può essere utile una rete logica che trasforma un segnale "a fronte" in un segnale a livello.      Una rete valida potrebbe essere la seguente:     <div class="image-environment"><div class="image-wrapper spaced-75"><img alt="Immagine" src="../resources/rete-logica-fronte-livello.png"/></div></div>     In questo caso, al fronte di salita di <span class="mono">SEGNALE_FRONTE</span> il flip-flop emetterà il valore a livello.      A questo punto, per reimpostarlo a <span class="mono">0</span>, è necessario asserire il segnale <span class="mono">RESET_SEGNALE</span>.   </div></div><div class="definition environment" id="def1-36"><h2 class="environment-title">Definizione - Approcci per la gestione di eventi con priorità differenti</h2><div class="environment-body">     Nel caso di interruzioni multiple con priorità differenti, è possibile utilizzare approcci differenti.     <br/>     Una possibile soluzione (più semplice da implementare) è via "software" in cui <strong>saranno controllate le possibili fonti di interrupt in ordine di priorità</strong>.      Alternativamente, è possibile affidarsi ad una rete logica esterna detta <strong>PIC</strong> (<i><strong>P</strong>rogrammable <strong>I</strong>nterrupt <strong>C</strong>ontroller</i>) che non fa altro che convogliare le possibili sorgenti di interrupt e indicare quale degli interrupt è necessario gestire (secondo una policy prestabilita).   </div></div><div class="definition environment" id="def1-37"><h2 class="environment-title">Definizione - PIC</h2><div class="environment-body">     Il <strong>PIC</strong> (<i><strong>P</strong>rogrammable <strong>I</strong>nterrupt <strong>C</strong>ontroller</i>) è una rete logica adibita alla gestione di eventi con diversa priorità.     Una possibile struttura può essere caratterizzata da:     <ul class="list-container"><li class="list-item"><span class="math-span">\( n\)</span> segnali in input di interrupt <span class="mono">INT_IN</span> (uno per ogni sorgente), provenienti dalle diverse sorgenti di interrupt;         </li><li class="list-item">i segnali di <span class="mono">CS</span> (<i><strong>C</strong>hip <strong>S</strong>elect</i>), <span class="mono">RD</span>, <span class="mono">WR</span> (considerando che è una rete programmabile può essere utile effettuare anche cicli di scrittura, ad esempio per modifcare la politica di gestione delle interruzioni);         </li><li class="list-item">un Bus Address di <span class="math-span">\( k \mathrm{ \, bit }\)</span> in ingresso;         </li><li class="list-item">un Bus Dati bidirezionale, tipicamente di <span class="math-span">\( 8 \mathrm{ \, bit }\)</span>, per permettere lo scambio di informazioni;         </li><li class="list-item">un segnale <span class="mono">INT</span> in output da collegare al microprocessore.     </li></ul>     <div class="image-environment"><div class="image-wrapper spaced-60"><img alt="Immagine" src="../resources/pic.png"/></div></div> </div></div><div class="definition environment" id="def1-38"><h2 class="environment-title">Definizione - Consistenza dei dati a seguito di interruzioni</h2><div class="environment-body">     Come è stato detto, le interruzioni possono verificarsi in qualsiasi momento e quindi anche durante l'esecuzione di altri programmi.      <br/>     È necessario considerare che i registri utilizzabili dall'handler sono gli stessi del programma "principale".     Per questo motivo occorre, per rendere <strong>consistente l'esecuzione dei programmi</strong>, salvare il valore dei registri che si andranno a modificare in memoria per poi ripristinarli al termine dell'handler (o, alternativamente, scegliere e utilizzare registri non utilizzati dal programma principale). </div></div><div class="definition environment" id="def1-39"><h2 class="environment-title">Definizione - Codice di inizializzazione e interrupt handler</h2><div class="environment-body">     Se la gestione degli interrupt è abilitata, all'arrivo di un interrupt l'esecuzione si sposterà all'indirizzo <span class="mono">0x0000 0000</span> dove risiede tuttavia anche il <strong>codice di configurazione iniziale</strong> (eseguito all'avvio del sistema).     Inoltre, proprio perchè si sta configurando il sistema, in questo momento si desidera ignorare qualsiasi interruzione.     <br/>     Per risolvere queste problematiche, può essere utile considerare un segnale <span class="mono">STARTUP</span> che è attivo durante la configurazione iniziale: tale segnale sarà quindi caratterizzato da una rete logica dedicata in grado di gestire i comandi per la lettura e scrittura del suo valore. </div></div>
            </article>
            <nav class="buttons-container content-width">
                <a class="navigation-button previous" href="il-microprocessore-dlx.html" rel="nofollow"><span>Il microprocessore DLX</span></a>
                <a class="navigation-button next" href="protocollo-di-comunicazione-handshake.html" rel="nofollow"><span>Protocollo di comunicazione handshake</span></a>
            </nav>
        </section>
        <div class="scroll-to-bottom-button" onclick="scroll_to_bottom()">
            <span class="material-symbols-outlined">
                keyboard_double_arrow_down
            </span>
        </div>
            <footer class="footer-wrapper">
                <div class="copyright-wrapper">
                    <span> &copy; Copyright 2024</span> /
                    <span>made by <a href="https://github.com/lorenzoarlo" rel="nofollow">lorenzoarlo</a></span>
                </div>
                /
                <div class="privacy-wrapper">
                    <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/" rel="nofollow">Pannello preferenze
                            cookie</a></span> /
                    <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/privacy-policy.html" rel="nofollow"
                            target="_blank">Privacy Policy</a></span>
                </div>
            </footer>
    </div>
</body>
</html>