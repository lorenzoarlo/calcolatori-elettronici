<!DOCTYPE html>
<html lang="IT">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="stylesheet" href="../styles/style.css" />
    <link rel="stylesheet" href="../styles/index-style.css" />
    <link rel="stylesheet" href="../styles/content-style.css" />
    <link rel="icon" type="image/x-icon" href="../resources/favicon.ico">
    <meta name="application-name" content="Calcolatori elettronici" />
    <meta name="apple-mobile-web-app-title" content="Calcolatori elettronici" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="#FFD700" />
    <link rel="apple-touch-icon" href="../resources/favicon.png" />
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-78NHLXDQD8"></script>
    <script src="../scripts/script.js"></script>
    <style>:root { --bg-clr: #FFD700; --fg-clr: #262626; }</style>
    <meta name="theme-color" content="#FFD700" />
    <meta name="keywords" content="calcolatori elettronici" />
    <meta name="description" content="Il seguente sito contiene gli appunti e le definizioni del corso 'Calcolatori elettronici T'.">
    <meta name="robots" content="index">
    <script defer async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <title>Calcolatori elettronici - Funzionamento della CPU in un elaboratore - Eventi e interruzioni</title>
</head>
<body>
    <div class="container">
        <header class="header-wrapper">
            <div class="title-wrapper">
                <span class="title">
                    Calcolatori elettronici
                </span>
                <span class="subtitle">
                    by lorenzoarlo
                </span>
            </div>
            <span class="page-title">
                Funzionamento della CPU in un elaboratore
            </span>
        </header>
        <section class="content-wrapper">
            <h1 class="section-title content-width">Eventi e interruzioni</h1>
            <article class="content-container content-width">
                <div class="definition environment" id="def1-31"><h2 class="environment-title">Definizione - Controllare il verificarsi di eventi</h2><div class="environment-body">     In un sistema a microprocessore è essenziale poter <strong>gestire eventi</strong>.     I possibili eventi interessanti possono essere classificati in base alla "sorgente", che può essere:     <ul class="list-container"><li class="list-item"><strong>esterna</strong>, solitamente generata da perifiche;         </li><li class="list-item"><strong>interna</strong>, detta anche eccezione ("<i>exception</i>"), che può informare di situazioni critiche che si sono verificate.     </li></ul>       Per poter "conoscere" tali eventi esistono due approcci differenti:     <ul class="list-container"><li class="list-item">il <strong>polling</strong>, che consiste nel controllo periodico dello stato di questi eventi;         </li><li class="list-item">l'utilizzo di uno o più segnali di <strong><span class="mono">INT</span></strong> ("<i>Interrupt</i>"), che indicano la presenza di un evento da gestire.     </li></ul>     Per quanto possano essere entrambi metodi funzionanti, la scelta più efficiente risulta essere l'utilizzo dell'interrupt.     Il controllo periodico (<strong>polling</strong>) consiste infatti in una serie di istruzioni che "rallentano" il normale flusso del codice e che sono eseguite in ogni caso, anche se non necessarie.      <div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Ad esempio</h3><div class="environment-body">         Un esempio molto comune di segnale di interrupt generato è il mouse, che informa il processore di eventi come lo spostamento, la pressione di un tasto, ecc.     </div></div></div></div><div class="definition environment" id="def1-32"><h2 class="environment-title">Definizione - Gestione di eventi</h2><div class="environment-body">     Una volta presa coscienza dell'evento, è necessario (se è abilitata la gestione) reagire:      per farlo si esegue automaticamente una porzione di codice detta <strong>interrupt handler</strong> che reagirà in maniera adeguata.  </div></div><div class="definition environment" id="def1-33"><h2 class="environment-title">Definizione - Segnale di interrupt</h2><div class="environment-body">     Il segnale di interrupt permette la segnalazione di un evento esterno ed è paragonabile ad una "notifica push" hardware.       Dovendo segnalare un evento anche proveniente dall'esterno, esso ha una natura asincrona e non segue la temporizzazione del clock.      <br/>     Tale segnale inoltre può essere soggetto a diverse scelte progettuali:     <ul class="list-container"><li class="list-item">è possibile che siano presenti <strong>uno o più segnali di interrupt</strong>, per discriminare diverse priorità.          È comune infatti anche il segnale <span class="mono">NMI</span> (<i>Non Maskable Interrupt</i>) per segnalare interruzioni particolarmente importanti.         </li><li class="list-item">è possibile che il sistema sia <strong>sensibile al fronte di salita del segnale</strong>, oppure è necessario che sia mantenuto il <strong>valore a livello</strong> fino a quando non sono state gestite tutte le sorgenti di interrupt (ma eventualmente è possibile anche che si rispettino entrambe le condizioni);         </li><li class="list-item">è possibile che il segnale di interrupt possa essere generato anche da <strong>istruzioni software</strong> (ad esempio per invocare <strong>system calls</strong>).         </li><li class="list-item">è possibile che il segnale di interrupt <strong>interrompa l'istruzione in esecuzione</strong>, oppure che aspetti la sua terminazione.     </li></ul></div></div><div class="definition environment" id="def1-34"><h2 class="environment-title">Definizione - Gestione di più sorgenti di interrupt</h2><div class="environment-body">     In un qualsiasi sistema è comune la presenza di diverse sorgenti di interruzione (anche con <strong>priorità differente</strong>) nonostante sia presente un unico ingresso per la segnalazione.     A proposito di ciò, ogni sistema può adottare diverse politiche di gestione delle priorità, ad esempio:     <ul class="list-container"><li class="list-item">a <strong>priorità fissa</strong>;         </li><li class="list-item">a<strong> priorità variabile</strong>;         </li><li class="list-item">ecc.     </li></ul>      Dato ciò (in particolare nei casi di priorità variabile), esistono alcune alternative per trattare questo problema.      Il sistema più auspicabile sarebbe la possibilità di alternare l'esecuzione di diversi interrupt handler in caso dell'invocazione di eventi a priorità maggiore.      Per fare ciò, deve essere permesso l'annidamento (<strong>nesting</strong>) del codice, implementabile tramite uno stack.     <br/>     Senza creare questa complessità, un'alternativa potrebbe essere rendere "indivisibile" ogni interrupt handler, ovvero disabilitare la gestione degli interrupt durante l'esecuzione di un altro handler.      Ovviamente, la gestione della priorità in questo caso dovrà essere fatta "a monte": ovvero, nel caso di invocazione simultanea di eventi con priorità differente, dovrà essere data precedenza all'evento con priorità maggiore.  </div></div><div class="definition environment" id="def1-35"><h2 class="environment-title">Definizione - Gestione eventi in DLX</h2><div class="environment-body">     Considerando il processore DLX, per la gestione degli eventi (detti genericamente <i>exception</i> anche se provenienti da sorgenti esterne), si ha che:     <ul class="list-container"><li class="list-item">esiste <strong>un unico segnale</strong> di interrupt <span class="mono">INT</span> sensibile al livello del segnale;         </li><li class="list-item">assumeremo, per semplicità, che l'<strong>istruzione in esecuzione</strong> al momento della segnalazione <strong>termini</strong> prima che sia eseguito l'interrupt handler;         </li><li class="list-item">non è permesso l'annidamento degli interrupt handler (si ha infatti che in DLX non è implementato alcuno stack).          Nel caso si volesse permettere l'annidamento sarebbe necessario implementare uno stack di tipo software utilizzando le istruzioni <span class="code-inline">MOVS2I</span> e <span class="code-inline">MOVI2S</span> per salvare lo storico dei valori del registro <span class="mono">IAR</span>.          Oltre a questo, sarebbero inoltre necessarie istruzioni software per <strong>abilitare e disabilitare</strong> la gestione degli interrupt.      </li></ul>     Ad ogni segnalazione di interrupt, si avrà che il DLX:     <ul class="list-container"><li class="list-item">salva il valore del Program Counter nel registro speciale <span class="mono">IAR</span> (<i>Interrupt Address Register</i>);         </li><li class="list-item">è effettuato un salto all'indirizzo <span class="mono">0x0000 0000</span>, in cui è presente l'interrupt handler (oltre al codice di inizializzazione del sistema);         </li><li class="list-item">in caso di interruzioni multiple, è stabilito quale degli interrupt ricevuti ha priorità maggiore;         </li><li class="list-item">viene disabilitata la gestione di ulteriori interrupt;         </li><li class="list-item">una volta gestito l'evento è necessario utilizzare l'istruzione <span class="code-inline">RFE</span> (<i>Return From Exception</i>) per ripristinare il valore del Program Counter e riprendere la normale esecuzione.     </li></ul></div></div><div class="definition environment" id="def1-36"><h2 class="environment-title">Definizione - Rete logica per la trasformazione fronte-livello</h2><div class="environment-body">     Dato che considereremo la sensibilità al livello del segnale <span class="mono">INT</span>, può essere utile una rete logica che trasforma un segnale "a fronte" in un segnale a livello.      Una rete valida potrebbe essere la seguente:     <div class="image-environment"><div class="image-wrapper spaced-75"><img alt="Immagine" src="../resources/rete-logica-fronte-livello.png"/></div></div>     In questo caso, al fronte di salita di <span class="mono">SEGNALE_FRONTE</span> il flip-flop emetterà il valore a livello.      A questo punto, per reimpostarlo a <span class="mono">0</span>, è necessario asserire il segnale <span class="mono">RESET_SEGNALE</span>.   </div></div><div class="definition environment" id="def1-37"><h2 class="environment-title">Definizione - Approcci per la gestione di eventi con priorità differenti</h2><div class="environment-body">     Nel caso di interruzioni multiple con priorità differenti, è possibile utilizzare approcci differenti.     <br/>     Una possibile soluzione (più semplice da implementare) è via "software" in cui saranno controllate le possibili fonti di interrupt in ordine di priorità.      Alternativamente, è possibile affidarsi ad una rete logica esterna detta <strong>PIC</strong> (<i>Programmable Interrupt Controller</i>) che non fa altro che coinvogliare le possibili sorgenti di interrupt e indicare quale degli interrupt è necessario gestire (secondo una policy prestabilita).   </div></div><div class="definition environment" id="def1-38"><h2 class="environment-title">Definizione - PIC</h2><div class="environment-body">     Il <strong>PIC</strong> (<i>Programmable Interrupt Controller</i>) è una rete logica adibita alla gestione di eventi con diversa priorità.     Una possibile struttura può essere caratterizzata da:     <ul class="list-container"><li class="list-item"><span class="math-span">\( n\)</span> segnali in input di interrupt <span class="mono">INT_IN</span> (uno per ogni sorgente), provenienti dalle diverse sorgenti di interrupt;         </li><li class="list-item">i segnali di <span class="mono">CS</span> (<i>Chip Select</i>), <span class="mono">RD</span>, <span class="mono">WR</span> (considerando che è una rete programmabile può essere utile effettuare anche cicli di scrittura, ad esempio per modifcare la politica di gestione delle interruzioni);         </li><li class="list-item">un Bus Address di <span class="math-span">\( k \mathrm{ \, bit }\)</span> in ingresso;         </li><li class="list-item">un Bus Dati bidirezionale, tipicamente di <span class="math-span">\( 8 \mathrm{ \, bit }\)</span>, per permettere lo scambio di informazioni;         </li><li class="list-item">un segnale <span class="mono">INT</span> in output da collegare al microprocessore.     </li></ul><div class="image-environment"><div class="image-wrapper spaced-60"><img alt="Immagine" src="../resources/pic.png"/></div></div></div></div><div class="definition environment" id="def1-39"><h2 class="environment-title">Definizione - Consistenza dei dati a seguito di interruzioni</h2><div class="environment-body">     Come è stato detto, le interruzioni possono verificarsi in qualsiasi momento e quindi anche durante l'esecuzione di altri programmi.      <br/>     Bisogna tuttavia considerare che i registri utilizzabili dall'handler sono gli stessi del programma "principale".     Per questo motivo occorre, per rendere <strong>consistente il programma</strong>, salvare il valore dei registri modificati in memoria per poi ripristinarli al termine dell'handler (o, alternativamente, scegliere e utilizzare registri non utilizzati dal programma principale). </div></div><div class="definition environment" id="def1-40"><h2 class="environment-title">Definizione - Codice di inizializzazione e interrupt handler</h2><div class="environment-body">     Se la gestione degli interrupt è abilitata, l'esecuzione si sposterà all'indirizzo <span class="mono">0x0000 0000</span> dove risiede tuttavia anche il <strong>codice di configurazione iniziale</strong> (eseguito all'avvio del sistema).     Inoltre, proprio perchè si sta configurando il sistema, in questo momento si desidera ignorare qualsiasi interruzione.     <br/>     Per risolvere queste problematiche, può essere utile considerare un segnale <span class="mono">STARTUP</span> che attivo durante la configurazione iniziale: tale segnale sarà quindi caratterizzato da una rete logica dedicata in grado di gestire i comandi per la lettura e scrittura del suo valore. </div></div>
            </article>
            <nav class="buttons-container content-width">
                <a class="navigation-button previous" href="il-microprocessore-dlx.html" rel="nofollow"><span>Il microprocessore DLX</span></a>
                <a class="navigation-button next" href="protocollo-di-comunicazione-handshake.html" rel="nofollow"><span>Protocollo di comunicazione handshake</span></a>
            </nav>
        </section>
        <div class="scroll-to-bottom-button" onclick="scroll_to_bottom()">
            <span class="material-symbols-outlined">
                keyboard_double_arrow_down
            </span>
        </div>
        <footer class="footer-wrapper">
            <div class="copyright-wrapper">
                <span> &copy; Copyright 2023</span> /
                <span>made by lorenzoarlo</span>
            </div>
            /
            <div class="privacy-wrapper">
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/" rel="nofollow">Pannello preferenze cookie</a></span> /
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/privacy-policy.html" rel="nofollow" target="_blank" >Privacy Policy</a></span>
            </div>
        </footer>
    </div>
</body>
</html>