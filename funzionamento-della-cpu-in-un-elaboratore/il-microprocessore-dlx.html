<!DOCTYPE html>
<html lang="IT">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="stylesheet" href="../styles/style.css" />
    <link rel="stylesheet" href="../styles/index-style.css" />
    <link rel="stylesheet" href="../styles/content-style.css" />
    <link rel="icon" type="image/x-icon" href="../resources/favicon.ico">
    <meta name="application-name" content="Calcolatori elettronici" />
    <meta name="apple-mobile-web-app-title" content="Calcolatori elettronici" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="#FFD700" />
    <link rel="apple-touch-icon" href="../resources/favicon.png" />
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-78NHLXDQD8"></script>
    <script src="../scripts/script.js"></script>
    <style>:root { --bg-clr: #FFD700; --fg-clr: #262626; }</style>
    <meta name="theme-color" content="#FFD700" />
    <meta name="keywords" content="calcolatori elettronici" />
    <meta name="description" content="Il seguente sito contiene gli appunti e le definizioni del corso 'Calcolatori elettronici T'.">
    <meta name="robots" content="index">
    <script defer async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <title>Calcolatori elettronici - Funzionamento della CPU in un elaboratore - Il microprocessore DLX</title>
</head>
<body>
    <div class="container">
        <header class="header-wrapper">
            <div class="title-wrapper">
                <span class="title">
                    Calcolatori elettronici
                </span>
                <span class="subtitle">
                    by lorenzoarlo
                </span>
            </div>
            <span class="page-title">
                Funzionamento della CPU in un elaboratore
            </span>
        </header>
        <section class="content-wrapper">
            <h1 class="section-title content-width">Il microprocessore DLX</h1>
            <article class="content-container content-width">
                <div class="definition environment" id="def1-25"><h2 class="environment-title">Definizione - Caratteristiche e segnali del microprocessore DLX</h2><div class="environment-body">     Il microprocessore DLX è caratterizzato da:     <ul class="list-container"><li class="list-item">un <strong>Data Bus</strong> di dimensione <span class="math-span">\( 32 \mathrm{ \, bit }\)</span>;         </li><li class="list-item">un <strong>unico spazio di indirizzamento</strong> di <span class="math-span">\( 4 \mathrm{ \, GB }\)</span> (ovvero <span class="math-span">\( {32}\)</span> bit di indirizzo, che tuttavia diventano <span class="math-span">\( 29\)</span>, con <span class="math-span">\( 4\)</span> segnali di Bus Enable a causa della grandezza del Data Bus).     </li></ul>     L'ISA è di tipo RISC ed è caratterizzato da:     <ul class="list-container"><li class="list-item"><span class="math-span">\( 32\)</span> registri (da <span class="math-span">\( 32 \mathrm{ \, bit }\)</span>) <strong>general purpose</strong>, indicati con (<span class="mono">R0</span>, <span class="mono">R1</span>, <span class="mono">...</span>, <span class="mono">R31</span>).          Di questi, il registro <span class="mono">R0</span> non è sovrascribile e contiene la costante <span class="mono">0x00000000</span>;         </li><li class="list-item"><span class="math-span">\( 4\)</span> registri <strong>speciali</strong> (sempre da <span class="math-span">\( 32 \mathrm{ \, bit }\)</span>) non direttamente accedibili tramite istruzioni:         <ul class="list-container"><li class="list-item">il registro <span class="mono">PC</span> (<i><strong>P</strong>rogram <strong>C</strong>ounter</i>), che contiene l'indirizzo in memoria della <strong>prossima istruzione</strong> (a cui sarà poi effettuato il fetch).              Ad ogni istruzione esso incrementa automaticamente di <span class="math-span">\( +4\)</span>;             </li><li class="list-item">il registro <span class="mono">IAR</span> (<i><strong>I</strong>nterrupt <strong>A</strong>ddress <strong>R</strong>egister</i>), in cui è depositato il Program Counter a <strong>seguito della ricezione di un segnale di Interrupt</strong>;             </li><li class="list-item">il registro <span class="mono">MAR</span> (<i><strong>M</strong>emory <strong>A</strong>ddress <strong>R</strong>egister</i>), con il contenuto dell'Address Bus (che è modificato quindi durante i cicli di Bus);             </li><li class="list-item">il registro <span class="mono">MDR</span> (<i><strong>M</strong>emory <strong>D</strong>ata <strong>R</strong>egister</i>), che contiene il contenuto del Data Bus (modificato anch'esso durante i cicli di Bus).         </li></ul></li><li class="list-item">non sono presenti registri contenenti i flag impostati dall'<strong>ALU</strong> (<i><strong>A</strong>rithmetic <strong>L</strong>ogic <strong>U</strong>nit</i>);         </li><li class="list-item">istruzioni a <strong>lunghezza fissa</strong> a <span class="math-span">\( 32 \mathrm{ \, bit }\)</span> allineate (ovvero informazioni per la decodifica nelle stesse posizioni);         </li><li class="list-item">modalità di <strong>accesso</strong> alla memoria <strong>indiretto</strong>;         </li><li class="list-item">ordine di memorizzazione dei dati <strong>little-endian</strong>.     </li></ul><span class="inner-title">I segnali del DLX</span>     Considerando tali caratterische, si ha che il processore DLX è caratterizzato da:     <ul class="list-container"><li class="list-item">un ingresso <span class="mono">CLK</span> per il segnale di clock;         </li><li class="list-item">un ingresso <span class="mono">RESET</span> per il segnale di inizializzazione all'accensione;         </li><li class="list-item">un'uscita per l'Address Bus di <span class="math-span">\( 30 \mathrm{ \, bit }\)</span> (<span class="mono">BA[31..2]</span>);         </li><li class="list-item">quattro uscite per i segnali di Bus Enable (<span class="mono">BE0</span>, <span class="mono">BE1</span>, <span class="mono">BE2</span> e <span class="mono">BE3</span>);         </li><li class="list-item">due uscite <span class="mono">RD</span> e <span class="mono">WR</span> per i segnali di controllo <span class="mono">MEMRD</span> e <span class="mono">MEMWR</span>;         </li><li class="list-item">due ingressi <span class="mono">READY</span> e <span class="mono">INT</span> per i segnali di controllo omonimi;         </li><li class="list-item">un ingresso/uscita per il Data Bus a <span class="math-span">\( 32 \mathrm{ \, bit }\)</span>.     </li></ul><span class="inner-title">Tipi di dato (numeri interi)</span>     Il processore DLX è in grado di gestire numeri interi signed e unsigned di grandezza:     <ul class="list-container"><li class="list-item"><span class="math-span">\( 8 \mathrm{ \, bit }\)</span>, ovvero un <i>Byte</i>;         </li><li class="list-item"><span class="math-span">\( 16 \mathrm{ \, bit }\)</span>, ovvero una <i>Half-Word</i>;         </li><li class="list-item"><span class="math-span">\( 32 \mathrm{ \, bit }\)</span>, ovvero una <i>Word</i>.      </li></ul>      Tutti i dati di dimensione inferiore a <span class="math-span">\( 32 \mathrm{ \, bit }\)</span> (gestiti quando si vuole leggere dalla memoria dati di queste grandezze) sono estesi a <span class="math-span">\( 32 \mathrm{ \, bit }\)</span> in questo modo:     <ul class="list-container"><li class="list-item">nel caso di <strong>interi unsigned</strong> si aggiungono nelle posizioni più significative il numero di <span class="mono">0</span> necessari per raggiungere i <span class="math-span">\( 32 \mathrm{ \, bit }\)</span>;         </li><li class="list-item">nel caso di <strong>interi signed</strong> si aggiungono nelle posizioni più significative la cifra più significativa del numero letto per raggiungere i <span class="math-span">\( 32 \mathrm{ \, bit }\)</span> (in questo modo è possibile mantenere il segno).      </li></ul></div></div><div class="definition environment" id="def1-26"><h2 class="environment-title">Definizione - Formato delle istruzioni</h2><div class="environment-body">     Nel linguaggio assembly per DLX esistono tre tipi di formati di istruzioni che si differenziano in base agli "argomenti passati":     <ul class="list-container"><li class="list-item">istruzioni del tipo <span class="mono">R</span> (da <i><strong>R</strong>egister</i>) caratterizzate da un registro di destinazione e due registri operandi;         </li><li class="list-item">istruzioni del tipo <span class="mono">I</span> (da <i><strong>I</strong>mmediate</i>) caratterizzate da un registro di destinazione, un registro operando e un immediato (una costante) a <span class="math-span">\( 16 \mathrm{ \, bit }\)</span>;         </li><li class="list-item">istruzioni del tipo <span class="mono">J</span> (da <i><strong>J</strong>ump</i>) caratterizzate da un immediato a <span class="math-span">\( 26 \mathrm{ \, bit }\)</span>.     </li></ul>      Ogni istruzione (non dipendente dal tipo) contiene un <strong>Operation Code</strong> di <span class="math-span">\( 6 \mathrm{ \, bit }\)</span> che discrimina i vari tipi di operazioni.     <span class="inner-title">Istruzioni <span class="mono">R</span></span>     Le istruzioni del tipo <span class="mono">R</span> comprendono le istruzioni aritmetiche, logiche e istruzioni di set.      Una tipica istruzione <span class="mono">R</span> sarà quindi così formata:     <div class="image-environment"><div class="image-wrapper spaced-90"><img alt="Immagine" src="../resources/generated-9.png"/></div></div>     Gli <span class="math-span">\( 11 \mathrm{ \, bit }\)</span> di estensione sono utili per estendere l'Operation Code e per la creazione di ulteriori istruzioni.     <span class="inner-title">Istruzioni <span class="mono">I</span></span>     Le istruzioni del tipo <span class="mono">I</span> comprendono le istruzioni di load, store, branch, di operazioni aritmetiche, logiche, di set tra un registro, ecc..      Una tipica istruzione <span class="mono">I</span> sarà quindi così formata:     <div class="image-environment"><div class="image-wrapper spaced-90"><img alt="Immagine" src="../resources/generated-10.png"/></div></div>     Tale immediato, codificato con <span class="math-span">\( 16\)</span> bit per motivi di spazio, per essere utilizzato dalla CPU dovrà essere esteso a <span class="math-span">\( 32 \mathrm{ \, bit }\)</span> (tale estensione potrà essere fatta sia con segno che senza in base alle necessità).     <span class="inner-title">Istruzioni <span class="mono">J</span></span>     Le istruzioni del tipo <span class="mono">J</span> comprendono le istruzioni di Jump.      Una tipica istruzione <span class="mono">J</span> sarà quindi uguale a:     <div class="image-environment"><div class="image-wrapper spaced-90"><img alt="Immagine" src="../resources/generated-11.png"/></div></div><div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Giusto per capirci...</h3><div class="environment-body">         La ripartizione dei bit non è fedele alla realtà: ad esempio l'OPCode potrebbe essere suddiviso in due intervalli non contigui.          Ciò che è importante, tuttavia, è l'allineamento di questi campi (ad esempio, se l'OPCode occupa i bit nelle posizioni <span class="mono">31 30 29 28 25 24</span>, si ha che deve occupare queste posizioni in ogni istruzione, al fine di rendere più agevole la decodifica).      </div></div></div></div><div class="definition environment" id="def1-27"><h2 class="environment-title">Definizione - Istruzioni per il Data Transfer</h2><div class="environment-body">     Le istruzioni per il Data Transfer comprendono tutte quelle istruzioni che permettono l'<strong>interazione con memorie e periferiche esterne</strong>.      <br/>     Considerando <span class="mono">RD</span> un registro destinazione, <span class="mono">RS</span> un registro sorgente, <span class="mono">RSP</span> un registro speciale e <span class="mono">Imm16</span> un valore "immediato" a <span class="math-span">\( 16 \mathrm{ \, bit }\)</span> si ha:     <ul class="list-container"><li class="list-item">le istruzioni per <strong>leggere un dato</strong> ad un <strong>indirizzo della memoria</strong> (ottenuto sommando il contenuto del registro all'immediato signed) e inserirlo nel registro <span class="mono">RD</span>, in particolare         <ul class="list-container"><li class="list-item"><span class="code-inline">LW RD, Imm16(RS)</span> (<i><strong>L</strong>oad <strong>W</strong>ord</i>) permette la lettura di interi signed a <span class="math-span">\( 32 \mathrm{ \, bit }\)</span>.              Affinchè tale istruzione possa essere eseguita correttamente, è necessario che l'indirizzo finale sia un indirizzo divisibile per <span class="math-span">\( 4\)</span> (in quanto è necessario trasportare <span class="math-span">\( 4 \mathrm{ \, Byte }\)</span> e attivare quindi tutte e <span class="math-span">\( 4\)</span> le memorie);             </li><li class="list-item"><span class="code-inline">LH RD, Imm16(RS)</span> (<i><strong>L</strong>oad <strong>H</strong>alf Word</i>) permette la lettura di interi signed a <span class="math-span">\( 16 \mathrm{ \, bit }\)</span> (si avrà quindi un'estensione a <span class="math-span">\( 32 \mathrm{ \, bit }\)</span> con segno).               Affinchè tale istruzione possa essere eseguita correttamente, è necessario che l'indirizzo finale sia un indirizzo divisibile per <span class="math-span">\( 2\)</span>;             </li><li class="list-item"><span class="code-inline">LHU RD, Imm16(RS)</span> (<i><strong>L</strong>oad <strong>H</strong>alf Word Unsigned</i>) permette la lettura di interi unsigned a <span class="math-span">\( 16 \mathrm{ \, bit }\)</span> (si avrà quindi un'estensione a <span class="math-span">\( 32 \mathrm{ \, bit }\)</span> senza segno);             </li><li class="list-item"><span class="code-inline">LB RD, Imm16(RS)</span> (<i><strong>L</strong>oad <strong>B</strong>yte</i>) permette la lettura di interi signed a <span class="math-span">\( 8 \mathrm{ \, bit }\)</span>;             </li><li class="list-item"><span class="code-inline">LBU RD, Imm16(RS)</span> (<i><strong>L</strong>oad <strong>B</strong>yte <strong>U</strong>nsigned</i>) permette la lettura di interi signed a <span class="math-span">\( 8 \mathrm{ \, bit }\)</span>;         </li></ul></li><li class="list-item">le istruzioni per <strong>scrivere il dato</strong> contenuto nel registro <span class="mono">RS</span> ad un <strong>indirizzo della memoria</strong>, in particolare         <ul class="list-container"><li class="list-item"><span class="code-inline">SW RS, Imm16(RS)</span> (<i><strong>S</strong>tore <strong>W</strong>ord</i>) permette la scrittura di interi signed a <span class="math-span">\( 32 \mathrm{ \, bit }\)</span>.  Affinchè tale istruzione possa essere eseguita correttamente, è necessario che l'indirizzo finale sia un indirizzo divisibile per <span class="math-span">\( 4\)</span> (in quanto è necessario trasportare <span class="math-span">\( 4 \mathrm{ \, Byte }\)</span> e attivare quindi tutte e <span class="math-span">\( 4\)</span> le memorie);             </li><li class="list-item"><span class="code-inline">SH RS, Imm16(RS)</span> (<i><strong>S</strong>tore <strong>H</strong>alf Word</i>) permette la scrittura di interi signed a <span class="math-span">\( 16 \mathrm{ \, bit }\)</span> (si avrà quindi un'estensione a <span class="math-span">\( 32 \mathrm{ \, bit }\)</span> con segno). Affinchè tale istruzione possa essere eseguita correttamente, è necessario che l'indirizzo finale sia un indirizzo divisibile per <span class="math-span">\( 2\)</span>;             </li><li class="list-item"><span class="code-inline">SB RS, Imm16(RS)</span> (<i><strong>S</strong>tore <strong>B</strong>yte</i>) permette la scrittura di interi signed a <span class="math-span">\( 8 \mathrm{ \, bit }\)</span>;         </li></ul></li><li class="list-item"><span class="code-inline">MOVS2I RS, RSP</span> è un istruzione per copiare il contenuto di un registro general purpose <span class="mono">RS</span> a un registro speciale <span class="mono">RSP</span>;         </li><li class="list-item"><span class="code-inline">MOVI2S RSP, RD</span> è un istruzione per copiare il contenuto di un registro speciale <span class="mono">RSP</span> a un registro general purpose <span class="mono">RS</span>;     </li></ul></div></div><div class="definition environment" id="def1-28"><h2 class="environment-title">Definizione - Istruzioni aritmetiche e logiche</h2><div class="environment-body">     Le istruzioni aritmetiche e logiche comprendono tutte quelle istruzioni che permettono di <strong>effettuare calcoli e operazioni</strong>.     <br/>     Considerando <span class="mono">RD</span> un registro destinazione, <span class="mono">RS</span> un registro sorgente e <span class="mono">Imm16</span> un valore "immediato" a <span class="math-span">\( 16 \mathrm{ \, bit }\)</span> si ha:     <ul class="list-container"><li class="list-item">le <strong>istruzioni aritmetiche</strong> di tipo <span class="mono">R</span> (ovvero che "copiano" il risultato dell'operazione tra i due registri <span class="mono">RS</span> nel registro <span class="mono">RD</span>), in particolare         <ul class="list-container"><li class="list-item"><span class="code-inline">ADD RD, RS, RS</span> per la somma tra numeri interi con segno;             </li><li class="list-item"><span class="code-inline">ADDU RD, RS, RS</span> (<i><strong>ADD U</strong>nsigned</i>) per la somma tra numeri interi senza segno;             </li><li class="list-item"><span class="code-inline">SUB RD, RS, RS</span> (<i><strong>SUB</strong>tract</i>) per la differenza tra numeri interi con segno;             </li><li class="list-item"><span class="code-inline">SUBU RD, RS, RS</span> (<i><strong>SUB</strong>tract <strong>U</strong>nsigned</i>) per la differenza tra numeri interi senza segno;         </li></ul></li><li class="list-item">le <strong>istruzioni aritmetiche</strong> di tipo <span class="mono">I</span> (ovvero che "copiano" il risultato dell'operazione tra un registro e un immediato (esteso a <span class="math-span">\( 32 \mathrm{ \, bit }\)</span> con o senza segno in base all'istruzione)), in particolare         <ul class="list-container"><li class="list-item"><span class="code-inline">ADDI RD, RS, Imm16</span> (<i><strong>ADD I</strong>mmediate</i>) per la somma tra numeri interi con segno;             </li><li class="list-item"><span class="code-inline">ADDUI RD, RS, Imm16</span> (<i><strong>ADD U</strong>nsigned <strong>I</strong>mmediate</i>) per la somma tra numeri interi senza segno;             </li><li class="list-item"><span class="code-inline">SUBI RD, RS, Imm16</span> (<i><strong>SUB</strong>tract <strong>I</strong>mmediate</i>) per la differenza tra numeri interi con segno;             </li><li class="list-item"><span class="code-inline">SUBUI RD, RS, Imm16</span> (<i><strong>SUB</strong>tract <strong>U</strong>nsigned <strong>I</strong>mmediate</i>) per la differenza tra numeri interi senza segno;         </li></ul></li><li class="list-item">le <strong>istruzioni logiche</strong> di tipo <span class="mono">R</span> (ovvero che "copiano" il risultato dell'operazione tra i due registri <span class="mono">RS</span> nel registro <span class="mono">RD</span>), in particolare         <ul class="list-container"><li class="list-item"><span class="code-inline">AND RD, RS, RS</span> per l'AND bit-a-bit;             </li><li class="list-item"><span class="code-inline">OR RD, RS, RS</span> per l'OR bit-a-bit;             </li><li class="list-item"><span class="code-inline">XOR RD, RS, RS</span> per lo XOR bit-a-bit;         </li></ul></li><li class="list-item">le <strong>istruzioni logiche</strong> di tipo <span class="mono">I</span> (ovvero che "copiano" il risultato dell'operazione tra un registro e un immediato (esteso a <span class="math-span">\( 32 \mathrm{ \, bit }\)</span> sempre <strong>senza segno</strong>), in particolare         <ul class="list-container"><li class="list-item"><span class="code-inline">ANDI RD, RS, Imm16</span> (<i><strong>AND I</strong>mmediate</i>) per l'AND bit-a-bit;             </li><li class="list-item"><span class="code-inline">ORI RD, RS, Imm16</span> (<i><strong>OR I</strong>mmediate</i>) per l'OR bit-a-bit;             </li><li class="list-item"><span class="code-inline">XORI RD, RS, Imm16</span> (<i><strong>XOR I</strong>mmediate</i>) per lo XOR bit-a-bit;         </li></ul></li><li class="list-item">le <strong>istruzioni di shift</strong> di tipo <span class="mono">R</span> (ovvero che effettuano lo scorrimento del contenuto del primo registro <span class="mono">RS</span> delle posizioni indicate nel contenuto del secondo registro <span class="mono">RS</span> e "copiano" il risultato nel registro <span class="mono">RD</span>), in particolare         <ul class="list-container"><li class="list-item"><span class="code-inline">SLL RD, RS, RS</span> (<i><strong>S</strong>hift <strong>L</strong>eft <strong>L</strong>ogical</i>) per lo shift logico verso sinistra;             </li><li class="list-item"><span class="code-inline">SRL RD, RS, RS</span> (<i><strong>S</strong>hift <strong>R</strong>ight <strong>L</strong>ogical</i>) per lo shift logico verso destra;             </li><li class="list-item"><span class="code-inline">SRA RD, RS, RS</span> (<i><strong>S</strong>hift <strong>R</strong>ight <strong>A</strong>rithmetical</i>) per lo shift aritmetico verso destra;         </li></ul></li><li class="list-item">le <strong>istruzioni di shift</strong> di tipo <span class="mono">I</span> (ovvero che effettuano lo scorrimento del contenuto del primo registro <span class="mono">RS</span> delle posizioni indicate dall'immediato e "copiano" il risultato nel registro <span class="mono">RD</span>), in particolare         <ul class="list-container"><li class="list-item"><span class="code-inline">SLLI RD, RS, Imm16</span> (<i><strong>S</strong>hift <strong>L</strong>eft <strong>L</strong>ogical <strong>I</strong>mmediate</i>) per lo shift logico verso sinistra;             </li><li class="list-item"><span class="code-inline">SRLI RD, RS, Imm16</span> (<i><strong>S</strong>hift <strong>R</strong>ight <strong>L</strong>ogical <strong>I</strong>mmediate</i>) per lo shift logico verso destra;             </li><li class="list-item"><span class="code-inline">SRAI RD, RS, Imm16</span> (<i><strong>S</strong>hift <strong>R</strong>ight <strong>A</strong>rithmetical <strong>I</strong>mmediate</i>) per lo shift aritmetico verso destra;         </li></ul></li><li class="list-item"><span class="code-inline">LHI RD, Imm16</span> (<i><strong>L</strong>oad <strong>H</strong>igh-Word <strong>I</strong>mmediate</i>) che permette il caricamento nel registro <span class="mono">RD</span> dell'immediato, posizionandolo però nelle posizioni più significative (e "riempiendo" il resto con <span class="mono">0</span>).      </li></ul></div></div><div class="definition environment" id="def1-29"><h2 class="environment-title">Definizione - Istruzioni di controllo</h2><div class="environment-body">     Le istruzioni di controllo comprendono le istruzioni di Set, di salto condizionato e non, ecc..     Considerando <span class="mono">RD</span> un registro destinazione, <span class="mono">RS</span> un registro sorgente, <span class="mono">Imm16</span> un valore "immediato" a <span class="math-span">\( 16 \mathrm{ \, bit }\)</span>, <span class="mono">Imm26</span> un valore "immediato" a <span class="math-span">\( 26 \mathrm{ \, bit }\)</span> si ha:     <ul class="list-container"><li class="list-item">le istruzioni di set di tipo <span class="mono">R</span> (ovvero che copiano nel registro <span class="mono">RD</span> se una condizione è rispettata (valore <span class="mono">1</span>) o meno (valore <span class="mono">0</span>) tra i due valori contenuti nei registri <span class="mono">RS</span>), in particolare         <ul class="list-container"><li class="list-item"><span class="code-inline">SLT RD, RS, RS</span> (<i><strong>S</strong>et <strong>L</strong>esser <strong>T</strong>han</i>) per verificare che il contenuto del primo registro sia minore "stretto" del secondo (confronto tra numeri con segno);             </li><li class="list-item"><span class="code-inline">SLTU RD, RS, RS</span> (<i><strong>S</strong>et <strong>L</strong>esser <strong>T</strong>han <strong>U</strong>nsigned</i>) per verificare che il contenuto del primo registro sia minore "stretto" del secondo (confronto tra numeri senza segno);             </li><li class="list-item"><span class="code-inline">SGT RD, RS, RS</span> (<i><strong>S</strong>et <strong>G</strong>reater <strong>T</strong>han</i>) per verificare che il contenuto del primo registro sia maggiore "stretto" del secondo (confronto tra numeri con segno);             </li><li class="list-item"><span class="code-inline">SGTU RD, RS, RS</span> (<i><strong>S</strong>et <strong>G</strong>reater <strong>T</strong>han <strong>U</strong>nsigned</i>) per verificare che il contenuto del primo registro sia maggiore "stretto" del secondo (confronto tra numeri senza segno);             </li><li class="list-item"><span class="code-inline">SLE RD, RS, RS</span> (<i><strong>S</strong>et <strong>L</strong>esser <strong>E</strong>qual</i>) per verificare che il contenuto del primo registro sia minore o uguale del secondo (confronto tra numeri con segno);             </li><li class="list-item"><span class="code-inline">SLEU RD, RS, RS</span> (<i><strong>S</strong>et <strong>L</strong>esser <strong>E</strong>qual <strong>U</strong>nsigned</i>) per verificare che il contenuto del primo registro sia minore o uguale del secondo (confronto tra numeri senza segno);             </li><li class="list-item"><span class="code-inline">SGE RD, RS, RS</span> (<i><strong>S</strong>et <strong>G</strong>reater <strong>E</strong>qual</i>) per verificare che il contenuto del primo registro sia maggiore o uguale del secondo (confronto tra numeri con segno);              </li><li class="list-item"><span class="code-inline">SGEU RD, RS, RS</span> (<i><strong>S</strong>et <strong>G</strong>reater <strong>E</strong>qual <strong>U</strong>nsigned</i>) per verificare che il contenuto del primo registro sia maggiore o uguale del secondo (confronto tra numeri senza segno);             </li><li class="list-item"><span class="code-inline">SEQ RD, RS, RS</span> (<i><strong>S</strong>et <strong>EQ</strong>ual</i>) per verificare che il contenuto del primo registro sia uguale al secondo (confronto tra numeri con segno);             </li><li class="list-item"><span class="code-inline">SEQU RD, RS, RS</span> (<i><strong>S</strong>et <strong>EQ</strong>ual <strong>U</strong>nsigned</i>) per verificare che il contenuto del primo registro sia uguale al secondo (confronto tra numeri senza segno);             </li><li class="list-item"><span class="code-inline">SNE RD, RS, RS</span> (<i><strong>S</strong>et <strong>N</strong>ot <strong>E</strong>qual</i>) per verificare che il contenuto del primo registro sia diverso dal secondo (confronto tra numeri con segno);                         </li><li class="list-item"><span class="code-inline">SNEU RD, RS, RS</span> (<i><strong>S</strong>et <strong>N</strong>ot <strong>E</strong>qual <strong>U</strong>nsigned</i>) per verificare che il contenuto del primo registro sia diverso dal secondo (confronto tra numeri senza segno);                         </li></ul></li><li class="list-item">le istruzioni di set di tipo <span class="mono">I</span> (ovvero che copiano nel registro <span class="mono">RD</span> se una condizione è rispettata o meno tra il valore del registro <span class="mono">RS</span> e l'immediato esteso con o senza segno), in particolare         <ul class="list-container"><li class="list-item"><span class="code-inline">SLTI RD, RS, Imm16</span> (<i><strong>S</strong>et <strong>L</strong>esser <strong>T</strong>han <strong>I</strong>mmediate</i>) per verificare che il contenuto del primo registro sia minore "stretto" dell'immediato (confronto tra numeri con segno);             </li><li class="list-item"><span class="code-inline">SLTUI RD, RS, Imm16</span> (<i><strong>S</strong>et <strong>L</strong>esser <strong>T</strong>han <strong>U</strong>nsigned <strong>I</strong>mmediate</i>) per verificare che il contenuto del primo registro sia minore "stretto" dell'immediato (confronto tra numeri senza segno);             </li><li class="list-item"><span class="code-inline">SGTI RD, RS, Imm16</span> (<i><strong>S</strong>et <strong>G</strong>reater <strong>T</strong>han <strong>I</strong>mmediate</i>) per verificare che il contenuto del primo registro sia maggiore "stretto" dell'immediato (confronto tra numeri con segno);             </li><li class="list-item"><span class="code-inline">SGTUI RD, RS, Imm16</span> (<i><strong>S</strong>et <strong>G</strong>reater <strong>T</strong>han <strong>U</strong>nsigned <strong>I</strong>mmediate</i>) per verificare che il contenuto del primo registro sia maggiore "stretto" dell'immediato (confronto tra numeri senza segno);             </li><li class="list-item"><span class="code-inline">SLEI RD, RS, Imm16</span> (<i><strong>S</strong>et <strong>L</strong>esser <strong>E</strong>qual <strong>I</strong>mmediate</i>) per verificare che il contenuto del primo registro sia minore o uguale dell'immediato (confronto tra numeri con segno);             </li><li class="list-item"><span class="code-inline">SLEUI RD, RS, Imm16</span> (<i><strong>S</strong>et <strong>L</strong>esser <strong>E</strong>qual <strong>U</strong>nsigned <strong>I</strong>mmediate</i>) per verificare che il contenuto del primo registro sia minore o uguale dell'immediato (confronto tra numeri senza segno);             </li><li class="list-item"><span class="code-inline">SGEI RD, RS, Imm16</span> (<i><strong>S</strong>et <strong>G</strong>reater <strong>E</strong>qual <strong>I</strong>mmediate</i>) per verificare che il contenuto del primo registro sia maggiore o uguale dell'immediato (confronto tra numeri con segno);             </li><li class="list-item"><span class="code-inline">SGEUI RD, RS, Imm16</span> (<i><strong>S</strong>et <strong>G</strong>reater <strong>E</strong>qual <strong>U</strong>nsigned <strong>I</strong>mmediate</i>) per verificare che il contenuto del primo registro sia maggiore o uguale dell'immediato (confronto tra numeri senza segno);             </li><li class="list-item"><span class="code-inline">SEQI RD, RS, Imm16</span> (<i><strong>S</strong>et <strong>EQ</strong>ual <strong>I</strong>mmediate</i>) per verificare che il contenuto del primo registro sia uguale all'immediato (confronto tra numeri con segno);             </li><li class="list-item"><span class="code-inline">SEQUI RD, RS, Imm16</span> (<i><strong>S</strong>et <strong>EQ</strong>ual <strong>U</strong>nsigned <strong>I</strong>mmediate</i>) per verificare che il contenuto del primo registro sia uguale all'immediato (confronto tra numeri senza segno);             </li><li class="list-item"><span class="code-inline">SNEI RD, RS, Imm16</span> (<i><strong>S</strong>et <strong>N</strong>ot <strong>E</strong>qual <strong>I</strong>mmediate</i>) per verificare che il contenuto del primo registro sia diverso dall'immediato (confronto tra numeri con segno);             </li><li class="list-item"><span class="code-inline">SNEUI RD, RS, Imm16</span> (<i><strong>S</strong>et <strong>N</strong>ot <strong>E</strong>qual <strong>U</strong>nsigned <strong>I</strong>mmediate</i>) per verificare che il contenuto del primo registro sia diverso dall'immediato (confronto tra numeri senza segno);                                 </li></ul></li><li class="list-item"><span class="code-inline">BEQZ RS, Imm16</span> (<i><strong>B</strong>ranch if <strong>EQ</strong>ual <strong>Z</strong>ero</i>) per il salto condizionato (se in <span class="mono">RS</span> è presente il valore <span class="mono">0</span>) all'istruzione <span class="mono">PC</span>-relativa sommata all'immediato (ricordando che il Program Counter punta all'indirizzo successivo da eseguire);         </li><li class="list-item"><span class="code-inline">BNEZ RS, Imm16</span> (<i><strong>B</strong>ranch if <strong>N</strong>ot <strong>E</strong>qual <strong>Z</strong>ero</i>) per il salto condizionato (se in <span class="mono">RS</span> non è presente il valore <span class="mono">0</span>) all'istruzione <span class="mono">PC</span>-relativa sommata all'immediato (ricordando che il Program Counter punta all'indirizzo successivo da eseguire);         </li><li class="list-item"><span class="code-inline">J Imm26</span> (<i><strong>J</strong>ump</i>) per il salto incodizionato all'indirizzo <span class="mono">PC</span>-relativo sommato all'immediato;         </li><li class="list-item"><span class="code-inline">JR RS</span> (<i><strong>J</strong>ump <strong>R</strong>egister</i>) per il salto incodizionato all'indirizzo assoluto contenuto nel registro <span class="mono">RS</span>;         </li><li class="list-item"><span class="code-inline">JALR Imm26</span> (<i><strong>J</strong>ump <strong>A</strong>nd <strong>L</strong>ink</i>) per il salto incodizionato con ritorno (ovvero è salvato il valore del Program Counter nel registro <span class="mono">R31</span>) all'indirizzo <span class="mono">PC</span>-relativo sommato all'immediato;         </li><li class="list-item"><span class="code-inline">JALR RS</span> (<i><strong>J</strong>ump <strong>A</strong>nd <strong>L</strong>ink <strong>R</strong>egister</i>) per il salto incodizionato con ritorno (ovvero è salvato il valore del Program Counter nel registro <span class="mono">R31</span>) all'indirizzo assoluto contenuto nel registro <span class="mono">RS</span></li></ul>     Per le istruzioni di salto, è concesso anche l'utilizzo di label (invece del valore numerico), dichiarabili come <span class="code-inline">Label:</span>. </div></div><div class="myexample environment" id="example4"><h2 class="environment-title">Esempio - Codice assembly per la somma degli elementi in un intervallo contiguo di memoria</h2><div class="environment-body collapsed">     Considerando un processore DLX nel cui spazio di indirizzamento è mappata una memoria <span class="mono">A</span> all'indirizzo <span class="mono">0x0800</span> contenente <span class="math-span">\( 8\)</span> numeri unsigned memorizzati come Byte, scrivere il codice al cui termine dell'esecuzione posiziona nel registro <span class="mono">R30</span> il risultato della somma di tutti gli otto numeri presenti in memoria.     <span class="inner-title">Considerazioni</span>     Considerando la richiesta, si ha che la risoluzione di questo problema può ricondursi all'iterazione di un comportamento per <span class="math-span">\( 8\)</span> volte.      Il metodo più efficiente e scalabile è considerare la creazione di un ciclo while.      Ragionando in questo modo, saranno necessari:     <ul class="list-container"><li class="list-item">un accumulatore in cui sarà memorizzata la somma;         </li><li class="list-item">un contatore "indice" che "tiene conto" di quanti numeri si sono già sommati (e permette quindi l'accesso al successivo indirizzo di memoria).     </li></ul>     Consideriamo ora anche il fatto che tale memoria è mappata all'indirizzo <span class="mono">0x00000800</span> (un numero i cui ultimi <span class="math-span">\( 16 \mathrm{ \, bit }\)</span> non sono significativi, ovvero che sono significativi solo i primi <span class="math-span">\( 16 \mathrm{ \, bit }\)</span>).      Possiamo quindi considerare di utilizzare come "punto costante" di accesso l'indirizzo rappresentato dall'immediato <span class="mono">0x0800</span> e l'offset di accesso dal contatore.     <span class="inner-title">Il codice</span>     Seguendo queste osservazioni otteniamo il codice:     <pre class="code-block"><code>        ADD R1, R0, R0      ; Accumulatore R1 = 0
        ADD R2, R0, R0      ; Indice R2 = 0
        ADD R3, R0, R0      ; Loop Condition Register R3 = 0
        ADD R4, R0, R0      ; Storage R4 = 0
        ADD R30, R0, R0     ; Risultato R30 = 0

SLOOP:  SLTUI R3, R2, 0x0008    ; R3 = R2 &lt; 8
        BEQZ R3, ELOOP          ; Se R3 = 0 (False), salta a ELOOP
        
        LBU R4, 0x0800(R2)      ; Storage R4 = A[0x0800 + R2]
        ADDU R1, R1, R3         ; Accumulatore R1 = R1 + R4
        ADDU R2, R2, 0x0001     ; Indice R2 = R2 + 1

        J SLOOP                 ; Salto incodizionato a SLOOP
ELOOP:  ADDU R30, R0, R1        ; Risultato R30 = R1</code></pre>     Tale codice ricalca il codice di un linguaggio ad alto livello (come C): tuttavia risulta essere inefficiente dato che:     <ul class="list-container"><li class="list-item">all'inizio si inizializzano inutilmente i registri <span class="mono">R3</span>, <span class="mono">R4</span>, <span class="mono">R30</span>;         </li><li class="list-item">il ciclo while è una struttura generica e non "modellata" perfettamente su questo problema.     </li></ul>     Detto ciò, è possibile considerare un codice decisamente più efficiente (in quanto si ha che ad ogni istruzione superflua, si "sprecano" alcuni cicli di clock):     <pre class="code-block"><code>        ADD R1, R0, R0      ; Accumulatore R1 = 0
        ADDI R2, R0, 0x0008 ; Indice R2 = 8

LOOP:   SUBUI R2, R2, 0x0001    ; R2 = R2 - 1 
        LBU R3, 0x0800(R1)      ; Storage R3 = A[0x0800 + R2]
        ADDU R1, R1, R3         ; R1 = R1 + R3
        
        BNEZ R2, LOOP           ; Se R2 != 0, salta a LOOP

        ADDU R30, R0, R1        ; Risultato R30 = R1</code></pre>     Tale codice risulta essere particolarmente efficiente: non utilizza infatti istruzioni di set per verificare che il ciclo sia finito, ma sfrutta il fatto che una volta terminato, l'indice arrivi naturalmente a <span class="mono">0</span>. </div><div class="environment-tail"><span class="material-symbols-outlined body-visibility-icon" onclick="expand_environment(event)">expand_more</span></div></div><div class="myexample environment" id="example5"><h2 class="environment-title">Esempio - Progetto di sistema basato su DLX con tre dispositivi, un LED e un segnale logico</h2><div class="environment-body collapsed">     Progettare un sistema basato sul processore DLX con:     <ul class="list-container"><li class="list-item"><span class="math-span">\( 512 \mathrm{ \, MB }\)</span> di EPROM mappata agli indirizzi bassi;         </li><li class="list-item"><span class="math-span">\( 1 \mathrm{ \, GB }\)</span> di RAM mappata all'indirizzo <span class="mono">0x40000000</span>;         </li><li class="list-item"><span class="math-span">\( 512 \mathrm{ \, MB }\)</span> di RAM mappata agli indirizzi alti;     </li></ul>     Tramite istruzioni software, deve essere inoltre possibile:     <ul class="list-container"><li class="list-item">impostare e leggere il livello logico <span class="mono">0</span> o <span class="mono">1</span> di un segnale detto <span class="mono">STARTUP</span> mappato all'indirizzo <span class="mono">0xC0000000</span>, inizialmente impostato al valore <span class="mono">1</span>;         </li><li class="list-item">invertire lo stato di un LED, inizialmente spento, mappato all'indirizzo <span class="mono">0x90000000</span>, prevedendo anche la possibilità di poterne leggere lo stato.     </li></ul><span class="inner-title">Spazio di indirizzamento</span>     Per risolvere questo problema, consideriamo innanzitutto gli intervalli di indirizzamento dei dispositivi.     <br/>     Consideriamo la EPROM da <span class="math-span">\( 512 \mathrm{ \, MB }\)</span>, essa occuperà <span class="math-span">\( 2^{9} \cdot 2^{20} = 2^{29}\)</span> indirizzi che dovranno essere posizionati agli indirizzi bassi. Quindi si ha     <div class="center"><span class="mono">EPROM = [ 0000 0000h, 0000 0000h + 2<sup>29</sup> ] = [ 0000 0000h, 0000 0000h + 1FFF FFFFh ] = [ 0000 0000h, 1FFF FFFFh ]</span></div>     Consideriamo ora la RAM da <span class="math-span">\( 1 \mathrm{ \, GB }\)</span> che occupa <span class="math-span">\( 2^{30}\)</span> indirizzi, che posizionati a partire dall'indirizzo <span class="mono">4000 0000h</span> comporteranno:     <div class="center"><span class="mono">RAM<sub>1 GB</sub> = [ 4000 0000h, 4000 0000h + 2<sup>30</sup> ] = [ 4000 0000h, 4000 0000h + 3FFF FFFFh ] = [ 4000 0000h, 7FFF FFFFh ]</span></div>     Considerando ora la RAM da <span class="math-span">\( 512 \mathrm{ \, MB }\)</span>, essa occupa <span class="math-span">\( 2^{29}\)</span> indirizzi, che posizionati agli indirizzi alti, comporteranno:     <div class="center"><span class="mono">RAM<sub>512 MB</sub> = [ FFFF FFFFh - 2<sup>29</sup> , FFFF FFFFh ] = [ FFFF FFFFh - 1FFF FFFFh, FFFF FFFFh ] = [ E000 0000h, FFFF FFFFh ]</span></div>     Consideriamo inoltre gli indirizzi utili per gestire le istruzioni. Per il segnale <span class="mono">STARTUP</span> saranno necessari due indirizzi, uno per la lettura e uno per la scrittura, ovvero     <div class="center"><span class="mono">STARTUP_INSTR = [ C000 0000h, C000 0000h + 2 ·  0000 0004h ] = [ C000 0000h, C000 0008h ]</span></div>     in particolare, utilizzeremo gli indirizzi <span class="mono">0xC0000000</span> per l'istruzione di lettura e <span class="mono">0xC0000004</span> per l'istruzione di scrittura (dedichiamo quattro indirizzi a istruzione per allinearlo al sistema a <span class="math-span">\( 32 \mathrm{ \, bit }\)</span>).     <br/>     Anche per "comandare" il LED sono sufficienti due segnali, uno per invertire lo stato e uno per leggere lo stato corrente, da cui     <div class="center"><span class="mono">LED_INSTR = [ 9000 0000h, 9000 0000h + 2 ·  0000 0004h ] = [ 9000 0000h, 9000 0008h ]</span></div>     in particolare utilizzeremo l'indirizzo <span class="mono">0x90000000</span> per l'istruzione di lettura e <span class="mono">0x9000004</span> per l'inversione.     <span class="inner-title">Calcolo dei chip select</span>     Ora che abbiamo suddiviso lo spazio di indirizzamento, è possibile procedere con il calcolo dei Chip Select     <ul class="list-container"><li class="list-item">per la EPROM da <span class="math-span">\( 512 \mathrm{ \, MB }\)</span> (quindi <span class="math-span">\( 2^{29}\)</span> indirizzi), sarà divisa in quattro EPROM da <span class="math-span">\( 128 \mathrm{ \, MB }\)</span> (<span class="math-span">\( 2^{27}\)</span> indirizzi) che "esiste" (dato che esistono tutte le potenze del <span class="math-span">\( 2\)</span>) e comporterà quattro segnali di chip select, ovvero <span class="mono">CS_EPROM_0</span>, <span class="mono">CS_EPROM_1</span>, <span class="mono">CS_EPROM_2</span>, <span class="mono">CS_EPROM_3</span>;         </li><li class="list-item">la RAM da <span class="math-span">\( 1 \mathrm{ \, GB }\)</span> (quindi <span class="math-span">\( 2^{30}\)</span> indirizzi) si ha che non "esiste" in questa taglia o in taglie grandi un quarto (in quanto sono disponibili solo taglie di RAM grandi "potenze dispari" del <span class="math-span">\( 2\)</span>).          Saranno quindi necessarie otto RAM da <span class="math-span">\( 128 \mathrm{ \, GB }\)</span> e i segnali di chip select <span class="mono">CS_RAM_1GB_L_0</span>, <span class="mono">CS_RAM_1GB_L_1</span>, <span class="mono">CS_RAM_1GB_L_2</span>, <span class="mono">CS_RAM_1GB_L_3</span>, <span class="mono">CS_RAM_1GB_H_0</span>, <span class="mono">CS_RAM_1GB_H_1</span>, <span class="mono">CS_RAM_1GB_H_2</span>, <span class="mono">CS_RAM_1GB_H_3</span>.          Inoltre, rimodellando l'intervallo di indirizzamento avremo         <div class="center"><span class="mono">RAM<sub>1 GB</sub>_L = [ 4000 0000h, 4000 0000h + 2<sup>29</sup> ] = [ 4000 0000h, 4000 0000h + 1FFF FFFFh ] = [ 4000 0000h, 5FFF FFFFh ]</span><br/><span class="mono">RAM<sub>1 GB</sub>_H = [ 7FFF FFFFh - 2<sup>29</sup>, 7FFF FFFFh ] = [ 7FFF FFFFh - 1FFF FFFFh, 7FFF FFFFh ] = [ 6000 0000h, 7FFF FFFFh ]</span></div></li><li class="list-item">per la RAM da <span class="math-span">\( 512 \mathrm{ \, MB }\)</span> (quindi <span class="math-span">\( 2^{29}\)</span> indirizzi), sarà divisa in quattro RAM da <span class="math-span">\( 128 \mathrm{ \, MB }\)</span> (<span class="math-span">\( 2^{27}\)</span> indirizzi) che "esiste" e comporterà quattro segnali di chip select, ovvero <span class="mono">CS_RAM_512MB_0</span>, <span class="mono">CS_RAM_512MB_1</span>, <span class="mono">CS_RAM_512MB_2</span>, <span class="mono">CS_RAM_512MB_3</span>;         </li><li class="list-item">per le istruzioni legate al segnale <span class="mono">STARTUP</span> saranno necessari due segnali, ovvero <span class="mono">CS_READ_STARTUP</span> e <span class="mono">CS_WRITE_STARTUP</span>;         </li><li class="list-item">per le istruzioni legate al LED saranno necessari due segnali, ovvero <span class="mono">CS_READ_LED</span> e <span class="mono">CS_WRITE_LED</span>.     </li></ul>     Per il calcolo dei chip select, consideriamo che:     <ul class="list-container"><li class="list-item">nella prima metà dello spazio di indirizzamento sono presenti due dispositivi, ovvero la RAM da <span class="math-span">\( 1 \mathrm{ \, GB }\)</span> e la EPROM, da cui          <div class="image-environment"><div class="image-wrapper spaced-90"><img alt="Immagine" src="../resources/generated-12.png"/></div></div>         si avrà quindi che:         <ul class="list-container"><li class="list-item">il bit <span class="mono">BA[31]</span> è necessario per discriminare tra le due metà dello spazio di indirizzamento;             </li><li class="list-item">il bit <span class="mono">BA[30]</span> è necessario per discriminare tra RAM e EPROM;             </li><li class="list-item">il bit <span class="mono">BA[29]</span> è necessario per discriminare quale delle due RAM attivare.         </li></ul>         Ciò implica         <div class="center"><span class="mono">CS_EPROM_0 = <span class="overline">BA[31]</span> ·  <span class="overline">BA[30]</span> ·  BE0</span><br/><span class="mono">CS_EPROM_1 = <span class="overline">BA[31]</span> ·  <span class="overline">BA[30]</span> ·  BE1</span><br/><span class="mono">CS_EPROM_2 = <span class="overline">BA[31]</span> ·  <span class="overline">BA[30]</span> ·  BE2</span><br/><span class="mono">CS_EPROM_3 = <span class="overline">BA[31]</span> ·  <span class="overline">BA[30]</span> ·  BE3</span><br/><span class="mono">CS_RAM_1GB_L_0 = <span class="overline">BA[31]</span> ·  BA[30] ·  <span class="overline">BA[29]</span> ·  BE0</span><br/><span class="mono">CS_RAM_1GB_L_1 = <span class="overline">BA[31]</span> ·  BA[30] ·  <span class="overline">BA[29]</span> ·  BE1</span><br/><span class="mono">CS_RAM_1GB_L_2 = <span class="overline">BA[31]</span> ·  BA[30] ·  <span class="overline">BA[29]</span> ·  BE2</span><br/><span class="mono">CS_RAM_1GB_L_3 = <span class="overline">BA[31]</span> ·  BA[30] ·  <span class="overline">BA[29]</span> ·  BE3</span><br/><span class="mono">CS_RAM_1GB_H_0 = <span class="overline">BA[31]</span> ·  BA[30] ·  BA[29] ·  BE0</span><br/><span class="mono">CS_RAM_1GB_H_1 = <span class="overline">BA[31]</span> ·  BA[30] ·  BA[29] ·  BE1</span><br/><span class="mono">CS_RAM_1GB_H_2 = <span class="overline">BA[31]</span> ·  BA[30] ·  BA[29] ·  BE2</span><br/><span class="mono">CS_RAM_1GB_H_3 = <span class="overline">BA[31]</span> ·  BA[30] ·  BA[29] ·  BE3</span></div></li><li class="list-item">nella seconda metà dello spazio di indirizzamento sono presenti una RAM da <span class="math-span">\( 512 \mathrm{ \, MB }\)</span>, le due istruzioni per comandare il segnale <span class="mono">STARTUP</span> e le due istruzioni per gestire il LED, da cui         <div class="image-environment"><div class="image-wrapper spaced-90"><img alt="Immagine" src="../resources/generated-13.png"/></div></div>         si avrà quindi che:         <ul class="list-container"><li class="list-item">il bit <span class="mono">BA[31]</span> è necessario per discriminare tra le due metà dello spazio di indirizzamento;             </li><li class="list-item">i bit <span class="mono">BA[30]</span> e <span class="mono">BA[29]</span> sono necessari per discriminare tra RAM, istruzioni per il segnale <span class="mono">STARTUP</span> e istruzioni per il LED;             </li><li class="list-item">il bit <span class="mono">BA[2]</span> è necessario nei comandi per discriminare lettura e scrittura.         </li></ul>         Ciò implica          <div class="center"><span class="mono">CS_READ_LED = BA[31] ·  <span class="overline">BA[30]</span> ·  <span class="overline">BA[29]</span> · BA[2] ·  MEMRD</span><br/><span class="mono">CS_WRITE_LED = BA[31] ·  <span class="overline">BA[30]</span> ·  <span class="overline">BA[29]</span> ·  BA[2]</span><br/><span class="mono">CS_READ_STARTUP = BA[31] ·  BA[30] ·  <span class="overline">BA[29]</span> ·  BA[2] ·  MEMRD </span><br/><span class="mono">CS_WRITE_STARTUP = BA[31] ·  BA[30] ·  <span class="overline">BA[29]</span>·  <span class="overline">BA[2]</span> ·  MEMWR</span><br/><span class="mono">CS_RAM_512MB_0 = BA[31] ·  BA[30] ·  BA[29] ·  BE0</span><br/><span class="mono">CS_RAM_512MB_1 = BA[31] ·  BA[30] ·  BA[29] ·  BE1</span><br/><span class="mono">CS_RAM_512MB_2 = BA[31] ·  BA[30] ·  BA[29] ·  BE2</span><br/><span class="mono">CS_RAM_512MB_3 = BA[31] ·  BA[30] ·  BA[29] ·  BE3</span></div></li></ul><span class="inner-title">Collegamenti logici</span>     Una volta calcolati i Chip Select, è possibile effettuare il collegamento logico alle memorie. Si ha quindi il collegamento della <span class="math-span">\( i\)</span>-esima EPROM      <div class="image-environment"><div class="image-wrapper spaced-60"><img alt="Immagine" src="../resources/eprom-128MB-32bitSystem.png"/></div></div>     della <span class="math-span">\( i\)</span>-esima RAM (della memoria da <span class="math-span">\( 512 \mathrm{ \, MB }\)</span>)     <div class="image-environment"><div class="image-wrapper spaced-60"><img alt="Immagine" src="../resources/ram512MB-128MB-32bitSystem.png"/></div></div>     e della <span class="math-span">\( i\)</span>-esima <span class="mono">RAM_L</span> (e in maniera non dissimile per la <span class="mono">RAM_H</span>)      <div class="image-environment"><div class="image-wrapper spaced-60"><img alt="Immagine" src="../resources/ram1GB-128MB-32bitSystem.png"/></div></div><span class="inner-title">Segnale <span class="mono">STARTUP</span></span>     Per il segnale <span class="mono">STARTUP</span>, è possibile utilizzare un Latch CD nel seguente modo:     <div class="image-environment"><div class="image-wrapper spaced-75"><img alt="Immagine" src="../resources/rete-startup.png"/></div></div>     Le istruzioni per la lettura del valore di <span class="mono">STARTUP</span> saranno     <pre class="code-block"><code>LHI R1, 0xC000      ; R1 = 0xC000 0000 (Indirizzo istruzioni)
LW R3, 0x0000(R1)   ; Lettura</code></pre>     e per la scrittura     <pre class="code-block"><code>LHI R1, 0xC000      ; R1 = 0xC000 0000 (Indirizzo istruzioni)
ADD R2, R0, 0x0001  ; R2 = 1
SW R2, 0x0004(R1)   ; Scrittura del valore 1</code></pre><span class="inner-title">Comandare un LED</span>     Per comandare il LED, è necessario utilizzare un Flip-Flop nel seguente modo:     <div class="image-environment"><div class="image-wrapper spaced-75"><img alt="Immagine" src="../resources/rete-led.png"/></div></div>     Le istruzioni per la lettura dello stato del LED saranno     <pre class="code-block"><code>LHI R1, 0x9000      ; R1 = 0x9000 0000 (Indirizzo istruzioni)
LW R2, 0x0000(R1)   ; Lettura</code></pre>     e per la scrittura (inversione del valore)     <pre class="code-block"><code>LHI R1, 0x9000      ; R1 = 0x9000 0000 (Indirizzo istruzioni)
SW R2, 0x0004(R1)   ; Scrittura (Inversione)</code></pre></div><div class="environment-tail"><span class="material-symbols-outlined body-visibility-icon" onclick="expand_environment(event)">expand_more</span></div></div>
            </article>
            <nav class="buttons-container content-width">
                <a class="navigation-button previous" href="instruction-set-architecture.html" rel="nofollow"><span>Instruction Set Architecture</span></a>
                <a class="navigation-button next" href="eventi-e-interruzioni.html" rel="nofollow"><span>Eventi e interruzioni</span></a>
            </nav>
        </section>
        <div class="scroll-to-bottom-button" onclick="scroll_to_bottom()">
            <span class="material-symbols-outlined">
                keyboard_double_arrow_down
            </span>
        </div>
        <footer class="footer-wrapper">
            <div class="copyright-wrapper">
                <span> &copy; Copyright 2023</span> /
                <span>made by lorenzoarlo</span>
            </div>
            /
            <div class="privacy-wrapper">
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/" rel="nofollow">Pannello preferenze cookie</a></span> /
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/privacy-policy.html" rel="nofollow" target="_blank" >Privacy Policy</a></span>
            </div>
        </footer>
    </div>
</body>
</html>