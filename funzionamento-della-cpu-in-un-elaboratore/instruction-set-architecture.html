<!DOCTYPE html>
<html lang="IT">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="stylesheet" href="../styles/style.css" />
    <link rel="stylesheet" href="../styles/index-style.css" />
    <link rel="stylesheet" href="../styles/content-style.css" />
    <meta name="format-detection" content="telephone=no">
    <meta name="application-name" content="Calcolatori elettronici" />
    <meta name="apple-mobile-web-app-title" content="Calcolatori elettronici" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="#FFD700" />
    <link rel="apple-touch-icon" sizes="144x144" href="../apple-icon-144x144.png">
    <link rel="icon" type="image/x-icon" href="../favicon.ico">
    <link rel="icon" type="image/png" sizes="192x192"  href="../android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="96x96" href="../favicon-96x96.png">
    <meta name="msapplication-TileColor" content="#FFD700">
    <meta name="msapplication-TileImage" content="../ms-icon-144x144.png">
    <meta name="theme-color" content="#FFD700">
    <link rel="manifest" href="../manifest.json">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-78NHLXDQD8"></script>
    <script src="../scripts/script.js"></script>
    <style>:root { --bg-clr: #FFD700; --fg-clr: #262626; }</style>
    <meta name="keywords" content="calcolatori elettronici" />
    <meta name="description" content="Il seguente sito contiene gli appunti e le definizioni del corso 'Calcolatori elettronici T'.">
    <meta name="robots" content="index">
    <script defer async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <title>Calcolatori elettronici - Funzionamento della CPU in un elaboratore - Instruction Set Architecture</title>
</head>
<body>
    <div class="container">
        <header class="header-wrapper">
            <div class="title-wrapper">
                <span class="title">
                    Calcolatori elettronici
                </span>
                <span class="subtitle">
                    by lorenzoarlo
                </span>
            </div>
            <span class="page-title">
                Funzionamento della CPU in un elaboratore
            </span>
        </header>
        <aside class="sidebar">
            <h2 class="sidebar-title">Calcolatori elettronici</h2>
            <div class="index-container">
                <ul class="parent-ul"><li class="section-li"><a href="../index.html" rel="nofollow">Indice</a></li><li class="section-li current">Funzionamento della CPU in un elaboratore<ul><li class="subsection-li "><a href="il-modello-della-cpu.html" rel="nofollow">Il modello della CPU</a></li><li class="subsection-li "><a href="comunicazione-con-dispositivi.html" rel="nofollow">Comunicazione con dispositivi</a></li><li class="subsection-li current">Instruction Set Architecture<ul><li class="definition-li"><a href="#def1-18" rel="nofollow">ISA</a></li><li class="definition-li"><a href="#def1-19" rel="nofollow">Caratteristiche e requisiti di un ISA</a></li><li class="definition-li"><a href="#def1-20" rel="nofollow">L'accesso ai registri</a></li><li class="definition-li"><a href="#def1-21" rel="nofollow">Codifica binaria delle istruzioni e linguaggio assembler</a></li><li class="definition-li"><a href="#def1-22" rel="nofollow">Modalità di accesso alla memoria</a></li><li class="definition-li"><a href="#def1-23" rel="nofollow">Ordine di memorizzazione dei dati</a></li><li class="definition-li"><a href="#def1-24" rel="nofollow">Notazione per codifiche binarie</a></li></ul></li><li class="subsection-li "><a href="il-microprocessore-dlx.html" rel="nofollow">Il microprocessore DLX</a></li><li class="subsection-li "><a href="eventi-e-interruzioni.html" rel="nofollow">Eventi e interruzioni</a></li><li class="subsection-li "><a href="protocollo-di-comunicazione-handshake.html" rel="nofollow">Protocollo di comunicazione handshake</a></li></ul></li><li class="section-li "><a href="../progettazione-dlx/implementazione-sequenziale.html" rel="nofollow">Progettazione DLX</a><ul><li class="subsection-li "><a href="../progettazione-dlx/implementazione-sequenziale.html" rel="nofollow">Implementazione sequenziale</a></li><li class="subsection-li "><a href="../progettazione-dlx/implementazione-pipelined.html" rel="nofollow">Implementazione pipelined</a></li></ul></li></ul>
            </div>
        </aside>
        <div class="sidebar-button" onclick="toggle_sidebar(this)" role="button" >
            keyboard_double_arrow_right
        </div>
        <section class="content-wrapper">
            <h1 class="section-title content-width">Instruction Set Architecture</h1>
            <article class="content-container content-width">
                <div class="definition environment" id="def1-18"><h2 class="environment-title">Definizione - ISA</h2><div class="environment-body">     L'<strong>ISA</strong> (<i><strong>I</strong>nstruction <strong>S</strong>et <strong>A</strong>rchitecture</i>) è l'insieme di tutte le istruzioni macchina che descrive il funzionamento di una CPU.     <br/>     Ogni CPU è caratterizzata da un proprio ISA che può essere del tipo:     <ul class="list-container"><li class="list-item"><strong>RISC</strong> (<i><strong>R</strong>educed <strong>I</strong>nstruction <strong>S</strong>et <strong>C</strong>omputer</i>), dove l'insieme delle istruzioni ridotto e sono presenti (solitamente) <strong>molti registri</strong> interni;         </li><li class="list-item"><strong>CISC</strong> (<i><strong>C</strong>omplex <strong>I</strong>nstruction <strong>S</strong>et <strong>C</strong>omputer</i>), dove l'insieme delle istruzioni è ampio e sono presenti (solitamente) <strong>pochi registri</strong> interni.     </li></ul>     Proprio la presenza di molti registri, rende le architetture RISC più veloci nell'esecuzione dei programmi dato che devono effettuare meno accessi in memoria. </div></div><div class="definition environment" id="def1-19"><h2 class="environment-title">Definizione - Caratteristiche e requisiti di un ISA</h2><div class="environment-body">     Nonostante esistano ISA differenti, si ha che essi sono caratterizzati da requisiti e parametri comuni.      Si ha infatti che un generico ISA deve:     <ul class="list-container"><li class="list-item">poter risolvere un qualsiasi problema (considerando i problemi risolvibili algoritmicamente);         </li><li class="list-item">minimizzare il tempo di esecuzione del codice  <span class="mono">CPU<sub>time</sub></span>.     </li></ul>      Il <span class="mono">CPU<sub>time</sub></span> indica il tempo che una CPU impiega per eseguire un certo codice, ed è uguale a:     <div class="center">         <span class="mono">CPU<sub>time</sub> = N<sub>istruzioni</sub> ·  CPI<sub>medio</sub> ·  T<sub>clock</sub></span>     </div>      dove     <ul class="list-container"><li class="list-item"><span class="mono">N<sub>istruzioni</sub></span> è il numero di istruzioni di cui è composto il codice;         </li><li class="list-item"><span class="mono">CPI<sub>medio</sub></span> (<i>Cost Per Instruction<sub>medio</sub></i>) è il costo medio in termini di tempo per istruzione;         </li><li class="list-item"><span class="mono">T<sub>clock</sub></span> è la durata del periodo di clock.     </li></ul> </div></div><div class="definition environment" id="def1-20"><h2 class="environment-title">Definizione - L'accesso ai registri</h2><div class="environment-body">     Ogni CPU possiede delle <strong>risorse interne</strong>, come i <strong>registri architetturali</strong> e i <strong>registri di stato</strong>.      Il grande vantaggio dei registri è l'accesso ai dati diretto, senza necessità di compiere <strong>cicli di bus</strong>.     Tuttavia, non tutti i registri sono accedibili e sovrascribili dal programmatore, il quale può utilizzare liberamente solo i cosiddetti <strong>registri general purpose</strong>. </div></div><div class="definition environment" id="def1-21"><h2 class="environment-title">Definizione - Codifica binaria delle istruzioni e linguaggio assembler</h2><div class="environment-body">     Un'istruzione, per essere eseguita dalla CPU, deve essere codificata in binario secondo un formato descritto dal produttore nel datasheet e decodificabile dall'<strong>unità di controllo</strong>.     <br/>     La codifica delle istruzioni può essere a <strong>lunghezza costante</strong> (ovvero ad ogni istruzione è assegnato lo stesso numero di bit), oppure <strong>variabile</strong>.      <br/>     Risulta tuttavia poco intuitivo per gli esseri umani utilizzare le istruzioni in codice binario: per questo motivo si utilizza un linguaggio assembler che codifica ogni istruzione in modo più intuitivo (attraverso parole, ad esempio). </div></div><div class="definition environment" id="def1-22"><h2 class="environment-title">Definizione - Modalità di accesso alla memoria</h2><div class="environment-body">     Ogni ISA permette tramite alcune istruzioni di accedere alla memoria.      In base a come l'indirizzo a cui si vuole accedere è espresso, si differenziano diversi modi di accesso alla memoria:     <ul class="list-container"><li class="list-item">con l'<strong>accesso diretto</strong> si ha che l'istruzione contiene internamente l'indirizzo a cui si vuole accedere (rendendolo quindi dipendente da una costante);         </li><li class="list-item">con l'<strong>accesso indiretto</strong> si ha che l'indirizzo è ottenuto dalla somma di una costante e un registro, rendendolo quindi modificabile anche a run-time (modificando il contenuto del registro).     </li></ul> </div></div><div class="definition environment" id="def1-23"><h2 class="environment-title">Definizione - Ordine di memorizzazione dei dati</h2><div class="environment-body">     Ogni ISA di sistemi con parallelismo dati maggiore di <span class="math-span">\( 8 \mathrm{ \, bit }\)</span> adotta una convenzione di memorizzazione dei dati.     In base all'ordine si differenziano le modalità:     <ul class="list-container"><li class="list-item"><strong>little-endian</strong> in cui sono memorizzati prima i Byte meno significativi;         </li><li class="list-item"><strong>big-endian</strong> in cui sono memorizzati prima i Byte più significativi.     </li></ul>     <div class="mynote environment"><h3 class="environment-title">Nota bene - Ad esempio</h3><div class="environment-body">         Per capire meglio consideriamo che si vuole memorizzare il numero di due Byte <span class="mono">0xBCFA</span>, si avrà che:         <ul class="list-container"><li class="list-item">in un sistema little-endian si avrà che all'indirizzo <span class="mono">0x01</span> è memorizzato il Byte <span class="mono">BC</span> e all'indirizzo <span class="mono">0x00</span> è memorizzato il Byte <span class="mono">0xFA</span>;             </li><li class="list-item">in un sistema big-endian si avrà che all'indirizzo <span class="mono">0x01</span> è memorizzato il Byte <span class="mono">FA</span> e all'indirizzo <span class="mono">0x00</span> è memorizzato il Byte <span class="mono">0xBC</span>;         </li></ul>     </div></div> </div></div><div class="definition environment" id="def1-24"><h2 class="environment-title">Definizione - Notazione per codifiche binarie</h2><div class="environment-body">     Dato che ad ogni CPU corrispondono istruzioni differenti e linguaggi assembler diversi, è utile utilizzare una notazione comune e generale per indicare comuni operazioni sulle configurazioni binarie.     <br/>     Si avrà ad esempio:     <ul class="list-container"><li class="list-item">per indicare la <strong>traslazione logica</strong> (lo shift) di <span class="mono">n</span> bit si utilizzerà la notazione <span class="mono">W &lt;&lt;n</span> per lo shift logico a sinistra di <span class="math-span">\( n\)</span> bit (inserendo <span class="math-span">\( n\)</span> cifre <span class="mono">0</span> a destra) e <span class="mono">W &gt;&gt;<span class="math-span">\( n\)</span></span> per lo shift logico a destra.          Ad esempio         <div class="center">             <span class="mono">0111 &lt;&lt;2 = 1100</span>         </div>         </li><li class="list-item">per indicare la <strong>concatenazione</strong> di due configurazioni si utilizza la notazione ##, ad esempio         <div class="center">             <span class="mono">0111 ## 1010 = 01111010</span>         </div>         </li><li class="list-item">per indicare la <strong>ripetizione</strong> della configurazione per <span class="mono">n</span> volte si utilizza la notazione <span class="mono">(W)<sup>n</sup></span>, ad esempio         <div class="center">             <span class="mono">(011)<sup>3</sup> = 011011011</span>         </div>         </li><li class="list-item">per indicare <strong>l'<span class="mono">n</span>-esimo bit di una configurazione</strong> binaria si utilizza la notazione <span class="mono">(W)<sub>n</sub></span>, ad esempio         <div class="center">             <span class="mono">(00001)<sub>0</sub> = 1</span>         </div>         </li><li class="list-item">per indicare la <strong>selezione di una sottostringa</strong> da una configurazione si utilizza la notazione <span class="mono">(W)<sub>n..m</sub></span> (con <span class="mono">n</span> e <span class="mono">m</span> inclusi), ad esempio         <div class="center">             <span class="mono">(00001)<sub>2..0</sub> = 001</span>         </div>         </li><li class="list-item">per indicare il trasferimento di un dato si utilizza la notazione <span class="mono">←</span> (se il numero di bit è deducibile) oppure <span class="mono">←<sub>n</sub></span> per indicare il trasferimento di <span class="mono">n</span> bit, ad esempio         <div class="center">             <span class="mono">R1 ←<sub>32</sub> R2</span>         </div>         </li><li class="list-item">per indicare il contenuto di celle di memoria adiacenti a partire da un indirizzo <span class="mono">x</span> si può scrivere <span class="mono">M[x]</span>, ad esempio         <div class="center">             <span class="mono">R1 ←<sub>32</sub> M[x]</span>         </div>         trasferirà quattro byte, in particolare i byte <span class="mono">M[x]</span>, <span class="mono">M[x + 1]</span>, <span class="mono">M[x + 2]</span> e <span class="mono">M[x + 3]</span> nel registro <span class="mono">R1</span>.     </li></ul> </div></div>
            </article>
            <nav class="buttons-container content-width">
                <a class="navigation-button previous" href="comunicazione-con-dispositivi.html" rel="nofollow"><span>Comunicazione con dispositivi</span></a>
                <a class="navigation-button next" href="il-microprocessore-dlx.html" rel="nofollow"><span>Il microprocessore DLX</span></a>
            </nav>
        </section>
        <div class="scroll-to-bottom-button" onclick="scroll_to_bottom()">
            <span class="material-symbols-outlined">
                keyboard_double_arrow_down
            </span>
        </div>
        <footer class="footer-wrapper">
            <div class="copyright-wrapper">
                <span> &copy; Copyright 2024</span> /
                <span>made by lorenzoarlo</span>
            </div>
            /
            <div class="privacy-wrapper">
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/" rel="nofollow">Pannello preferenze cookie</a></span> /
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/privacy-policy.html" rel="nofollow" target="_blank" >Privacy Policy</a></span>
            </div>
        </footer>
    </div>
</body>
</html>