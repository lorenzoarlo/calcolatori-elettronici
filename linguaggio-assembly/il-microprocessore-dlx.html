<!DOCTYPE html>
<html lang="IT">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="stylesheet" href="../styles/style.css" />
    <link rel="stylesheet" href="../styles/index-style.css" />
    <link rel="stylesheet" href="../styles/content-style.css" />
    <link rel="icon" type="image/x-icon" href="../resources/favicon.ico">
    <link rel="apple-touch-icon" href="../resources/favicon.png" />
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-78NHLXDQD8"></script>
    <script src="../scripts/script.js"></script>
    <style>:root { --bg-clr: #FFD700; --fg-clr: #262626; }</style>
    <meta name="theme-color" content="#FFD700" />
    <meta name="keywords" content="calcolatori elettronici" />
    <meta name="description" content="Il seguente sito contiene gli appunti e le definizioni del corso 'Calcolatori elettronici T'.">
    <meta name="robots" content="index">
    <script defer async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <title>Calcolatori elettronici - Linguaggio Assembly - Il microprocessore DLX</title>
</head>
<body>
    <div class="container">
        <header class="header-wrapper">
            <div class="title-wrapper">
                <span class="title">
                    Calcolatori elettronici
                </span>
                <span class="subtitle">
                    by lorenzoarlo
                </span>
            </div>
            <span class="page-title">
                Linguaggio Assembly
            </span>
        </header>
        <section class="content-wrapper">
            <h1 class="section-title content-width">Il microprocessore DLX</h1>
            <article class="content-container content-width">
                <div class="definition environment" id="def2-9"><h2 class="environment-title">Definizione - Caratteristiche e segnali del microprocessore DLX</h2><div class="environment-body">     Il microprocessore DLX è caratterizzato da:     <ul class="list-container"><li class="list-item">un <strong>Data Bus</strong> di dimensione <span class="math-span">\( 32 \mathrm{ \, bit }\)</span>;         </li><li class="list-item">un <strong>unico spazio di indirizzamento</strong> di <span class="math-span">\( 4 \mathrm{ \, GB }\)</span> (ovvero <span class="math-span">\( {32}\)</span> bit di indirizzo, che tuttavia diventano <span class="math-span">\( 29\)</span>, con <span class="math-span">\( 4\)</span> segnali di Bus Enable a causa della grandezza del Data Bus)     </li></ul>     con ISA di tipo RISC e caratterizzata da:     <ul class="list-container"><li class="list-item"><span class="math-span">\( 32\)</span> registri (da <span class="math-span">\( 32 \mathrm{ \, bit }\)</span>) <strong>general purpose</strong>, indicati con (<span class="mono">R0</span>, <span class="mono">R1</span>, <span class="mono">...</span>, <span class="mono">R31</span>). Di questi, il registro <span class="mono">R0</span> non è sovrascribile e contiene la costante <span class="mono">0x00000000</span>;         </li><li class="list-item"><span class="math-span">\( 4\)</span> registri <strong>speciali</strong> (sempre da <span class="math-span">\( 32 \mathrm{ \, bit }\)</span>) non direttamente accedibili tramite istruzioni:         <ul class="list-container"><li class="list-item">il registro <span class="mono">PC</span> (<i>Program Counter</i>), che contiene l'indirizzo in memoria della <strong>prossima istruzione</strong> (a cui sarà poi effettuato il fetch). Ad ogni istruzione esso incrementa automaticamente di <span class="math-span">\( 4 \mathrm{ \, Byte }\)</span>;             </li><li class="list-item">il registro <span class="mono">IAR</span> (<i>Interrupt Address Register</i>), in cui è depositato il Program Counter a <strong>seguito di un segnale di Interrupt</strong>;             </li><li class="list-item">il registro <span class="mono">MAR</span> (<i>Memory Address Register</i>), che contiene il contenuto dell'Address Bus (che è modificato quindi durante i cicli di Bus);             </li><li class="list-item">il registro <span class="mono">MDR</span> (<i>Memory Data Register</i>), che contiene il contenuto del Data Bus (modificato anch'esso durante i cicli di Bus).         </li></ul></li><li class="list-item">non sono presenti registri contenenti i flag impostati dall'<strong>ALU</strong> (<i>Arithmetic Logic Unit</i>);         </li><li class="list-item">istruzioni di <strong>lunghezza fissa</strong> a <span class="math-span">\( 32 \mathrm{ \, bit }\)</span> allineate (ovvero informazioni per la decodifica nelle stesse posizioni);         </li><li class="list-item">modalità di <strong>accesso</strong> alla memoria <strong>indiretto</strong>;         </li><li class="list-item">ordine di memorizzazione dei dati <strong>little-endian</strong>.     </li></ul><span class="inner-title">I segnali del DLX</span>     Considerando tali caratterische, si ha che il processore DLX è caratterizzato da:     <ul class="list-container"><li class="list-item">un ingresso <span class="mono">CLK</span> per il segnale di clock;         </li><li class="list-item">un ingresso <span class="mono">RESET</span> per il segnale di inizializzazione all'accensione;         </li><li class="list-item">un'uscita per l'Address Bus di <span class="math-span">\( 29 \mathrm{ \, bit }\)</span> (<span class="mono">BA[31..2]</span>);         </li><li class="list-item">quattro uscite per i segnali di Bus Enable (<span class="mono">BE0</span>, <span class="mono">BE1</span>, <span class="mono">BE2</span> e <span class="mono">BE3</span>);         </li><li class="list-item">due uscite <span class="mono">RD</span> e <span class="mono">WR</span> per i segnali di controllo <span class="mono">MEMRD</span> e <span class="mono">MEMWR</span>;         </li><li class="list-item">due ingressi <span class="mono">READY</span> e <span class="mono">INT</span> per i segnali di controllo omonimi;         </li><li class="list-item">un ingresso/uscita per il Data Bus di <span class="math-span">\( 32 \mathrm{ \, bit }\)</span>.     </li></ul><span class="inner-title">Tipi di dato (numeri interi)</span>     Il processore DLX è in grado di gestire numeri interi signed e unsigned di grandezza:     <ul class="list-container"><li class="list-item"><span class="math-span">\( 8 \mathrm{ \, bit }\)</span>, ovvero un <i>Byte</i>;         </li><li class="list-item"><span class="math-span">\( 16 \mathrm{ \, bit }\)</span>, ovvero una <i>Half-Word</i>;         </li><li class="list-item"><span class="math-span">\( 32 \mathrm{ \, bit }\)</span>, ovvero una <i>Word</i>.      </li></ul>      Tutti i dati di dimensione inferiore a <span class="math-span">\( 32 \mathrm{ \, bit }\)</span> (gestiti quando si vuole leggere dalla memoria dati di queste grandezze) sono estesi a <span class="math-span">\( 32 \mathrm{ \, bit }\)</span> in questo modo:     <ul class="list-container"><li class="list-item">nel caso di <strong>interi unsigned</strong> si aggiungono alla sinistra il numero di <span class="mono">0</span> necessari per raggiungere i <span class="math-span">\( 32 \mathrm{ \, bit }\)</span>;         </li><li class="list-item">nel caso di <strong>interi signed</strong> si aggiunge alla sinistra la cifra più significativa del numero letto per raggiungere i <span class="math-span">\( 32 \mathrm{ \, bit }\)</span> (in questo modo è possibile mantenere il segno).      </li></ul></div></div><div class="definition environment" id="def2-10"><h2 class="environment-title">Definizione - Formato delle istruzioni</h2><div class="environment-body">     Nel linguaggio assembly per DLX esistono tre tipi di formati di istruzioni differenti per gli "argomenti passati":     <ul class="list-container"><li class="list-item">istruzioni del tipo <span class="mono">R</span> (da <i><strong>R</strong>egister</i>) caratterizzate da un registro di destinazione, due registri operandi;         </li><li class="list-item">istruzioni del tipo <span class="mono">I</span> (da <i><strong>I</strong>mmediate</i>) caratterizzate da un registro di destinazione, un registro operando e un immediato (una costante) a <span class="math-span">\( 16 \mathrm{ \, bit }\)</span>;         </li><li class="list-item">istruzioni del tipo <span class="mono">J</span> (da <i><strong>J</strong>ump</i>) caratterizzate da un immediato a <span class="math-span">\( 26 \mathrm{ \, bit }\)</span>.     </li></ul>      Ogni istruzione (non dipendente dal tipo) contiene un <strong>Operation Code</strong> di <span class="math-span">\( 6 \mathrm{ \, bit }\)</span> che discrimina i vari tipi di operazioni.     <span class="inner-title">Istruzioni <span class="mono">R</span></span>     Le istruzioni del tipo <span class="mono">R</span> comprendono le istruzioni aritmetiche, logiche e istruzioni di set. Una tipica istruzione <span class="mono">R</span> sarà quindi uguale a:     <div class="image-environment"><div class="image-wrapper spaced-90"><img alt="Immagine" src="../resources/generated-9.png"/></div></div>     Gli <span class="math-span">\( 11 \mathrm{ \, bit }\)</span> di estensione sono utili per estendere l'operation code e per la creazione di ulteriori istruzioni.     <span class="inner-title">Istruzioni <span class="mono">I</span></span>     Le istruzioni del tipo <span class="mono">I</span> comprendono le istruzioni di load, store, branch, di operazioni aritmetiche, logiche, di set tra un registro, ecc.. Una tipica istruzione <span class="mono">I</span> sarà quindi uguale a:     <div class="image-environment"><div class="image-wrapper spaced-90"><img alt="Immagine" src="../resources/generated-10.png"/></div></div>     Tale immediato, codificato con <span class="math-span">\( 16\)</span> bit per motivi di spazio, per essere utilizzato dalla CPU dovrà essere esteso a <span class="math-span">\( 32 \mathrm{ \, bit }\)</span> (tale estensione potrà essere fatta sia con segno che senza in base alle necessità).     <span class="inner-title">Istruzioni <span class="mono">J</span></span>     Le istruzioni del tipo <span class="mono">J</span> comprendono le istruzioni di Jump. Una tipica istruzione <span class="mono">J</span> sarà quindi uguale a:     <div class="image-environment"><div class="image-wrapper spaced-90"><img alt="Immagine" src="../resources/generated-11.png"/></div></div><div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Giusto per capirci...</h3><div class="environment-body">         La ripartizione dei bit non è fedele alla realtà: ad esempio l'OP Code potrebbe essere suddiviso in due intervalli non contigui. Ciò che è importante, tuttavia, è l'allineamento di questi campi (ad esempio, se l'OP Code occupa i bit nelle posizioni <span class="mono">31 30 29 28 25 24</span>, si ha che deve occupare queste posizioni in ogni istruzione).      </div></div></div></div><div class="definition environment" id="def2-11"><h2 class="environment-title">Definizione - Istruzioni per il Data Transfer</h2><div class="environment-body">     Le istruzioni per il Data Transfer comprendono tutte quelle istruzioni che permettono l'<strong>interazione con memorie e periferiche esterne</strong>.      Considerando <span class="mono">RD</span> un registro destinazione, <span class="mono">RS</span> un registro sorgente, <span class="mono">RSP</span> un registro speciale e <span class="mono">Imm16</span> un valore "immediato" a <span class="math-span">\( 16 \mathrm{ \, bit }\)</span> si ha:     <ul class="list-container"><li class="list-item">le istruzioni per <strong>leggere un dato</strong> ad un <strong>indirizzo della memoria</strong> (ottenuto sommando il contenuto del registro all'immediato signed) e inserirlo nel registro <span class="mono">RD</span>, in particolare         <ul class="list-container"><li class="list-item"><span class="code-inline">LW RD, Imm16(RS)</span> (<i><strong>L</strong>oad <strong>W</strong>ord</i>) permette la lettura di interi signed a <span class="math-span">\( 32 \mathrm{ \, bit }\)</span>;             </li><li class="list-item"><span class="code-inline">LH RD, Imm16(RS)</span> (<i><strong>L</strong>oad <strong>H</strong>alf Word</i>) permette la lettura di interi signed a <span class="math-span">\( 16 \mathrm{ \, bit }\)</span> (si avrà quindi un'estensione a <span class="math-span">\( 32 \mathrm{ \, bit }\)</span> con segno);             </li><li class="list-item"><span class="code-inline">LHU RD, Imm16(RS)</span> (<i><strong>L</strong>oad <strong>H</strong>alf Word Unsigned</i>) permette la lettura di interi unsigned a <span class="math-span">\( 16 \mathrm{ \, bit }\)</span> (si avrà quindi un'estensione a <span class="math-span">\( 32 \mathrm{ \, bit }\)</span> senza segno);             </li><li class="list-item"><span class="code-inline">LB RD, Imm16(RS)</span> (<i><strong>L</strong>oad <strong>B</strong>yte</i>) permette la lettura di interi signed a <span class="math-span">\( 8 \mathrm{ \, bit }\)</span>;             </li><li class="list-item"><span class="code-inline">LBU RD, Imm16(RS)</span> (<i><strong>L</strong>oad <strong>B</strong>yte <strong>U</strong>nsigned</i>) permette la lettura di interi signed a <span class="math-span">\( 8 \mathrm{ \, bit }\)</span>;         </li></ul></li><li class="list-item">le istruzioni per <strong>scrivere il dato</strong> contenuto nel registro <span class="mono">RS</span> ad un <strong>indirizzo della memoria</strong>, in particolare         <ul class="list-container"><li class="list-item"><span class="code-inline">SW RS, Imm16(RS)</span> (<i><strong>S</strong>tore <strong>W</strong>ord</i>) permette la scrittura di interi signed a <span class="math-span">\( 32 \mathrm{ \, bit }\)</span>;             </li><li class="list-item"><span class="code-inline">SH RS, Imm16(RS)</span> (<i><strong>S</strong>tore <strong>H</strong>alf Word</i>) permette la scrittura di interi signed a <span class="math-span">\( 16 \mathrm{ \, bit }\)</span> (si avrà quindi un'estensione a <span class="math-span">\( 32 \mathrm{ \, bit }\)</span> con segno);             </li><li class="list-item"><span class="code-inline">SB RS, Imm16(RS)</span> (<i><strong>S</strong>tore <strong>B</strong>yte</i>) permette la scrittura di interi signed a <span class="math-span">\( 8 \mathrm{ \, bit }\)</span>;         </li></ul></li><li class="list-item"><span class="code-inline">MOVS2I RS, RSP</span> è un istruzione per copiare il contenuto di un registro general purpose <span class="mono">RS</span> a un registro speciale <span class="mono">RSP</span>;         </li><li class="list-item"><span class="code-inline">MOVI2S RSP, RD</span> è un istruzione per copiare il contenuto di un registro speciale <span class="mono">RSP</span> a un registro general purpose <span class="mono">RS</span>;     </li></ul></div></div><div class="definition environment" id="def2-12"><h2 class="environment-title">Definizione - Istruzioni aritmetiche e logiche</h2><div class="environment-body">     Le istruzioni aritmetiche e logiche comprendono tutte quelle istruzioni che permettono di <strong>effettuare calcoli e operazioni</strong>.     Considerando <span class="mono">RD</span> un registro destinazione, <span class="mono">RS</span> un registro sorgente e <span class="mono">Imm16</span> un valore "immediato" a <span class="math-span">\( 16 \mathrm{ \, bit }\)</span> si ha:     <ul class="list-container"><li class="list-item">le <strong>istruzioni aritmetiche</strong> di tipo <span class="mono">R</span> (ovvero che "copiano" il risultato dell'operazione tra i due registri <span class="mono">RS</span> nel registro <span class="mono">RD</span>), in particolare         <ul class="list-container"><li class="list-item"><span class="code-inline">ADD RD, RS, RS</span> per la somma tra numeri interi con segno;             </li><li class="list-item"><span class="code-inline">ADDU RD, RS, RS</span> (<i><strong>ADD U</strong>nsigned</i>) per la somma tra numeri interi senza segno;             </li><li class="list-item"><span class="code-inline">SUB RD, RS, RS</span> (<i><strong>SUB</strong>tract</i>) per la differenza tra numeri interi con segno;             </li><li class="list-item"><span class="code-inline">SUBU RD, RS, RS</span> (<i><strong>SUB</strong>tract <strong>U</strong>nsigned</i>) per la differenza tra numeri interi senza segno;         </li></ul></li><li class="list-item">le <strong>istruzioni aritmetiche</strong> di tipo <span class="mono">I</span> (ovvero che "copiano" il risultato dell'operazione tra un registro e un immediato (esteso a <span class="math-span">\( 32 \mathrm{ \, bit }\)</span> con o senza segno in base all'istruzione)), in particolare         <ul class="list-container"><li class="list-item"><span class="code-inline">ADDI RD, RS, Imm16</span> (<i><strong>ADD I</strong>mmediate</i>) per la somma tra numeri interi con segno;             </li><li class="list-item"><span class="code-inline">ADDUI RD, RS, Imm16</span> (<i><strong>ADD U</strong>nsigned <strong>I</strong>mmediate</i>) per la somma tra numeri interi senza segno;             </li><li class="list-item"><span class="code-inline">SUBI RD, RS, Imm16</span> (<i><strong>SUB</strong>tract <strong>I</strong>mmediate</i>) per la differenza tra numeri interi con segno;             </li><li class="list-item"><span class="code-inline">SUBUI RD, RS, Imm16</span> (<i><strong>SUB</strong>tract <strong>U</strong>nsigned <strong>I</strong>mmediate</i>) per la differenza tra numeri interi senza segno;         </li></ul></li><li class="list-item">le <strong>istruzioni logiche</strong> di tipo <span class="mono">R</span> (ovvero che "copiano" il risultato dell'operazione tra i due registri <span class="mono">RS</span> nel registro <span class="mono">RD</span>), in particolare         <ul class="list-container"><li class="list-item"><span class="code-inline">AND RD, RS, RS</span> per l'AND bit-a-bit;             </li><li class="list-item"><span class="code-inline">OR RD, RS, RS</span> per l'OR bit-a-bit;             </li><li class="list-item"><span class="code-inline">XOR RD, RS, RS</span> per lo XOR bit-a-bit;         </li></ul></li><li class="list-item">le <strong>istruzioni logiche</strong> di tipo <span class="mono">I</span> (ovvero che "copiano" il risultato dell'operazione tra un registro e un immediato (esteso a <span class="math-span">\( 32 \mathrm{ \, bit }\)</span> sempre senza segno)), in particolare         <ul class="list-container"><li class="list-item"><span class="code-inline">ANDI RD, RS, Imm16</span> (<i><strong>AND I</strong>mmediate</i>) per l'AND bit-a-bit;             </li><li class="list-item"><span class="code-inline">ORI RD, RS, Imm16</span> (<i><strong>OR I</strong>mmediate</i>) per l'OR bit-a-bit;             </li><li class="list-item"><span class="code-inline">XORI RD, RS, Imm16</span> (<i><strong>XOR I</strong>mmediate</i>) per lo XOR bit-a-bit;         </li></ul></li><li class="list-item">le <strong>istruzioni di shift</strong> di tipo <span class="mono">R</span> (ovvero che effettuano lo scorrimento del contenuto del primo registro <span class="mono">RS</span> delle posizioni indicate nel contenuto del secondo registro <span class="mono">RS</span> e "copiano" il risultato nel registro <span class="mono">RD</span>), in particolare         <ul class="list-container"><li class="list-item"><span class="code-inline">SLL RD, RS, RS</span> (<i><strong>S</strong>hift <strong>L</strong>eft <strong>L</strong>ogical</i>) per lo shift logico verso sinistra;             </li><li class="list-item"><span class="code-inline">SRL RD, RS, RS</span> (<i><strong>S</strong>hift <strong>R</strong>ight <strong>L</strong>ogical</i>) per lo shift logico verso destra;             </li><li class="list-item"><span class="code-inline">SRA RD, RS, RS</span> (<i><strong>S</strong>hift <strong>R</strong>ight <strong>A</strong>rithmetical</i>) per lo shift aritmetico verso destra;         </li></ul></li><li class="list-item">le <strong>istruzioni di shift</strong> di tipo <span class="mono">I</span> (ovvero che effettuano lo scorrimento del contenuto del primo registro <span class="mono">RS</span> delle posizioni indicate dall'immediato e "copiano" il risultato nel registro <span class="mono">RD</span>), in particolare         <ul class="list-container"><li class="list-item"><span class="code-inline">SLLI RD, RS, Imm16</span> (<i><strong>S</strong>hift <strong>L</strong>eft <strong>L</strong>ogical <strong>I</strong>mmediate</i>) per lo shift logico verso sinistra;             </li><li class="list-item"><span class="code-inline">SRLI RD, RS, Imm16</span> (<i><strong>S</strong>hift <strong>R</strong>ight <strong>L</strong>ogical <strong>I</strong>mmediate</i>) per lo shift logico verso destra;             </li><li class="list-item"><span class="code-inline">SRAI RD, RS, Imm16</span> (<i><strong>S</strong>hift <strong>R</strong>ight <strong>A</strong>rithmetical <strong>I</strong>mmediate</i>) per lo shift aritmetico verso destra;         </li></ul></li><li class="list-item"><span class="code-inline">LHI RD, Imm16</span> (<i><strong>L</strong>oad <strong>H</strong>igh-Word <strong>I</strong>mmediate</i>) che permette il caricamento nel registro <span class="mono">RD</span> dell'immediato, posizionandolo però nelle posizioni più significative (e "riempiendo" il resto con <span class="mono">0</span>).      </li></ul></div></div><div class="definition environment" id="def2-13"><h2 class="environment-title">Definizione - Istruzioni di controllo</h2><div class="environment-body">     Le istruzioni di controllo comprendono le istruzioni di Set, di salto condizionato e non, ecc..     Considerando <span class="mono">RD</span> un registro destinazione, <span class="mono">RS</span> un registro sorgente, <span class="mono">Imm16</span> un valore "immediato" a <span class="math-span">\( 16 \mathrm{ \, bit }\)</span>, <span class="mono">Imm26</span> un valore "immediato" a <span class="math-span">\( 26 \mathrm{ \, bit }\)</span> si ha:     <ul class="list-container"><li class="list-item">le istruzioni di set di tipo <span class="mono">R</span> (ovvero che copiano nel registro <span class="mono">RD</span> se una condizione è rispettata (valore <span class="mono">1</span>) o meno (valore <span class="mono">0</span>) tra i due valori contenuti nei registri <span class="mono">RS</span>), in particolare         <ul class="list-container"><li class="list-item"><span class="code-inline">SLT RD, RS, RS</span> (<i><strong>S</strong>et <strong>L</strong>esser <strong>T</strong>han</i>) per verificare che il contenuto del primo registro sia minore "stretto" del secondo (confronto tra numeri con segno);             </li><li class="list-item"><span class="code-inline">SLTU RD, RS, RS</span> (<i><strong>S</strong>et <strong>L</strong>esser <strong>T</strong>han <strong>U</strong>nsigned</i>) per verificare che il contenuto del primo registro sia minore "stretto" del secondo (confronto tra numeri senza segno);             </li><li class="list-item"><span class="code-inline">SGT RD, RS, RS</span> (<i><strong>S</strong>et <strong>G</strong>reater <strong>T</strong>han</i>) per verificare che il contenuto del primo registro sia maggiore "stretto" del secondo (confronto tra numeri con segno);             </li><li class="list-item"><span class="code-inline">SGTU RD, RS, RS</span> (<i><strong>S</strong>et <strong>G</strong>reater <strong>T</strong>han <strong>U</strong>nsigned</i>) per verificare che il contenuto del primo registro sia maggiore "stretto" del secondo (confronto tra numeri senza segno);             </li><li class="list-item"><span class="code-inline">SLE RD, RS, RS</span> (<i><strong>S</strong>et <strong>L</strong>esser <strong>E</strong>qual</i>) per verificare che il contenuto del primo registro sia minore o uguale del secondo (confronto tra numeri con segno);             </li><li class="list-item"><span class="code-inline">SLEU RD, RS, RS</span> (<i><strong>S</strong>et <strong>L</strong>esser <strong>E</strong>qual <strong>U</strong>nsigned</i>) per verificare che il contenuto del primo registro sia minore o uguale del secondo (confronto tra numeri senza segno);             </li><li class="list-item"><span class="code-inline">SGE RD, RS, RS</span> (<i><strong>S</strong>et <strong>G</strong>reater <strong>E</strong>qual</i>) per verificare che il contenuto del primo registro sia maggiore o uguale del secondo (confronto tra numeri con segno);              </li><li class="list-item"><span class="code-inline">SGEU RD, RS, RS</span> (<i><strong>S</strong>et <strong>G</strong>reater <strong>E</strong>qual <strong>U</strong>nsigned</i>) per verificare che il contenuto del primo registro sia maggiore o uguale del secondo (confronto tra numeri senza segno);             </li><li class="list-item"><span class="code-inline">SEQ RD, RS, RS</span> (<i><strong>S</strong>et <strong>EQ</strong>ual</i>) per verificare che il contenuto del primo registro sia uguale al secondo (confronto tra numeri con segno);             </li><li class="list-item"><span class="code-inline">SEQU RD, RS, RS</span> (<i><strong>S</strong>et <strong>EQ</strong>ual <strong>U</strong>nsigned</i>) per verificare che il contenuto del primo registro sia uguale al secondo (confronto tra numeri senza segno);             </li><li class="list-item"><span class="code-inline">SNE RD, RS, RS</span> (<i><strong>S</strong>et <strong>N</strong>ot <strong>E</strong>qual</i>) per verificare che il contenuto del primo registro sia diverso dal secondo (confronto tra numeri con segno);                         </li><li class="list-item"><span class="code-inline">SNEU RD, RS, RS</span> (<i><strong>S</strong>et <strong>N</strong>ot <strong>E</strong>qual <strong>U</strong>nsigned</i>) per verificare che il contenuto del primo registro sia diverso dal secondo (confronto tra numeri senza segno);                         </li></ul></li><li class="list-item">le istruzioni di set di tipo <span class="mono">I</span> (ovvero che copiano nel registro <span class="mono">RD</span> se una condizione è rispettata o meno tra il valore del registro <span class="mono">RS</span> e l'immediato esteso con o senza segno), in particolare         <ul class="list-container"><li class="list-item"><span class="code-inline">SLTI RD, RS, Imm16</span> (<i><strong>S</strong>et <strong>L</strong>esser <strong>T</strong>han <strong>I</strong>mmediate</i>) per verificare che il contenuto del primo registro sia minore "stretto" dell'immediato (confronto tra numeri con segno);             </li><li class="list-item"><span class="code-inline">SLTUI RD, RS, Imm16</span> (<i><strong>S</strong>et <strong>L</strong>esser <strong>T</strong>han <strong>U</strong>nsigned <strong>I</strong>mmediate</i>) per verificare che il contenuto del primo registro sia minore "stretto" dell'immediato (confronto tra numeri senza segno);             </li><li class="list-item"><span class="code-inline">SGTI RD, RS, Imm16</span> (<i><strong>S</strong>et <strong>G</strong>reater <strong>T</strong>han <strong>I</strong>mmediate</i>) per verificare che il contenuto del primo registro sia maggiore "stretto" dell'immediato (confronto tra numeri con segno);             </li><li class="list-item"><span class="code-inline">SGTUI RD, RS, Imm16</span> (<i><strong>S</strong>et <strong>G</strong>reater <strong>T</strong>han <strong>U</strong>nsigned <strong>I</strong>mmediate</i>) per verificare che il contenuto del primo registro sia maggiore "stretto" dell'immediato (confronto tra numeri senza segno);             </li><li class="list-item"><span class="code-inline">SLEI RD, RS, Imm16</span> (<i><strong>S</strong>et <strong>L</strong>esser <strong>E</strong>qual <strong>I</strong>mmediate</i>) per verificare che il contenuto del primo registro sia minore o uguale dell'immediato (confronto tra numeri con segno);             </li><li class="list-item"><span class="code-inline">SLEUI RD, RS, Imm16</span> (<i><strong>S</strong>et <strong>L</strong>esser <strong>E</strong>qual <strong>U</strong>nsigned <strong>I</strong>mmediate</i>) per verificare che il contenuto del primo registro sia minore o uguale dell'immediato (confronto tra numeri senza segno);             </li><li class="list-item"><span class="code-inline">SGEI RD, RS, Imm16</span> (<i><strong>S</strong>et <strong>G</strong>reater <strong>E</strong>qual <strong>I</strong>mmediate</i>) per verificare che il contenuto del primo registro sia maggiore o uguale dell'immediato (confronto tra numeri con segno);             </li><li class="list-item"><span class="code-inline">SGEUI RD, RS, Imm16</span> (<i><strong>S</strong>et <strong>G</strong>reater <strong>E</strong>qual <strong>U</strong>nsigned <strong>I</strong>mmediate</i>) per verificare che il contenuto del primo registro sia maggiore o uguale dell'immediato (confronto tra numeri senza segno);             </li><li class="list-item"><span class="code-inline">SEQI RD, RS, Imm16</span> (<i><strong>S</strong>et <strong>EQ</strong>ual <strong>I</strong>mmediate</i>) per verificare che il contenuto del primo registro sia uguale all'immediato (confronto tra numeri con segno);             </li><li class="list-item"><span class="code-inline">SEQUI RD, RS, Imm16</span> (<i><strong>S</strong>et <strong>EQ</strong>ual <strong>U</strong>nsigned <strong>I</strong>mmediate</i>) per verificare che il contenuto del primo registro sia uguale all'immediato (confronto tra numeri senza segno);             </li><li class="list-item"><span class="code-inline">SNEI RD, RS, Imm16</span> (<i><strong>S</strong>et <strong>N</strong>ot <strong>E</strong>qual <strong>I</strong>mmediate</i>) per verificare che il contenuto del primo registro sia diverso dall'immediato (confronto tra numeri con segno);             </li><li class="list-item"><span class="code-inline">SNEUI RD, RS, Imm16</span> (<i><strong>S</strong>et <strong>N</strong>ot <strong>E</strong>qual <strong>U</strong>nsigned <strong>I</strong>mmediate</i>) per verificare che il contenuto del primo registro sia diverso dall'immediato (confronto tra numeri senza segno);                                 </li></ul></li><li class="list-item"><span class="code-inline">BEQZ RS, Imm16</span> (<i><strong>B</strong>ranch if <strong>EQ</strong>ual <strong>Z</strong>ero</i>) per il salto condizionato (se in <span class="mono">RS</span> è presente il valore <span class="mono">0</span>) all'istruzione <span class="mono">PC</span>-relativa sommata all'immediato (ricordando che il Program Counter punta all'indirizzo successivo da eseguire);         </li><li class="list-item"><span class="code-inline">BNEZ RS, Imm16</span> (<i><strong>B</strong>ranch if <strong>N</strong>ot <strong>E</strong>qual <strong>Z</strong>ero</i>) per il salto condizionato (se in <span class="mono">RS</span> non è presente il valore <span class="mono">0</span>) all'istruzione <span class="mono">PC</span>-relativa sommata all'immediato (ricordando che il Program Counter punta all'indirizzo successivo da eseguire);         </li><li class="list-item"><span class="code-inline">J Imm26</span> (<i><strong>J</strong>ump</i>) per il salto incodizionato all'indirizzo <span class="mono">PC</span>-relativo sommato all'immediato;         </li><li class="list-item"><span class="code-inline">JR RS</span> (<i><strong>J</strong>ump <strong>R</strong>egister</i>) per il salto incodizionato all'indirizzo assoluto contenuto nel registro <span class="mono">RS</span>;         </li><li class="list-item"><span class="code-inline">JALR Imm26</span> (<i><strong>J</strong>ump <strong>A</strong>nd <strong>L</strong>ink</i>) per il salto incodizionato con ritorno (ovvero è salvato il valore del Program Counter nel registro <span class="mono">R31</span>) all'indirizzo <span class="mono">PC</span>-relativo sommato all'immediato;         </li><li class="list-item"><span class="code-inline">JALR RS</span> (<i><strong>J</strong>ump <strong>A</strong>nd <strong>L</strong>ink <strong>R</strong>egister</i>) per il salto incodizionato con ritorno (ovvero è salvato il valore del Program Counter nel registro <span class="mono">R31</span>) all'indirizzo assoluto contenuto nel registro <span class="mono">RS</span></li></ul>     Per le istruzioni di salto, è concesso anche l'utilizzo di label (invece del valore numerico), dichiarabili come <span class="code-inline">Label:</span>. </div></div><div class="myexample environment" id="example4"><h2 class="environment-title">Esempio - Codice assembly per la somma degli elementi in un intervallo contiguo di memoria</h2><div class="environment-body collapsed">     Considerando un processore DLX nel cui spazio di indirizzamento è mappata una memoria <span class="mono">A</span> all'indirizzo <span class="mono">0x0800</span> contenente <span class="math-span">\( 8\)</span> numeri unsigned memorizzati come Byte, scrivere il codice al cui termine dell'esecuzione posiziona nel registro <span class="mono">R30</span> il risultato della somma di tutti gli otto numeri presenti in memoria.     <span class="inner-title">Considerazioni</span>     Considerando la richiesta, si ha che la risoluzione di questo problema può ricondursi all'iterazione di un comportamento per <span class="math-span">\( 8\)</span> volte.      Il metodo più efficiente e scalabile è considerare la creazione di un ciclo while. Ragionando in questo modo, saranno necessari:     <ul class="list-container"><li class="list-item">un accumulatore in cui sarà memorizzata la somma;         </li><li class="list-item">un contatore "indice" che "tiene conto" di quanti numeri si sono già sommati (e permette quindi l'accesso al successivo indirizzo di memoria).     </li></ul>     Consideriamo ora anche il fatto che tale memoria è mappata all'indirizzo <span class="mono">0x00000800</span> (un numero i cui ultimi <span class="math-span">\( 16 \mathrm{ \, bit }\)</span> non sono significativi, ovvero che sono significativi solo i primi <span class="math-span">\( 16 \mathrm{ \, bit }\)</span>).      Possiamo quindi considerare di utilizzare come "punto costante" di accesso l'indirizzo rappresentato dall'immediato <span class="mono">0x0800</span> e l'offset di accesso dal contatore.     <span class="inner-title">Il codice</span>     Seguendo queste osservazioni otteniamo il codice:     <pre class="code-block"><code>        ADD R1, R0, R0      ; Accumulatore R1 = 0
        ADD R2, R0, R0      ; Indice R2 = 0
        ADD R3, R0, R0      ; Loop Condition Register R3 = 0
        ADD R4, R0, R0      ; Storage R4 = 0
        ADD R30, R0, R0     ; Risultato R30 = 0

SLOOP:  SLTUI R3, R2, 0x0008    ; R3 = R2 &lt; 8
        BEQZ R3, ELOOP          ; Se R3 = 0 (False), salta a ELOOP
        
        LBU R4, 0x0800(R2)      ; Storage R4 = A[0x0800 + R2]
        ADDU R1, R1, R3         ; Accumulatore R1 = R1 + R4
        ADDU R2, R2, 0x0001     ; Indice R2 = R2 + 1

        J SLOOP                 ; Salto incodizionato a SLOOP
ELOOP:  ADDU R30, R0, R1        ; Risultato R30 = R1</code></pre>     Tale codice ricalca il codice di un linguaggio ad alto livello (come C): tuttavia risulta essere inefficiente dato che:     <ul class="list-container"><li class="list-item">all'inizio si inizializzano inutilmente i registri <span class="mono">R3</span>, <span class="mono">R4</span>, <span class="mono">R30</span>;         </li><li class="list-item">il ciclo while è una struttura generica e non "modellata" perfettamente su questo problema.     </li></ul>     Detto ciò, è possibile considerare un codice decisamente più efficiente (in quanto si ha che ad ogni istruzione di clock superflua, si "spreca" un ciclo di clock):     <pre class="code-block"><code>        ADD R1, R0, R0      ; Accumulatore R1 = 0
        ADDI R2, R0, 0x0008 ; Indice R2 = 8

LOOP:   SUBUI R2, R2, 0x0001    ; R2 = R2 - 1 
        LBU R3, 0x0800(R1)      ; Storage R3 = A[0x0800 + R2]
        ADDU R1, R1, R3         ; R1 = R1 + R3
        
        BNEZ R2, LOOP           ; Se R2 != 0, salta a LOOP

        ADDU R30, R0, R1        ; Risultato R30 = R1</code></pre>     Tale codice risulta essere particolarmente efficiente: non utilizza infatti istruzioni di set per verificare che il ciclo sia finito, ma sfrutta il fatto che una volta terminato, l'indice arrivi naturalmente a <span class="mono">0</span>. </div><div class="environment-tail"><span class="material-symbols-outlined body-visibility-icon" onclick="expand_environment(event)">expand_more</span></div></div>
            </article>
            <nav class="buttons-container content-width">
                <a class="navigation-button previous" href="instruction-set-architecture.html" rel="nofollow"><span>Instruction Set Architecture</span></a>
                
            </nav>
        </section>
        <div class="scroll-to-bottom-button" onclick="scroll_to_bottom()">
            <span class="material-symbols-outlined">
                keyboard_double_arrow_down
            </span>
        </div>
        <footer class="footer-wrapper">
            <div class="copyright-wrapper">
                <span> &copy; Copyright 2023</span> /
                <span>made by lorenzoarlo</span>
            </div>
            /
            <div class="privacy-wrapper">
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/" rel="nofollow">Pannello preferenze cookie</a></span> /
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/privacy-policy.html" rel="nofollow" target="_blank" >Privacy Policy</a></span>
            </div>
        </footer>
    </div>
</body>
</html>