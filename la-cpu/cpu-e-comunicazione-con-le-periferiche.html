<!DOCTYPE html>
<html lang="IT">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="stylesheet" href="../styles/style.css" />
    <link rel="stylesheet" href="../styles/index-style.css" />
    <link rel="stylesheet" href="../styles/content-style.css" />
    <link rel="icon" type="image/x-icon" href="../resources/favicon.ico">
    <link rel="apple-touch-icon" href="../resources/favicon.png" />
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-78NHLXDQD8"></script>
    <script src="../scripts/script.js"></script>
    <style>:root { --bg-clr: #FFD700; --fg-clr: #262626; }</style>
    <meta name="theme-color" content="#FFD700" />
    <meta name="keywords" content="calcolatori elettronici" />
    <meta name="description" content="Il seguente sito contiene gli appunti e le definizioni del corso 'Calcolatori elettronici T'.">
    <meta name="robots" content="index">
    <script defer async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <title>Calcolatori elettronici - La CPU - CPU e comunicazione con le periferiche</title>
</head>
<body>
    <div class="container">
        <header class="header-wrapper">
            <div class="title-wrapper">
                <span class="title">
                    Calcolatori elettronici
                </span>
                <span class="subtitle">
                    by lorenzoarlo
                </span>
            </div>
            <span class="page-title">
                La CPU
            </span>
        </header>
        <section class="content-wrapper">
            <h1 class="section-title content-width">CPU e comunicazione con le periferiche</h1>
            <article class="content-container content-width">
                <div class="definition environment" id="def1-1"><h2 class="environment-title">Definizione - Elaborazione delle informazioni e interazione con l'esterno</h2><div class="environment-body">     Gran parte dei sistemi esistenti ha come obiettivo l'<strong>elaborazione delle informazioni</strong>: anche la quasi totalità dei sistemi elettronici digitali ha questo obiettivo.     <br/>     Come per tutti i sistemi di questo tipo, una funzionalità essenziale per questi sistemi è l'<strong>interazione con l'esterno</strong> per acquisire e/o fornire informazione. </div></div><div class="definition environment" id="def1-2"><h2 class="environment-title">Definizione - Architetture per elaboratori</h2><div class="environment-body">     Esistono diverse architetture di elaborazione in base alle diverse necessità, ad esempio:     <ul class="list-container"><li class="list-item">sistemi <strong>general purpose</strong>;         </li><li class="list-item">sistemi <strong>embedded</strong>;         </li><li class="list-item">ecc.     </li></ul>     I sistemi general purpose sono sicuramente i più diffusi e sono basati generalmente sul <strong>modello di Von Neumann</strong>, che ha come elemento base una CPU. </div></div><div class="definition environment" id="def1-3"><h2 class="environment-title">Definizione - Modello di Von-Neumann</h2><div class="environment-body">     Il <strong>modello di Von-Neumann</strong> descrive un'architettura generale in cui il funzionamento è descritto da una <strong>sequenza di istruzioni</strong> (un programma) memorizzate su un supporto di memoria.     <br/>     Il sistema di elaborazione può essere schematizzato in modo astratto come una <strong>Rete Sequenziale Sincrona</strong> (<i>RSS</i>) a cui è aggiunta un'unità di controllo che dopo aver interrogato (<strong>fetch</strong>) la memoria per le istruzioni del programma, governa la parte combinatoria del microprocessore attraverso appositi <strong>segnali di controllo</strong>.     <br/>     A livello di massima astrazione, il funzionamento dell'intero sistema può essere descritto da <strong>due stati in continua alternanza</strong>:     <ul class="list-container"><li class="list-item">lo stato di <i>Instruction Fetch</i> (<strong>IF</strong>) in cui si "prelevano" le istruzioni da eseguire (indicato da un apposito registro detto <i>Program Counter</i>, <strong>PC</strong>);         </li><li class="list-item">lo stato di <i>Execute</i> (<strong>EX</strong>).     </li></ul></div></div><div class="definition environment" id="def1-4"><h2 class="environment-title">Definizione - CISC e RISC</h2><div class="environment-body">     Le CPU possono eseguire istruzioni come somme, moltiplicazioni, confronti, letture e scritture in memoria e/o verso altri dispositivi, ecc.      <br/>     In base al set di istruzioni codificate, le CPU si dividono in:     <ul class="list-container"><li class="list-item"><strong>RISC</strong> (<i>Reduced Instruction Set Computer</i>), dove le istruzioni sono <strong>poche e semplici</strong>. Tali CPU sono caratterizzate da reti logiche semplici ed <strong>efficienti</strong>;         </li><li class="list-item"><strong>CISC</strong> (<i>Complex Instruction Set Computer</i>), dove le istruzioni sono <strong>molte e complesse</strong>, comportando reti logiche più complesse e più grandi.     </li></ul>     Se inizialmente fu l'architettura CISC ad essere prevalente, in particolare con l'arrivo dei dispositivi mobili, l'architettura RISC è diventata la più utilizzata per questioni di efficienza energetica e spazio occupato.     <br/>     Inoltre, ad oggi, anche le architetture CISC (ancora necessarie per la grande quantità di software preesistente) sono realizzate internamente come RISC. </div></div><div class="definition environment" id="def1-5"><h2 class="environment-title">Definizione - Linguaggi per CPU</h2><div class="environment-body">     Indipendentemente dal tipo della CPU, le istruzioni sono in <strong>forma binaria</strong> rendendole quindi di difficile comprensione.      Per questo motivo si utilizza il <strong>linguaggio assembly</strong> che sarà poi trasformato in binario grazie ad apposite <i>Look Up Table</i> (<strong>LUT</strong>).     I linguaggi di programmazione ad alto livello non sono altro che istruzioni più complesse (di alto livello, appunto) poi convertite in istruzioni più semplici per la CPU (attraverso il compilatore, ad esempio).  </div></div><div class="definition environment" id="def1-6"><h2 class="environment-title">Definizione - Comunicazione nel modello di Von-Neumann</h2><div class="environment-body">     Nel modello di Von-Neumann le istruzioni risiedono in memoria, ma per leggere (e scrivere) la CPU utilizza segnali predefiniti temporizzati da un preciso ciclo di bus.     <br/>     Esistono infatti tre tipi di bus di comunicazione tra CPU, Memoria e le varie periferiche:     <ul class="list-container"><li class="list-item">l'<strong>Address Bus</strong> (<span class="mono">BA[...]</span>) <strong>unidirezionale</strong> (da CPU a memoria e periferiche);         </li><li class="list-item">il <strong>Data Bus</strong> (<span class="mono">BD[...]</span>) <strong>bidirezionale</strong>;         </li><li class="list-item">il <strong>Control Bus</strong> composto dai segnali:         <ul class="list-container"><li class="list-item"><strong>Read</strong> e <strong>Write</strong> (da CPU a memoria e periferiche);             </li><li class="list-item"><strong>Ready</strong> e <strong>Int</strong> (da memoria e periferiche a CPU).         </li></ul></li></ul></div></div><div class="definition environment" id="def1-7"><h2 class="environment-title">Definizione - Ciclo di bus</h2><div class="environment-body">     L'<strong>evoluzione temporale</strong> di alcuni segnali che interagiscono con una CPU si definiscono come <strong>ciclo di bus</strong>.     <br/>     L'unico modo per interagire con un sistema di questo tipo, consiste nel seguire le <strong>regole descritte</strong> da tale ciclo ed indicate dal costruttore nel relativo data sheet.     <br/>     Ad ogni ciclo di bus si ha quindi che nell'Address Bus è presente l'<strong>indirizzo della memoria o della periferica</strong>, nel Data Bus le <strong>informazioni da leggere o da scrivere</strong> e il Control Bus fornisce <strong>informazioni sull'operazione da svolgere o sullo stato della periferiche</strong>.     <br/>     Un ciclo di bus può durare più cicli di clock e può anche terminare in maniera asincrona.      <div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Ad esempio - Ciclo di bus di lettura</h3><div class="environment-body">         Consideriamo un prototipo di ciclo di bus di lettura         <div class="image-environment"><div class="image-wrapper spaced-90"><img alt="Immagine" src="../resources/generated-0.png"/></div></div>         Si ha quindi che la CPU emette l'indirizzo sull'Address Bus e negli istanti successivi la sua intenzione di lettura (segnale <span class="mono">Read</span>).          A questo punto, la CPU aspetta il segnale di <span class="mono">Ready</span> per poter "ritirare" il dato immesso dalla periferica (sul Data Bus).     </div></div><div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Ad esempio - Ciclo di bus di scrittura</h3><div class="environment-body">         Consideriamo un prototipo di ciclo di bus di scrittura         <div class="image-environment"><div class="image-wrapper spaced-90"><img alt="Immagine" src="../resources/generated-1.png"/></div></div>         Si ha quindi che la CPU emette l'indirizzo sull'Address Bus e negli istanti successivi la sua intenzione di scrittura (segnale <span class="mono">Write</span>).          A questo punto, la CPU aspetta il segnale di <span class="mono">Ready</span> per poter "inserire" il dato nella periferica (già caricato in precedenza sul Data Bus).     </div></div></div></div><div class="definition environment" id="def1-8"><h2 class="environment-title">Definizione - Indirizzamento e spazio di indirizzamento</h2><div class="environment-body">     La CPU "emette" sull'Address Bus diversi indirizzi: in particolare si ha che se il bus è composto da <span class="math-span">\( 20\)</span> bit, lo spazio di indirizzamento sarà composto da <span class="math-span">\( 2^{20}\)</span> indirizzi.      Ipotizzando inoltre la grandezza del Data Bus di <span class="math-span">\( 1 \mathrm{ \, Byte }\)</span> (scelta anacronistica ma conveniente per i ragionamenti), si avrà (nel caso dei <span class="math-span">\( 20\)</span> bit di indirizzo) uno spazio di indirizzamento di <span class="math-span">\( 1 \mathrm{ \, MB }\)</span>.     <br/>     Dato tale spazio, affinchè un dispositivo fisico (ad esempio una memoria) possa essere accessibile, deve essere <strong>mappato nello spazio di indirizzamento</strong>, ovvero deve essergli assegnata una finestra di indirizzi.     <div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Ad esempio</h3><div class="environment-body">         Considerando di avere una memoria da <span class="math-span">\( 64 \mathrm{ \, MB }\)</span> (<span class="math-span">\( 2^6 \cdot 2^{20} \mathrm{ \, Byte }\)</span>, ovvero <span class="math-span">\( 2^36 \mathrm{ \, Byte }\)</span>) ed un Address Bus di <span class="math-span">\( 1 \mathrm{ \, Byte }\)</span>, per poter indirizzare tale memoria saranno necessari almeno <span class="math-span">\( 2^36\)</span> indirizzi (ad ogni "dato" un indirizzo).     </div></div></div></div><div class="definition environment" id="def1-9"><h2 class="environment-title">Definizione - Driver 3-state</h2><div class="environment-body">     Il <strong>driver 3-state</strong> è una rete logica     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/driver3state-disabled.png"/></div></div>     che è caratterizzata da:     <ul class="list-container"><li class="list-item">un ingresso <span class="mono">I</span>;         </li><li class="list-item">un ingresso <span class="mono">OE</span> (<i>Output Enable</i>);         </li><li class="list-item">un'uscita <span class="mono">U</span></li></ul>     Tale driver (un componente che non altera il segnale logico) permette l'introduzione di un "terzo stato", detto di "<strong>alta impedenza</strong>", che ha un effetto logico paragonabile "all'interruzione del cavo": a livello fisico, la tensione non assume un valore preciso ma rende il segnale in uscita "neutrale" rispetto al valore fornito da un altro componente.     <br/>     Esso è quindi descritto dalla seguente tabella della verità:     <div class="image-environment"><div class="image-wrapper spaced-20"><img alt="Immagine" src="../resources/generated-2.png"/></div></div>     dove <span class="mono">Z</span> indica lo stato di alta impedenza.     <br/>     Si ha quindi che con l'ingresso <span class="mono">OE = 1</span>, ovvero     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/driver3state-enabled.png"/></div></div>     tale componente diventa "trasparente", altrimenti "blocca" il segnale </div></div><div class="definition environment" id="def1-10"><h2 class="environment-title">Definizione - Decoder di I e II livello</h2><div class="environment-body">     La CPU per poter scrivere e leggere dei dati, emette l'indirizzo della cella di memoria interessata: a questo punto tale indirizzo viene fornito in input ad un decoder di I livello che in base al valore dei bit più significativi di tale indirizzo, abiliterà o disabiliterà (grazie ad un driver 3-state) un apposito ingresso del dispositivo (detto "Chip Select" o "Chip Enable", CS o CE).     <br/>     A questo punto, l'indirizzo è ulteriormente decodificato da un decoder di II livello (interno al dispositivo) che "collegherà" la parte corretta della memoria. </div></div><div class="definition environment" id="def1-11"><h2 class="environment-title">Definizione - Struttura di una generico dispositivo collegato alla CPU</h2><div class="environment-body">     Considerando un sistema caratterizzato da <span class="math-span">\( n\)</span> bit di dati, un generico dispositivo compatibile sarà caratterizzato da:     <ul class="list-container"><li class="list-item">un segnale di <span class="mono">Chip Select</span> (<strong>CS</strong>) del dispositivo;         </li><li class="list-item">un bus di <span class="math-span">\( k\)</span> bit utili per la decodifica di II livello;         </li><li class="list-item">un segnale di controllo per indicare la lettura ed uno per indicare la scrittura;         </li><li class="list-item">un bus di <span class="math-span">\( n\)</span> bit di dati.     </li></ul></div></div><div class="definition environment" id="def1-12"><h2 class="environment-title">Definizione - Memorie EPROM</h2><div class="environment-body">     Le memorie <strong>EPROM</strong> (<i>Erasable Programmable Read Only Memory</i>), sono memorie non volatili a sola lettura (durante l'utilizzo).     <br/>     Esse sono caratterizzate dai segnali:     <ul class="list-container"><li class="list-item"><span class="mono">CE</span> (<i>Chip Enable</i>), per abilitare o meno il dispositivo;         </li><li class="list-item"><span class="mono">OE</span> (<i>Output Enable</i>), per connettere "l'output" del dispositivo con il Bus Dati (sarà quindi attivo nel caso della lettura).     </li></ul>     Tali segnali devono variare seguendo i vari tempi indicati nel data-sheet.     <br/>     Per motivi storici, tali memorie hanno solitamente capacità il cui valore è multiplo di <span class="math-span">\( 2\)</span> (ad esempio <span class="math-span">\( 32\mathrm{ \, KB }\)</span>, <span class="math-span">\( 64\mathrm{ \, KB }\)</span>, <span class="math-span">\( 128\mathrm{ \, KB }\)</span>, eccetera). </div></div><div class="definition environment" id="def1-13"><h2 class="environment-title">Definizione - Memorie SRAM</h2><div class="environment-body">     Le memorie <strong>SRAM</strong> (<i>Static Random Access Memory</i>), sono memorie volatili leggibili e scrivibili.      Si differenziano dalle <strong>DRAM</strong> (<i>Dynamic RAM</i>) per la tecnologia impiegata (le DRAM utilizzano condensatori in modo da essere meno energivore).     <br/>     Esse sono caratterizzate dai segnali:     <ul class="list-container"><li class="list-item"><span class="mono">CE</span> (<i>Chip Enable</i>), per abilitare o meno il dispositivo;         </li><li class="list-item"><span class="mono">OE</span> (<i>Output Enable</i>), per connettere "l'output" del dispositivo con il Bus Dati (attivo quindi nel caso della lettura);         </li><li class="list-item"><span class="mono">WE</span> (<i>Write Enable</i>), per connettere "l'input" del dispositivo con il Bus Dati (attivo quindi nel caso della scrittura).     </li></ul>     Tali segnali devono variare seguendo i vari tempi indicati nel data-sheet.     <br/>     Per motivi storici, tali memorie hanno solitamente capacità distanti un multiplo di <span class="math-span">\( 4\)</span> (ad esempio <span class="math-span">\( 8\mathrm{ \, KB }\)</span>, <span class="math-span">\( 32\mathrm{ \, KB }\)</span>, <span class="math-span">\( 128\mathrm{ \, KB }\)</span>).     <br/>     A livello strutturale, una singolo bit di una SRAM (la <span class="math-span">\( j\)</span>-esima cella composta da <span class="math-span">\( k\)</span> bit) è così composto     <div class="image-environment"><div class="image-wrapper spaced-80"><img alt="Immagine" src="../resources/cella-sram.png"/></div></div>     in particolare si ha che     <ul class="list-container"><li class="list-item">il segnale <span class="mono">DECODER II LIVELLO</span> sarà fornito dal decoder in base all'indirizzo e abiliterà le <span class="math-span">\( k\)</span> celle (dato che ad ogni indirizzo è composto da <span class="math-span">\( k\)</span> celle) del <span class="math-span">\( j\)</span>-esimo indirizzo.         </li><li class="list-item">il segnale <span class="mono">OE</span> rende (nel caso la cella sia all'indirizzo desiderato) il driver 3-state trasparente permettendo quindi l'inserimento sul Data Bus;         </li><li class="list-item">il segnale <span class="mono">WE</span> rende (nel caso la cella sia all'indirizzo desiderato) il driver 3-state bloccante e collega il dato presente sul Data Bus all'ingresso <span class="mono">D</span> del Latch (che sovrascriverà il dato presente in precedenza).     </li></ul></div></div><div class="definition environment" id="def1-14"><h2 class="environment-title">Definizione - Integrato notevole 244 - Driver 3-state a <span class="math-span">\( 8\)</span> bit</h2><div class="environment-body">     L'integrato notevole 244 è l'equivalente di <span class="math-span">\( 8\)</span> driver 3-state paralleli ma, a differenza dei singoli componenti, sono presenti solo due ingressi di <span class="mono">OE</span> che "piloteranno" <span class="math-span">\( 4\)</span> bit ciascuno.     <br/>     Tale integrato sarà quindi composto, oltre che dai due ingressi di <span class="mono">ENABLE</span>, da <span class="math-span">\( 8\)</span> ingressi e <span class="math-span">\( 8\)</span> uscite. </div></div><div class="definition environment" id="def1-15"><h2 class="environment-title">Definizione - Integrato notevole 245 - Driver 3-state bidirezionale a <span class="math-span">\( 8\)</span> bit</h2><div class="environment-body">     L'integrato notevole 245 è un driver 3-state bidirezionale composto da <span class="math-span">\( 8\)</span> "celle" del tipo     <div class="image-environment"><div class="image-wrapper spaced-60"><img alt="Immagine" src="../resources/integrato-245.png"/></div></div>     In base al valore dell'ingresso <span class="mono">DIR</span>, si avrà che un certo ingresso/uscita sarà attivo mentre l'altro sarà bloccato (quindi sarà possibile la comunicazione da <span class="mono">A</span> a <span class="mono">B</span> e da <span class="mono">B</span> ad <span class="mono">A</span>).     <br/>     Il segnale di <span class="mono">EN</span> si presenta solitamente negato (<span class="mono">EN'</span>) e permette di creare l'impedenza in entrambi i sensi. </div></div><div class="definition environment" id="def1-16"><h2 class="environment-title">Definizione - Integrato notevole 373 - Latch a <span class="math-span">\( 8\)</span> bit con uscita 3-state</h2><div class="environment-body">     L'integrato notevole 373 è l'equivalente di <span class="math-span">\( 8\)</span> Latch CD sulla cui uscita è posto un driver 3-state.      <br/>     Tale integrato sarà quindi composto, oltre che dagli <span class="math-span">\( 8\)</span> ingressi di dato e le <span class="math-span">\( 8\)</span> uscite anche da un ingresso <span class="mono">C</span> (condiviso) e un segnale per abilitare l'uscita (condiviso) solitamente negato (<span class="mono">OE'</span>). </div></div><div class="definition environment" id="def1-17"><h2 class="environment-title">Definizione - Registro edge-triggered a <span class="math-span">\( k\)</span> bit</h2><div class="environment-body">     Un registro a <span class="math-span">\( k\)</span> bit è una rete sequenziale sincrona in grado di memorizzare un dato di <span class="math-span">\( k\)</span> bit.     <div class="image-environment"><div class="image-wrapper spaced-60"><img alt="Immagine" src="../resources/register.png"/></div></div>     Esso è caratterizzato da:     <ul class="list-container"><li class="list-item">un ingresso <span class="mono">CLK</span> per il segnale di clock;         </li><li class="list-item">un bus di <span class="math-span">\( k\)</span> segnali sincroni in ingresso <span class="mono">IN[<span class="math-span">\( k-1, \ldots, 0\)</span>]</span>;         </li><li class="list-item">un ingresso sincrono <span class="mono">WE</span> ("<i>Write Enable</i>") per permettere la <strong>sovrascrittura</strong> del dato precedentemente memorizzato (con <span class="mono">WE = 0</span> ad ogni fronte di clock rimane il segnale memorizzato in precedenza);         </li><li class="list-item">un segnale asincrono <span class="mono">A_RESET</span> ("<i>Asynchronous RESET</i>") che, se attivo, pone a <span class="math-span">\( 0\)</span> tutti i bit memorizzati.     </li></ul>     Per realizzare un registro ad <span class="math-span">\( 1\)</span> bit (da cui poi è facile ottenere un registro a <span class="math-span">\( k\)</span> bit) è possibile ragionare nel seguente modo:     <ul class="list-container"><li class="list-item">se <span class="mono">WE = 1</span>, il flip-flop deve memorizzare l'ingresso <span class="mono">IN</span>;         </li><li class="list-item">se <span class="mono">WE = 0</span>, il flip-flop deve memorizzare il valore precedente, ovvero <span class="mono">Q</span>.     </li></ul>     Dato che è una scelta, un metodo utile per realizzarlo è utilizzare un multiplexer, ovvero     <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/circuito-register.png"/></div></div></div></div><div class="definition environment" id="def1-18"><h2 class="environment-title">Definizione - Integrato notevole 374 - Registro edge-triggered a <span class="math-span">\( 8\)</span> bit con uscita 3-state</h2><div class="environment-body">     L'integrato notevole 374 è l'equivalente di un registro edge-triggered a <span class="math-span">\( 8\)</span> bit sulla cui uscita è posto un driver 3-state.      <br/>     Tale integrato sarà quindi composto, oltre che dagli <span class="math-span">\( 8\)</span> ingressi di dato e le <span class="math-span">\( 8\)</span> uscite anche dal segnale di clock <span class="mono">CK</span> anche da un ingresso per abilitare l'uscita solitamente negato (<span class="mono">OE'</span>). </div></div><div class="definition environment" id="def1-19"><h2 class="environment-title">Definizione - Mappatura di dispositivi</h2><div class="environment-body">     Affinchè la CPU possa comunicare con un dispositivo, è necessario che esso sia mappato nello spazio di indirizzamento. Si ha inoltre che tali finestre di indirizzi da assegnare devono essere contigue.     <br/>     Si consideri un sistema ad <span class="math-span">\( n\)</span> bit ed un dispositivo con <span class="math-span">\( k\)</span> bit di indirizzo interno (ovvero che "andranno in pasto" al decoder di II livello).      In totale, tali dispositivi occuperanno <span class="mono">M = <span class="math-span">\( 2^k\)</span></span> indirizzi nello spazio di indirizzamento.     Un dispositivo si dice mappato ad un certo indirizzo <span class="mono">A</span> se gli indirizzi del dispositivo sono compresi tra <span class="mono">A</span> e <span class="mono">A + (M - 1)</span>.     <br/>     Si dice inoltre che un certo indirizzo è allineato se <span class="mono">A</span> è multiplo di <span class="mono">M</span>, ovvero se     <div class="center"><span class="mono">M modulo A = 0</span></div>     In questo caso, se un dispositivo è allineato, il primo indirizzo a lui corrispondente (<span class="math-span">\( A\)</span>) avrà i <span class="math-span">\( k\)</span> bit meno significativi (degli <span class="math-span">\( n\)</span> totali) a <span class="math-span">\( 0\)</span>.     <br/>     È possibile quindi dividere un generico indirizzo <span class="math-span">\( X\)</span> per il dispositivo in due parti     <span class="math-block">\[         X = \alpha \mid \beta       \]</span>     La parte <span class="math-span">\( \beta\)</span> è composta dai <span class="math-span">\( k\)</span> bit del dispositivo, mentre la parte <span class="math-span">\( \alpha\)</span> è composta dagli <span class="math-span">\( n - k\)</span> bit.      <br/>     In questo modo si avrà quindi che la decodifica della parte <span class="math-span">\( \alpha\)</span> è quella detta di I livello (a carico del progettista del sistema) mentre quella della parte <span class="math-span">\( \beta\)</span> è a carico del dispositivo.     <br/>     Una decodifica si dice completa se nella decodifica si utilizzano tutti i <span class="math-span">\( n - k\)</span> bit di <span class="math-span">\( \alpha\)</span>. Se non è questo il caso, si dice che la decodifica è semplificata. </div></div><div class="myexample environment" id="example1"><h2 class="environment-title">Esempio - Mappatura di dispositivi</h2><div class="environment-body">     Considerando un sistema con un Address Bus di <span class="math-span">\( 16 \mathrm{ \, bit }\)</span> e un Data Bus di <span class="math-span">\( 8 \mathrm{ \, bit }\)</span>, scrivere le espressioni di decodifica di I livello completa e semplificata nei casi:     <ul class="list-container"><li class="list-item">è presente un solo dispositivo di memoria da <span class="math-span">\( 16 \mathrm{ \, KB }\)</span> mappato all'indirizzo esadecimale <span class="mono">8000h</span>;         </li><li class="list-item">è presente un solo dispositivo di memoria da <span class="math-span">\( 8 \mathrm{ \, KB }\)</span> mappato all'indirizzo esadecimale <span class="mono">0000h</span>;         </li><li class="list-item">sono presenti un dispositivo di memoria <span class="mono">A</span> da <span class="math-span">\( 16 \mathrm{ \, KB }\)</span> mappato all'indirizzo esadecimale <span class="mono">8000h</span> e un dispositivo di memoria <span class="mono">B</span> da <span class="math-span">\( 8 \mathrm{ \, KB }\)</span> mappato all'indirizzo esadecimale <span class="mono">0000h</span>.     </li></ul>     Consideriamo il primo caso, ovvero il dispositivo di memoria da <span class="math-span">\( 16 \mathrm{ \, KB }\)</span> mappato all'indirizzo esadecimale <span class="mono">8000h</span>.      In questo caso, si ha che tale dispositivo necessita di <span class="math-span">\( 2^4 \cdot 2^{10} = 2^{14}\)</span> indirizzi.      Si ha quindi che la decodifica di I livello potrà coinvolgere solo i <span class="math-span">\( 16 - 14 = 2\)</span> bit di indirizzo più significativi.     Considerando inoltre il primo indirizzo <span class="mono">8000h</span> si avrà che     <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/generated-3.png"/></div></div>     È necessario quindi scrivere le espressioni corrispondenti ad <span class="math-span">\( \alpha\)</span>. La decodifica completa si ha che deve utilizzare entrambi i bit di <span class="math-span">\( \alpha\)</span>: in questo caso si avrà che l'espressione completa per il chip select è data da     <div class="center"><span class="mono">CS<sub>COMPLETA</sub> = BA[15] <span class="math-span">\( \cdot\)</span> BA[14]'</span></div>     mentre quella semplice (minima) è     <div class="center"><span class="mono">CS<sub>SEMPLICE</sub> = 1</span></div>     in quanto è presente un solo dispositivo (si ha quindi che corrisponde a tutto lo spazio di indirizzamento).     <br/>     Consideriamo ora il secondo caso, ovvero il dispositivo di memoria da <span class="math-span">\( 8\mathrm{ \, KB }\)</span> mappato all'indirizzo esadecimale <span class="mono">0000h</span>.      In questo caso, si ha che tale dispositivo necessita di <span class="math-span">\( 2^3 \cdot 2^{10} = 2^{13}\)</span> indirizzi e si ha che la decodifica di I livello potrà coinvolgere solo i <span class="math-span">\( 16 - 13 = 3\)</span> bit di indirizzo più significativi.      Considerando quindi il primo indirizzo <span class="mono">0000h</span> si ha che     <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/generated-4.png"/></div></div>     Le espressioni corrispondenti ad <span class="math-span">\( \alpha\)</span> saranno quindi     <div class="center"><span class="mono">CS<sub>COMPLETA</sub> = BA[15]' <span class="math-span">\( \cdot\)</span> BA[14]' <span class="math-span">\( \cdot\)</span> BA[13]'</span></div>     e     <div class="center"><span class="mono">CS<sub>SEMPLICE</sub> = 1</span></div>     per gli stessi motivi del caso precedente.     <br/>     Considerando invece l'ultimo caso, in cui i dispositivi devono convivere, si ha che le espressioni di decofica completa saranno identiche ai casi precedenti, ovvero     <div class="center"><span class="mono">CS_A<sub>COMPLETA</sub> = BA[15] <span class="math-span">\( \cdot\)</span> BA[14]'</span><br/><span class="mono">CS_B<sub>COMPLETA</sub> = BA[15]' <span class="math-span">\( \cdot\)</span> BA[14]' <span class="math-span">\( \cdot\)</span> BA[13]'</span></div>     mentre per la decodifica semplice si ha che è possibile considerare le differenze nei bit più significativi, ovvero si ha che     <div class="center"><span class="mono">CS_A<sub>SEMPLICE</sub> = BA[15]</span><br/><span class="mono">CS_B<sub>SEMPLICE</sub> = BA[15]'</span></div></div></div><div class="myexample environment" id="example2"><h2 class="environment-title">Esempio - Comandare un Flip-Flop D con una CPU</h2><div class="environment-body">     Considerando un sistema con un Address Bus di <span class="math-span">\( 20 \mathrm{ \, bit }\)</span> e un Data Bus di <span class="math-span">\( 8 \mathrm{ \, bit }\)</span> con:     <ul class="list-container"><li class="list-item"><span class="math-span">\( 64 \mathrm{ \, KB }\)</span> di memoria EPROM posizionati negli "indirizzi bassi";          </li><li class="list-item"><span class="math-span">\( 64 \mathrm{ \, KB }\)</span> di memoria RAM posizionati negli "indirizzi alti".     </li></ul>     Si vuole comunicare con un Flip Flop D      <div class="image-environment"><div class="image-wrapper spaced-30"><img alt="Immagine" src="../resources/flip-flop-d-set-reset.png"/></div></div>     e impartigli i comandi di:     <ul class="list-container"><li class="list-item">scrittura nel Flip-flop;         </li><li class="list-item">lettura nel Flip-flop;         </li><li class="list-item">set asincrono del Flip-flop;         </li><li class="list-item">reset asincrono del Flip-flop.     </li></ul><span class="inner-title">Mappatura</span>     Per risolvere questo problema, consideriamo innanzitutto la mappatura dei dispositivi.      <br/>     La EPROM necessita di <span class="math-span">\( 2^6 \cdot 2^{10} = 2^{16}\)</span> indirizzi e sappiamo inoltre che è posizionata negli indirizzi bassi (ovvero a partire da <span class="mono">00000h</span>).     Considerando ciò, si ha che la EPROM occuperà l'intervallo di indirizzi     <div class="center"><span class="mono">EPROM = [ 00000h, 00000h + 2<sup>16</sup> ] = [ 00000h, 00000h + 0FFFFh ] = [00000h, 0FFFFh]</span></div>     Per quanto riguarda la RAM, si ha che non sono disponibili memorie RAM di <span class="math-span">\( 64\mathrm{ \, KB }\)</span>.     Per risolvere ciò è tuttavia possibile considerare di utilizzare due memorie da <span class="math-span">\( 32 \mathrm{ \, KB }\)</span> l'una.     Per trovare il primo loro indirizzo, è possibile considerare che il loro ultimo indirizzo è <span class="mono">FFFFFh</span> e occupano <span class="math-span">\( 2^{15} \mathrm{ \, KB }\)</span> l'una.      Si avrà quindi che la prima RAM (quella più "in alto") occuperà gli indirizzi     <div class="center"><span class="mono">RAM_1 = [FFFFFh - 2<sup>15</sup>, FFFFFh] = [FFFFFh - 0EFFFh, FFFFFh] = [F8000h, FFFFFh]</span></div>     mentre la seconda (quella più "in basso") avrà come indirizzo superiore il primo disponibile al di sotto della <span class="math-span">\( RAM_1\)</span>, ovvero <span class="math-span">\( F8000h - 00001h = F7FFFh\)</span>, da cui     <div class="center"><span class="mono">RAM_2 = [F7FFFh - 2<sup>15</sup>, F7FFFh] = [F7FFFh - 0EFFFh, F7FFFh] = [F0000h, F7FFFh]</span></div>     Sono ora necessari quattro indirizzi per i quattro comandi che si vogliono impartire al Flip-Flop. È possibile scegliere degli indirizzi tra tutti quelli non utilizzati.     Scegliamo arbitrariamente i seguenti indirizzi:     <ul class="list-container"><li class="list-item">il comando di lettura sincrona all'indirizzo <span class="mono">80000h</span>;         </li><li class="list-item">il comando di scrittura sincrona all'indirizzo <span class="mono">80001h</span>;         </li><li class="list-item">il comando di reset asincrono all'indirizzo <span class="mono">80002h</span>;         </li><li class="list-item">il comando di set asincrono all'indirizzo <span class="mono">80003h</span>.     </li></ul>     Possiamo ora calcolare le espressioni di decodifica (utilizzando una decodifica semplice) di ogni dispositivo.      <br/>     In particolare consideriamo di avere un solo dispositivo nella prima metà dello spazio d'indirizzamento (la EPROM), per cui è possibile assegnargli l'intera metà, ovvero     <div class="center"><span class="mono">CS_EPROM = BA[19]'</span></div>     Considerando invece la seconda metà in cui convivono i vari comandi e le due RAM:     <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/generated-5.png"/></div></div>     Si ha quindi che:     <ul class="list-container"><li class="list-item">il bit <span class="mono">BA[19]</span> (evidenziato in rosso) è necessario per identificare la seconda metà dello spazio di indirizzamento;         </li><li class="list-item">il bit <span class="mono">BA[18]</span> (evidenziato in arancione) è necessario per distinguere tra i dispositivi RAM (<span class="mono">BA[18]</span>) e i comandi (<span class="mono">BA[18]'</span>);         </li><li class="list-item">il bit <span class="mono">BA[15]</span> (evidenziato in blu) è necessario per distinguere tra le due RAM (<span class="mono">BA[15]</span> per <span class="mono">RAM_1</span>, <span class="mono">BA[15]'</span> per <span class="mono">RAM_2</span>);         </li><li class="list-item">i bit <span class="mono">BA[1]</span> e <span class="mono">BA[0]</span> (evidenziati in verde) sono necessari per distinguere i vari comandi.     </li></ul>     Si avrà quindi che i chip select saranno uguali a:     <ul class="list-container"><li class="list-item">il chip select della <span class="mono">RAM_1</span> sarà         <div class="center"><span class="mono">CS_RAM_1 = BA[19] <span class="math-span">\( \cdot\)</span> BA[18] <span class="math-span">\( \cdot\)</span> BA[15]</span></div></li><li class="list-item">il chip select della <span class="mono">RAM_2</span> sarà         <div class="center"><span class="mono">CS_RAM_2 = BA[19] <span class="math-span">\( \cdot\)</span> BA[18] <span class="math-span">\( \cdot\)</span> BA[15]'</span></div></li><li class="list-item">il chip select del comando di lettura sincrono sarà         <div class="center"><span class="mono">CS_READ = BA[19] <span class="math-span">\( \cdot\)</span> BA[18]' <span class="math-span">\( \cdot\)</span> BA[1]' <span class="math-span">\( \cdot\)</span> BA[0]' <span class="math-span">\( \cdot\)</span> MEMREAD</span></div>         Oltre all'espressione di decodifica è presente anche il comando di <span class="mono">MEMREAD</span> per evitare malfunzionamenti durante i transitori;         </li><li class="list-item">il chip select del comando di scrittura sincrono sarà         <div class="center"><span class="mono">CS_READ = BA[19] <span class="math-span">\( \cdot\)</span> BA[18]' <span class="math-span">\( \cdot\)</span> BA[1]' <span class="math-span">\( \cdot\)</span> BA[0]</span></div></li><li class="list-item">il chip select del comando di reset asincrono sarà         <div class="center"><span class="mono">CS_RESET_ASYNC = BA[19] <span class="math-span">\( \cdot\)</span> BA[18]' <span class="math-span">\( \cdot\)</span> BA[1] <span class="math-span">\( \cdot\)</span> BA[0]' <span class="math-span">\( \cdot\)</span> MEMWRITE</span></div>         Oltre all'espressione di decodifica è presente anche il comando di <span class="mono">MEMWRITE</span> per evitare malfunzionamenti durante i transitori;         </li><li class="list-item">il chip select del comando di set asincrono sarà         <div class="center"><span class="mono">CS_SET_ASYNC = BA[19] <span class="math-span">\( \cdot\)</span> BA[18]' <span class="math-span">\( \cdot\)</span> BA[1] <span class="math-span">\( \cdot\)</span> BA[0] <span class="math-span">\( \cdot\)</span> MEMWRITE</span></div>         Oltre all'espressione di decodifica è presente anche il comando di <span class="mono">MEMWRITE</span> per evitare malfunzionamenti durante i transitori.     </li></ul><span class="inner-title">Progetto</span>     Dati questi segnali, si avrà quindi la seguente rete     <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/ffd-exercise.png"/></div></div>     Con questa rete è possibile comandare un flip-flop tramite i cicli di bus.      In particolare si ha che al clock del flip-flop è collegato il negato di <span class="mono">MEMWRITE</span> in quanto si vuole che il segnale sia campionato sul fronte di discesa di <span class="mono">MEMWRITE</span> (in quanto è solo in quel momento che si è sicuri che i dati siano presenti sul Bus Dati).      Altra particolarità è la presenza di un multiplexer. Ciò è causato dal segnale <span class="mono">MEMWRITE</span> sul clock: se il multiplexer non ci fosse, il dato sul Bus Dati sarebbe campionato ogni volta che la CPU vuole scrivere su una memoria qualsiasi. </div></div><div class="definition environment" id="def1-20"><h2 class="environment-title">Definizione - Incrementare il parallelismo dei dati</h2><div class="environment-body">     Considerando le specifiche prese ora, si ha che ad ogni ciclo di bus è possibile ottenere <span class="math-span">\( 1 \mathrm{ \, byte }\)</span> di informazione.      Con l'evolversi della tecnologia, le CPU sono caratterizzate da frequenze di clock sempre maggiori mentre le memorie risultano avere tempi di accesso lenti (rispetto al clock) creando un vero e proprio "collo di bottiglia".     È evidente che ciò rappresenta un rallentamento importante per buona parte degli applicativi attuali.      <br/>     Un'idea potrebbe essere aumentare la grandezza del Data Bus, in modo trasferire ad ogni ciclo di bus più dati.      Se è possibile fare ciò per quanto riguarda la CPU, ciò non è possibile per quanto riguarda il Bus Dati delle memorie (che sono vincolate ad un Bus Dati a <span class="math-span">\( 8 \mathrm{ \, bit }\)</span>).     <br/>     Dato il vincolo, un'idea può essere utilizzare per la stessa capacità più memorie (di porta dati a <span class="math-span">\( 8 \mathrm{ \, bit }\)</span> e di capacità minore) per ottenere ad ogni ciclo di bus più dati (da ogni memoria <span class="math-span">\( 1 \mathrm{ \, byte }\)</span>).     <br/>     Si avranno quindi una memoria logica (considerata come un unico blocco contiguo) e una memoria fisica (organizzata in blocchi separati).     Aumentando il numero di memorie, ognuna di esse avrà indirizzamento interno ridotto: ciò implica che sono necessari meno bit per indirizzare ognuna delle memorie più piccole (ricordando che ad ogni ciclo di bus il nostro sistema, con bus dati aumentato, può potenzialmente "prelevare/inserire" <span class="math-span">\( 1 \mathrm{ \, Byte }\)</span> da ciascuna memoria).     Consideriamo tuttavia che può essere di nostro interesse anche "prelevare/inserire" meno dati della capacità totale del nostro Bus: è necessario quindi introdurre ulteriori bit di "indirizzamento" (detti di Bus Enable, BE) che decidono con quali delle memorie più piccole comunicare.     <div class="mynote environment"><h3 class="environment-title">Osservazioni personali - In pratica - Parallelismo dei dati a <span class="math-span">\( 16 \mathrm{ \, bit }\)</span></h3><div class="environment-body">         Consideriamo il caso del parallismo dati a <span class="math-span">\( 16 \mathrm{ \, bit }\)</span>.          Per sfruttare ciò con una memoria di <span class="math-span">\( 2^N\)</span> informazioni (vincolata ad un Bus Dati a <span class="math-span">\( 8 \mathrm{ \, bit }\)</span>) è possibile utilizzare due memorie da <span class="math-span">\( 2^{N - 1}\)</span> informazioni (collegate rispettivamente da un Bus Alto e un Bus Basso)         <div class="image-environment"><div class="image-wrapper spaced-90"><img alt="Immagine" src="../resources/generated-6.png"/></div></div>         Considerando questa situazione, sarebbero necessari <span class="math-span">\( N \mathrm{ \, bit }\)</span> di indirizzamento per mappare (in questo caso, <span class="math-span">\( N = 3\)</span>) tutta la memoria logica, mentre per indirizzare le due memorie più piccole sono sufficienti solo <span class="math-span">\( N - 1 \mathrm{ \, bit }\)</span> (in questo caso <span class="math-span">\( N - 1 = 2\)</span>)         <div class="image-environment"><div class="image-wrapper spaced-90"><img alt="Immagine" src="../resources/generated-7.png"/></div></div>         A cui è tuttavia necessario aggiungere altri due segnali di Bus Enable per manifestare la volontà di:         <ul class="list-container"><li class="list-item">selezionare solo il Byte del bus alto;             </li><li class="list-item">selezionare solo il Byte del bus basso;             </li><li class="list-item">selezionare entrambi i Byte (una word);             </li><li class="list-item">non ottenere nessun Byte (anche se sarebbe un caso controintuitivo).         </li></ul>         Per mantenere tuttavia la contiguità degli indirizzi nell'accesso (ovvero per accedere ad indirizzi contigui nello stesso ciclo di bus) è necessario che i due indirizzi contigui siano su memorie distinte, ovvero         <div class="image-environment"><div class="image-wrapper spaced-90"><img alt="Immagine" src="../resources/generated-8.png"/></div></div>         In questo caso si ha che in un banco di memoria saranno presenti tutti gli indirizzi pari (in questo caso sul Bus Basso) e sull'altro tutti gli indirizzi dispari (sul Bus Alto).          <br/>         In questo caso (in cui il parallelismo dei dati è raddoppiato) si ha che l'indirizzo fisico di ogni banco sarà dato dall'indirizzo logico diviso per <span class="math-span">\( 2\)</span>, che equivale ad uno shift logico a sinistra (o equivalente a considerare i due bit meno significativi dell'indirizzo logico).     </div></div></div></div>
            </article>
            <nav class="buttons-container content-width">
                <a class="navigation-button previous" href="index.html" rel="nofollow"><span>La CPU</span></a>
                
            </nav>
        </section>
        <div class="scroll-to-bottom-button" onclick="scroll_to_bottom()">
            <span class="material-symbols-outlined">
                keyboard_double_arrow_down
            </span>
        </div>
        <footer class="footer-wrapper">
            <div class="copyright-wrapper">
                <span> &copy; Copyright 2023</span> /
                <span>made by lorenzoarlo</span>
            </div>
            /
            <div class="privacy-wrapper">
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/" rel="nofollow">Pannello preferenze cookie</a></span> /
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/privacy-policy.html" rel="nofollow" target="_blank" >Privacy Policy</a></span>
            </div>
        </footer>
    </div>
</body>
</html>