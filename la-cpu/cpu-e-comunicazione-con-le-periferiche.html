<!DOCTYPE html>
<html lang="IT">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="stylesheet" href="../styles/style.css" />
    <link rel="stylesheet" href="../styles/index-style.css" />
    <link rel="stylesheet" href="../styles/content-style.css" />
    <link rel="icon" type="image/x-icon" href="../resources/favicon.ico">
    <link rel="apple-touch-icon" href="../resources/favicon.png" />
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-78NHLXDQD8"></script>
    <script src="../scripts/script.js"></script>
    <style>:root { --bg-clr: #FFD700; --fg-clr: #262626; }</style>
    <meta name="theme-color" content="#FFD700" />
    <meta name="keywords" content="calcolatori elettronici" />
    <meta name="description" content="Il seguente sito contiene gli appunti e le definizioni del corso 'Calcolatori elettronici T'.">
    <meta name="robots" content="index">
    <script defer async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <title>Calcolatori elettronici - La CPU - CPU e comunicazione con le periferiche</title>
</head>
<body>
    <div class="container">
        <header class="header-wrapper">
            <div class="title-wrapper">
                <span class="title">
                    Calcolatori elettronici
                </span>
                <span class="subtitle">
                    by lorenzoarlo
                </span>
            </div>
            <span class="page-title">
                La CPU
            </span>
        </header>
        <section class="content-wrapper">
            <h1 class="section-title content-width">CPU e comunicazione con le periferiche</h1>
            <article class="content-container content-width">
                <div class="definition environment" id="def1-1"><h2 class="environment-title">Definizione - Elaborazione delle informazioni e interazione con l'esterno</h2><div class="environment-body">     Gran parte dei sistemi esistenti a come obiettivo principe l'elaborazione delle informazioni: anche la quasi totalità dei sistemi elettronici digitali ha questo obiettivo.     <br/>     Come tutti i sistemi di questo tipo, una funzione essenziale è l'interazione con l'esterno per acquisire e/o fornire informazione. </div></div><div class="definition environment" id="def1-2"><h2 class="environment-title">Definizione - Architetture per elaboratori</h2><div class="environment-body">     Esistono diverse architetture di elaborazione in base alle diverse necessità, ad esempio:     <ul class="list-container"><li class="list-item">sistemi general purpose;         </li><li class="list-item">sistemi embedded;         </li><li class="list-item">ecc.     </li></ul>     I sistemi general purpose sono sicuramente i più diffusi e sono basati generalmente sul modello di Von Neumann, che ha come elemento base una CPU. </div></div><div class="definition environment" id="def1-3"><h2 class="environment-title">Definizione - Modello di Von-Neumann</h2><div class="environment-body">     Il modello di Von-Neumann descrive un'architettura generale mentre il funzionamento è descritto da una sequenza di istruzioni (un programma) memorizzate su un supporto di memoria.     <br/>     Il sistema di elaborazione può essere schematizzato in modo astratto come una Rete Sequenziale Sincrona (RSS) a cui è aggiunta un'unità di controllo (ovvero una RSS) che dopo aver interrogato (<strong>fetch</strong>) la memoria per le istruzioni del programma, governa la parte combinatoria del microprocessore attraverso appositi <strong>segnali di controllo</strong>.     <br/>     A livello di massima astrazione, il funzionamento dell'intero sistema può essere descritto da due stati in continua alternanza:     <ul class="list-container"><li class="list-item">lo stato di Instruction Fetch (IF) in cui si "prelevano" le istruzioni da eseguire (indicato da un apposito registro detto Program Counter, PC);         </li><li class="list-item">lo stato di Execute (EX).     </li></ul></div></div><div class="definition environment" id="def1-4"><h2 class="environment-title">Definizione - CISC e RISC</h2><div class="environment-body">     Le CPU possono eseguire istruzioni come somme, moltiplicazioni, confronti, letture e scritture in memoria e/o verso altri dispositivi, ecc.      <br/>     In base al set di istruzioni codificate, le CPU si dividono tra:     <ul class="list-container"><li class="list-item">RISC (Reduced Instruction Set Computer), dove le istruzioni sono poche e semplici. Tali CPU sono caratterizzate da reti logiche semplici ed efficienti;         </li><li class="list-item">CISC (Complex Instruction Set Computer), dove le istruzioni sono molte e complesse, comportando reti logiche più complesse e più grandi.     </li></ul>     Se inizialmente fu l'architettura CISC ad essere prevalente, in particolare con l'arrivo dei dispositivi mobili, l'architettura RISC è diventata la più utilizzata per questioni di efficienza energetica e spazio occupato.     <br/>     Inoltre, ad oggi, anche le architetture CISC (ancora necessarie per la grande quantità di software preesistente) sono realizzate internamente come RISC. </div></div><div class="definition environment" id="def1-5"><h2 class="environment-title">Definizione - Linguaggi per CPU</h2><div class="environment-body">     Indipendentemente dal tipo della CPU, le istruzioni sono in forma binaria rendendole quindi di difficile comprensione.      Per questo motivo si utilizza il linguaggio assembly (o assembler) che traduce il codice assembly in binario grazie ad apposite Look Up Table (LUT).     I linguaggi di programmazione ad alto livello non fanno altro che tradurre le istruzioni più complesse (di alto livello, appunto) in istruzioni per la CPU (attraverso il compilatore, ad esempio).  </div></div><div class="definition environment" id="def1-6"><h2 class="environment-title">Definizione - Comunicazione nel modello di Von-Neumann</h2><div class="environment-body">     Nel modello di Von-Neumann le istruzioni risiedono in memoria, ma per leggere (e scrivere) la CPU utilizza segnali predefiniti temporizzati da un preciso ciclo di bus.     <br/>     Esistono infatti tre tipi di bus di comunicazione tra CPU, Memoria e le varie periferiche:     <ul class="list-container"><li class="list-item">l'Address Bus (<span class="math-span">\( BA[\ldots]\)</span>) unidirezionale (da CPU a memoria e periferiche);         </li><li class="list-item">il Data Bus (<span class="math-span">\( BD[\ldots]\)</span>) bidirizionale;         </li><li class="list-item">il Control Bus composto dai segnali:         <ul class="list-container"><li class="list-item">Read e Write (da CPU a memoria e periferiche);             </li><li class="list-item">Ready e Int (da memoria e periferiche a CPU).         </li></ul></li></ul></div></div><div class="definition environment" id="def1-7"><h2 class="environment-title">Definizione - Ciclo di bus</h2><div class="environment-body">     L'evoluzione temporale di alcuni segnali che interagiscono con una CPU si definiscono come ciclo di bus.     <br/>     L'unico modo per interagire con un sistema di questo tipo, consiste nel seguire le regole descritte da tale ciclo ed indicate dal costruttore nel relativo data sheet.     <br/>     Ad ogni ciclo di bus si ha quindi che nell'Address Bus è presente l'indirizzo della memoria o della periferica, nel Data Bus le informazioni da leggere o da scrivere e il Control Bus fornisce informazioni sull'operazione da svolgere o sullo stato della periferiche.     <br/>     Un ciclo di bus può durare più cicli di clock e può anche terminare in maniera asincrona.      <div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Ad esempio - Ciclo di bus di lettura</h3><div class="environment-body">         Consideriamo un prototipo di ciclo di bus di lettura         <div class="image-environment"><div class="image-wrapper spaced-90"><img alt="Immagine" src="../resources/generated-0.png"/></div></div>         Si ha quindi che la CPU emette l'indirizzo sull'Address Bus e negli istanti successivi la sua intenzione di lettura (segnale "Read"). A questo punto, la CPU aspetta il segnale di "Ready" per poter "ritirare" il dato immesso dalla periferica (sul Data Bus).     </div></div><div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Ad esempio - Ciclo di bus di scrittura</h3><div class="environment-body">         Consideriamo un prototipo di ciclo di bus di scrittura         <div class="image-environment"><div class="image-wrapper spaced-90"><img alt="Immagine" src="../resources/generated-1.png"/></div></div>         Si ha quindi che la CPU emette l'indirizzo sull'Address Bus e negli istanti successivi la sua intenzione di scrittura (segnale "Write"). A questo punto, la CPU aspetta il segnale di "Ready" per poter "inserire" il dato nella periferica (già caricato in precedenza sul data bus Data Bus).     </div></div></div></div><div class="definition environment" id="def1-8"><h2 class="environment-title">Definizione - Indirizzamento e spazio di indirizzamento</h2><div class="environment-body">     La CPU "emette" sull'Address Bus diversi indirizzi, in particolare si ha che se il bus è composto da <span class="math-span">\( 20\)</span> bit, lo spazio di indirizzamento sarà composto da <span class="math-span">\( 2^{20}\)</span> indirizzi. Ipotizzando inoltre la grandezza del Data Bus di <span class="math-span">\( 1\)</span> Byte (scelta anacronistica ma conveniente per i ragionamenti), si avrà uno spazio di indirizzamento di <span class="math-span">\( 1\)</span> MegaByte.     <br/>     Dato tale spazio, affinchè un dispositivo fisico (ad esempio una memoria) possa essere accessibile, deve essere mappato nello spazio di indirizzamento (devono essergli assegnati degli indirizzi), ovvero deve essergli assegnata una finestra di indirizzi.     <div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Ad esempio</h3><div class="environment-body">         Considerando di avere una memoria da <span class="math-span">\( 64\)</span> MB (<span class="math-span">\( 2^6 \cdot 2^{20}\)</span> Byte, ovvero <span class="math-span">\( 2^36\)</span> Byte) ed un Address Bus di <span class="math-span">\( 1\)</span> Byte, per poter indirizzare tale memoria saranno necessari almeno <span class="math-span">\( 2^36\)</span> indirizzi (ad ogni "dato" un indirizzo).     </div></div></div></div><div class="definition environment" id="def1-9"><h2 class="environment-title">Definizione - Driver 3-state</h2><div class="environment-body">     Il driver 3-state è una rete logica     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/driver3state-disabled.png"/></div></div>     che è caratterizzata da:     <ul class="list-container"><li class="list-item">un ingresso <span class="math-span">\( I\)</span>;         </li><li class="list-item">un ingresso <span class="math-span">\( OE\)</span> (Output Enable);         </li><li class="list-item">un'uscita <span class="math-span">\( U\)</span></li></ul>     Tale driver (un componente che non altera il segnale logico) permette l'introduzione di un "terzo stato", detto di "alta impedenza", che ha un effetto logico paragonabile "all'interruzione del cavo": a livello fisico, la tensione non assume un valore preciso ma rende il segnale in uscita "neutrale" rispetto al valore fornito da un altro componente.     <br/>     Esso è quindi descritto dalla seguente tabella della verità:     <div class="image-environment"><div class="image-wrapper spaced-20"><img alt="Immagine" src="../resources/generated-2.png"/></div></div>     dove <span class="math-span">\( Z\)</span> indica lo stato di alta impedenza.     <br/>     Si ha quindi che con l'ingresso <span class="math-span">\( OE = 1\)</span>, ovvero     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/driver3state-enabled.png"/></div></div>     tale componente diventa "trasparente", altrimenti "blocca" il segnale </div></div><div class="definition environment" id="def1-10"><h2 class="environment-title">Definizione - Decoder di I e II livello</h2><div class="environment-body">     La CPU per poter scrivere e leggere dei dati, emette l'indirizzo della cella di memoria interessata: a questo punto tale indirizzo viene fornito in input ad un decoder di I livello che in base al valore dei bit più significativi di tale indirizzo, abiliterà o disabiliterà (grazie ad un driver 3-state) un apposito ingresso del dispositivo (detto "Chip Select" o "Chip Enable", CS O CE).     <br/>     A questo punto, l'indirizzo è ulteriormente decodificato da un decoder di II livello (interno al dispositivo) che "collegherà" la parte corretta della memoria. </div></div><div class="definition environment" id="def1-11"><h2 class="environment-title">Definizione - Struttura di una generico dispositivo collegato alla CPU</h2><div class="environment-body">     Considerando un sistema caratterizzato da <span class="math-span">\( n\)</span> bit di dati, un generico dispositivo compatibile sarà caratterizzato da:     <ul class="list-container"><li class="list-item">un segnale di Chip Select del dispositivo;         </li><li class="list-item">un bus di <span class="math-span">\( k\)</span> bit utili per la decodifica di II livello;         </li><li class="list-item">un segnale di controllo per indicare la lettura ed uno per indicare la scrittura;         </li><li class="list-item">un bus di <span class="math-span">\( n\)</span> bit di dati.     </li></ul></div></div><div class="definition environment" id="def1-12"><h2 class="environment-title">Definizione - Memorie EPROM</h2><div class="environment-body">     Le memorie EPROM (Erasable Programmable Read Only Memory), sono memorie non volatili a sola lettura (durante l'utilizzo).     <br/>     Esse sono caratterizzate dai segnali:     <ul class="list-container"><li class="list-item"><span class="math-span">\( CE\)</span> (Chip Enable), per abilitare o meno il dispositivo;         </li><li class="list-item"><span class="math-span">\( OE\)</span> (Output Enable), per connettere "l'output" del dispositivo con il Bus Dati (sarà quindi attivo nel caso della lettura).     </li></ul>     Tali segnali devono variare seguendo i vari tempi indicati nel data-sheet.     <br/>     Per motivi storici, tali memorie hanno solitamente capacità il cui valore è multiplo di <span class="math-span">\( 2\)</span> (ad esempio <span class="math-span">\( 32\mathrm{\,KB}\)</span>, <span class="math-span">\( 64\mathrm{\,KB}\)</span>, <span class="math-span">\( 128\mathrm{\,KB}\)</span>, eccetera). </div></div><div class="definition environment" id="def1-13"><h2 class="environment-title">Definizione - Memorie SRAM</h2><div class="environment-body">     Le memorie SRAM (Static Random Access Memory), sono memorie volatili leggibili e scrivibili. Si differenziano dalle DRAM (Dynamic RAM) per la tecnologia impiegata (le DRAM utilizzano condensatori in modo da essere meno energivore).     <br/>     Esse sono caratterizzate dai segnali:     <ul class="list-container"><li class="list-item"><span class="math-span">\( CE\)</span> (Chip Enable), per abilitare o meno il dispositivo;         </li><li class="list-item"><span class="math-span">\( OE\)</span> (Output Enable), per connettere "l'output" del dispositivo con il Bus Dati (attivo quindi nel caso della lettura);         </li><li class="list-item"><span class="math-span">\( WE\)</span> (Write Enable), per connettere "l'input" del dispositivo con il Bus Dati (attivo quindi nel caso della scrittura).     </li></ul>     Tali segnali devono variare seguendo i vari tempi indicati nel data-sheet.     <br/>     Per motivi storici, tali memorie hanno solitamente capacità distanti un multiplo di <span class="math-span">\( 4\)</span> (ad esempio <span class="math-span">\( 8\mathrm{\,KB}\)</span>, <span class="math-span">\( 32\mathrm{\,KB}\)</span>, <span class="math-span">\( 128\mathrm{\,KB}\)</span>).     <br/>     A livello strutturale, una singolo bit di una SRAM (la <span class="math-span">\( j\)</span>-esima cella, composto da <span class="math-span">\( k\)</span> bit di Data Bus) è così composto     <div class="image-environment"><div class="image-wrapper spaced-80"><img alt="Immagine" src="../resources/cella-sram.png"/></div></div>     in particolare si ha che     <ul class="list-container"><li class="list-item">il segnale <span class="math-span">\( DECODER \ II \ LIVELLO\)</span> sarà fornito dal decoder in base all'indirizzo e abiliterà le <span class="math-span">\( k\)</span> celle (dato che ad ogni indirizzo è composto da <span class="math-span">\( k\)</span> celle) del <span class="math-span">\( j\)</span>-esimo indirizzo.         </li><li class="list-item">il segnale <span class="math-span">\( OE\)</span> rende (nel caso la cella sia all'indirizzo corretto) il driver 3-state trasparente permettendo quindi l'inserimento sul Data Bus;         </li><li class="list-item">il segnale <span class="math-span">\( WE\)</span> rende (nel caso la cella sia all'indirizzo corretto) il driver 3-state bloccante e collega il dato presente sul Data Bus all'ingresso <span class="math-span">\( D\)</span> del Latch (che sovrascriverà il dato presente in precedenza).     </li></ul></div></div><div class="definition environment" id="def1-14"><h2 class="environment-title">Definizione - Integrato notevole 244 - Driver 3-state a <span class="math-span">\( 8\)</span> bit</h2><div class="environment-body">     L'integrato notevole 244 è l'equivalente di <span class="math-span">\( 8\)</span> driver 3-state paralleli ma, a differenza dei singoli componenti, sono presenti solo due ingressi di <span class="math-span">\( OE\)</span> che "piloteranno" <span class="math-span">\( 4\)</span> bit ciascuno.     <br/>     Tale integrato sarà quindi composto, oltre che dai due ingressi di <span class="math-span">\( ENABLE\)</span>, da otto ingressi e otto uscite. </div></div><div class="definition environment" id="def1-15"><h2 class="environment-title">Definizione - Integrato notevole 245 - Driver 3-state bidirezionale a <span class="math-span">\( 8\)</span> bit</h2><div class="environment-body">     L'integrato notevole 245 è un driver 3-state bidirezionale composto da <span class="math-span">\( 8\)</span> "celle" del tipo     <div class="image-environment"><div class="image-wrapper spaced-60"><img alt="Immagine" src="../resources/integrato-245.png"/></div></div>     In base al valore dell'ingresso <span class="math-span">\( DIR\)</span>, si avrà che un certo ingresso/uscita sarà attivo mentre l'altro sarà bloccato (quindi sarà possibile la comunicazione da <span class="math-span">\( A\)</span> a <span class="math-span">\( B\)</span> e da <span class="math-span">\( B\)</span> ad <span class="math-span">\( A\)</span>).     <br/>     Il segnale di <span class="math-span">\( EN\)</span> si presenta solitamente negato (<span class="math-span">\( \overline{EN}\)</span>) e permette di creare l'impedenza in entrambi i sensi. </div></div><div class="definition environment" id="def1-16"><h2 class="environment-title">Definizione - Integrato notevole 373 - Latch a <span class="math-span">\( 8\)</span> bit con uscita 3-state</h2><div class="environment-body">     L'integrato notevole 373 è l'equivalente di <span class="math-span">\( 8\)</span> Latch CD sulla cui uscita è posto un driver 3-state.      <br/>     Tale integrato sarà quindi composto, oltre che dagli <span class="math-span">\( 8\)</span> ingressi di dato e le <span class="math-span">\( 8\)</span> uscite anche da un ingresso <span class="math-span">\( C\)</span> (condiviso) e un segnale per abilitare l'uscita (condiviso) solitamente negato (<span class="math-span">\( \overline{OE}\)</span>). </div></div><div class="definition environment" id="def1-17"><h2 class="environment-title">Definizione - Registro edge-triggered a <span class="math-span">\( k\)</span> bit</h2><div class="environment-body">     Un registro a <span class="math-span">\( k\)</span> bit è una rete sequenziale sincrona in grado di memorizzare un dato di <span class="math-span">\( k\)</span> bit.     <div class="image-environment"><div class="image-wrapper spaced-60"><img alt="Immagine" src="../resources/register.png"/></div></div>     Esso è caratterizzato da:     <ul class="list-container"><li class="list-item">un ingresso <span class="math-span">\( CLK\)</span> per il segnale di clock;         </li><li class="list-item">un bus di <span class="math-span">\( k\)</span> segnali sincroni in ingresso <span class="math-span">\( IN[k-1, \ldots, 0]\)</span>;         </li><li class="list-item">un ingresso sincrono <span class="math-span">\( WE\)</span> ("<i>Write Enable</i>") per permettere la <strong>sovrascrittura</strong> del dato precedentemente memorizzato (con <span class="math-span">\( WE = 0\)</span> ad ogni fronte di clock rimane il segnale memorizzato in precedenza);         </li><li class="list-item">un segnale asincrono <span class="math-span">\( A\_RESET\)</span> ("Asynchronous RESET") che, se attivo, pone a <span class="math-span">\( 0\)</span> tutti i bit memorizzati.     </li></ul>     Per realizzare un registro ad <span class="math-span">\( 1\)</span> bit (da cui poi è facile ottenere un registro a <span class="math-span">\( k\)</span> bit) è possibile ragionare nel seguente modo:     <ul class="list-container"><li class="list-item">se <span class="math-span">\( WE = 1\)</span>, il flip-flop deve memorizzare l'ingresso <span class="math-span">\( IN\)</span>;         </li><li class="list-item">se <span class="math-span">\( WE = 0\)</span>, il flip-flop deve memorizzare il valore precedente, ovvero <span class="math-span">\( Q\)</span>.     </li></ul>     Dato che è una scelta, un metodo utile per realizzarlo è utilizzare un multiplexer, ovvero     <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/circuito-register.png"/></div></div></div></div><div class="definition environment" id="def1-18"><h2 class="environment-title">Definizione - Integrato notevole 374 - Registro edge-triggered a <span class="math-span">\( 8\)</span> bit con uscita 3-state</h2><div class="environment-body">     L'integrato notevole 374 è l'equivalente di un registro edge-triggered a <span class="math-span">\( 8\)</span> bit sulla cui uscita è posto un driver 3-state.      <br/>     Tale integrato sarà quindi composto, oltre che dagli <span class="math-span">\( 8\)</span> ingressi di dato e le <span class="math-span">\( 8\)</span> uscite anche dal segnale di clock <span class="math-span">\( CK\)</span> anche da un ingresso per abilitare l'uscita solitamente negato (<span class="math-span">\( \overline{OE}\)</span>). </div></div><div class="definition environment" id="def1-19"><h2 class="environment-title">Definizione - Mappatura di dispositivi</h2><div class="environment-body">     Affinchè la CPU possa comunicare con un dispositivo, è necessario che esso sia mappato nello spazio di indirizzamento. Si ha inoltre che tali finestre di indirizzi da assegnare devono essere contigue.     <br/>     Si consideri un sistema ad <span class="math-span">\( n\)</span> bit ed un dispositivo con <span class="math-span">\( k\)</span> bit di indirizzo interno (ovvero che "andranno in pasto" al decoder di II livello). In totale, tali dispositivi occuperanno <span class="math-span">\( M = 2^k\)</span> indirizzi nello spazio di indirizzamento.     Un dispositivo si dice mappato ad un certo indirizzo <span class="math-span">\( A\)</span> se gli indirizzi del dispositivo sono compresi tra <span class="math-span">\( A\)</span> e <span class="math-span">\( A + (M - 1)\)</span>.     <br/>     Si dice inoltre che un certo indirizzo è allineato se <span class="math-span">\( A\)</span> è multiplo di <span class="math-span">\( M\)</span>, ovvero se     <span class="math-block">\[         M \ modulo \ A = 0     \]</span>     In questo caso, se un dispositivo è allineato, il primo indirizzo a lui corrispondente (<span class="math-span">\( A\)</span>) avrà i <span class="math-span">\( k\)</span> bit meno significativi (degli <span class="math-span">\( n\)</span> totali) a <span class="math-span">\( 0\)</span>.     <br/>     È possibile quindi dividere un generico indirizzo <span class="math-span">\( X\)</span> per il dispositivo in due parti     <span class="math-block">\[         X = \alpha \mid \beta       \]</span>     La parte <span class="math-span">\( \beta\)</span> è composta dai <span class="math-span">\( k\)</span> bit del dispositivo, mentre la parte <span class="math-span">\( \alpha\)</span> è composta dagli <span class="math-span">\( n - k\)</span> bit.      <br/>     In questo modo si avrà quindi che la decodifica della parte <span class="math-span">\( \alpha\)</span> è quella detta di I livello (a carico del progettista del sistema) mentre quella della parte <span class="math-span">\( \beta\)</span> è a carico del dispositivo.     <br/>     Una decodifica si dice completa se nella decodifica si utilizzano tutti i <span class="math-span">\( n - k\)</span> bit di <span class="math-span">\( \alpha\)</span>. Se non è questo il caso, si dice che la decodifica è semplificata. </div></div><div class="myexample environment" id="example1"><h2 class="environment-title">Esempio - Mappatura di dispositivi</h2><div class="environment-body">     Considerando un sistema con un Address Bus di <span class="math-span">\( 16 \mathrm{\,bit}\)</span> e un Data Bus di <span class="math-span">\( 8 \mathrm{\,bit}\)</span>, scrivere le espressioni di decodifica di I livello completa e semplificata nei casi:     <ul class="list-container"><li class="list-item">è presente un solo dispositivo di memoria da <span class="math-span">\( 16 \mathrm{\,KB}\)</span> mappato all'indirizzo esadecimale <span class="math-span">\( 8000h\)</span>;         </li><li class="list-item">è presente un solo dispositivo di memoria da <span class="math-span">\( 8 \mathrm{\,KB}\)</span> mappato all'indirizzo esadecimale <span class="math-span">\( 0000h\)</span>;         </li><li class="list-item">sono presenti un dispositivo di memoria <span class="math-span">\( A\)</span> da <span class="math-span">\( 16 \mathrm{\,KB}\)</span> mappato all'indirizzo esadecimale <span class="math-span">\( 8000h\)</span> e un dispositivo di memoria <span class="math-span">\( B\)</span> da <span class="math-span">\( 8 \mathrm{\,KB}\)</span> mappato all'indirizzo esadecimale <span class="math-span">\( 0000h\)</span>.     </li></ul>     Consideriamo il primo caso, ovvero il dispositivo di memoria da <span class="math-span">\( 16 \mathrm{\,KB}\)</span> mappato all'indirizzo esadecimale <span class="math-span">\( 8000h\)</span>. In questo caso, si ha che tale dispositivo necessita di <span class="math-span">\( 2^4 \cdot 2^{10} = 2^{14}\)</span> indirizzi. Si ha quindi che la decodifica di I livello potrà coinvolgere solo i <span class="math-span">\( 16 - 14 = 2\)</span> bit di indirizzo più significativi.     Considerando inoltre il primo indirizzo <span class="math-span">\( 8000h\)</span> si avrà che     <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/generated-3.png"/></div></div>     È necessario quindi scrivere le espressioni corrispondenti ad <span class="math-span">\( \alpha\)</span>. La decodifica completa si ha che deve utilizzare entrambi i bit di <span class="math-span">\( \alpha\)</span>: in questo caso si avrà che l'espressione completa per il chip select è data da     <span class="math-block">\[         CS_{\text{COMPLETA}} = BA[15] \cdot BA[14]'     \]</span>     mentre quella semplice (minima) è     <span class="math-block">\[         CS_{\text{SEMPLICE}} = 1     \]</span>     in quanto è presente un solo dispositivo (si ha quindi che corrisponde a tutto lo spazio di indirizzamento).     <br/>     Consideriamo ora il secondo caso, ovvero il dispositivo di memoria da <span class="math-span">\( 8\mathrm{\,KB}\)</span> mappato all'indirizzo esadecimale <span class="math-span">\( 0000h\)</span>. In questo caso, si ha che tale dispositivo necessita di <span class="math-span">\( 2^3 \cdot 2^{10} = 2^{13}\)</span> indirizzi e si ha che la decodifica di I livello potrà coinvolgere solo i <span class="math-span">\( 16 - 13 = 3\)</span> bit di indirizzo più significativi. Considerando quindi il primo indirizzo <span class="math-span">\( 0000h\)</span> si ha che     <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/generated-4.png"/></div></div>     Le espressioni corrispondenti ad <span class="math-span">\( \alpha\)</span> saranno quindi     <span class="math-block">\[         CS_{\text{COMPLETA}} = BA[15]' \cdot BA[14]' \cdot BA[13]'       \]</span>     e     <span class="math-block">\[         CS_{\text{SEMPLICE}} = 1     \]</span>     per gli stessi motivi del caso precedente.     <br/>     Considerando invece l'ultimo caso, in cui i dispositivi devono convivere, si ha che le espressioni di decofica completa saranno identiche ai casi precedenti, ovvero     <span class="math-block">\begin{aligned}         &amp; CS\_A_{\text{COMPLETA}} = BA[15] \cdot BA[14]' &amp; \\         &amp; CS\_B_{\text{COMPLETA}} = BA[15]' \cdot BA[14]' \cdot BA[13]' &amp;      \end{aligned}</span>     mentre per la decodifica semplice si ha che è possibile considerare le differenze nei bit più significativi, ovvero si ha che     <span class="math-block">\begin{aligned}         &amp; CS\_A_{\text{SEMPLICE}} = BA[15]  &amp; \\         &amp; CS\_B_{\text{SEMPLICE}} = BA[15]' &amp;      \end{aligned}</span></div></div><div class="myexample environment" id="example2"><h2 class="environment-title">Esempio - Comandare un Flip-Flop D con una CPU</h2><div class="environment-body">     Considerando un sistema con un Address Bus di <span class="math-span">\( 20 \mathrm{\,bit}\)</span> e un Data Bus di <span class="math-span">\( 8 \mathrm{\,bit}\)</span> con:     <ul class="list-container"><li class="list-item"><span class="math-span">\( 64 \mathrm{\,KB}\)</span> di memoria EPROM posizionati negli "indirizzi bassi";          </li><li class="list-item"><span class="math-span">\( 64 \mathrm{\,KB}\)</span> di memoria RAM posizionati negli "indirizzi alti".     </li></ul>     Si vuole comunicare con un Flip Flop D      <div class="image-environment"><div class="image-wrapper spaced-30"><img alt="Immagine" src="../resources/flip-flop-d-set-reset.png"/></div></div>     e impartigli i comandi di:     <ul class="list-container"><li class="list-item">scrittura nel Flip-flop;         </li><li class="list-item">lettura nel Flip-flop;         </li><li class="list-item">set asincrono del Flip-flop;         </li><li class="list-item">reset asincrono del Flip-flop.     </li></ul><span class="inner-title"> Mappatura</span>     Per risolvere questo problema, consideriamo innanzitutto la mappatura dei dispositivi.      <br/>     La EPROM necessita di <span class="math-span">\( 2^6 \cdot 2^{10} = 2^{16}\)</span> indirizzi e sappiamo inoltre che è posizionata negli indirizzi bassi (ovvero a partire da <span class="math-span">\( 00000h\)</span>).     Considerando ciò, si ha che la EPROM occuperà l'intervallo di indirizzi     <span class="math-block">\[         EPROM = [ 00000h, 00000h + 2^{16} ] = [ 00000h, 00000h + 0FFFFh ] =   [00000h, 0FFFFh]         \]</span>     Per quanto riguarda la RAM, si ha che non sono disponibili memorie RAM di <span class="math-span">\( 64\mathrm{\,KB}\)</span>.     Per risolvere ciò è tuttavia possibile considerare di utilizzare due memorie da <span class="math-span">\( 32 \mathrm{\,KB}\)</span> l'una.     Per trovare il primo loro indirizzo, è possibile considerare che il loro ultimo indirizzo è <span class="math-span">\( FFFFFh\)</span> e occupano <span class="math-span">\( 2^15 \mathrm{\,KB}\)</span> l'una.      Si avrà quindi che la prima RAM (quella più "in alto") occuperà gli indirizzi     <span class="math-block">\[         RAM\_1 = [FFFFFh - 2^{15}, FFFFFh] = [FFFFFh - 0EFFFh, FFFFFh] = [F8000h, FFFFFh]     \]</span>     mentre la seconda (quella più "in basso") avrà come indirizzo superiore il primo disponibile al di sotto della <span class="math-span">\( RAM_1\)</span>, ovvero <span class="math-span">\( F8000h - 00001h = F7FFFh\)</span>, da cui     <span class="math-block">\[         RAM\_2 = [F7FFFh - 2^{15}, F7FFFh] = [F7FFFh - 0EFFFh, F7FFFh] = [F0000h, F7FFFh]     \]</span>     Sono ora necessari quattro indirizzi per i quattro comandi che si vogliono impartire al Flip-Flop. È possibile scegliere degli indirizzi tra tutti quelli non utilizzati.     Scegliamo arbitrariamente i seguenti indirizzi:     <ul class="list-container"><li class="list-item">il comando di lettura sincrona all'indirizzo <span class="math-span">\( 80000h\)</span>;         </li><li class="list-item">il comando di scrittura sincrona all'indirizzo <span class="math-span">\( 80001h\)</span>;         </li><li class="list-item">il comando di reset asincrono all'indirizzo <span class="math-span">\( 80002h\)</span>;         </li><li class="list-item">il comando di set asincrono all'indirizzo <span class="math-span">\( 80003h\)</span>.     </li></ul>     Possiamo ora calcolare le espressioni di decodifica (utilizzando una decodifica semplice) di ogni dispositivo.      <br/>     In particolare consideriamo di avere un solo dispositivo nella prima metà dello spazio d'indirizzamento (la EPROM), per cui è possibile assegnargli l'intera metà, ovvero     <span class="math-block">\[         CS\_EPROM = BA[19]'     \]</span>     Considerando invece la seconda metà in cui convivono i vari comandi e le due RAM:     <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/generated-5.png"/></div></div>     Si ha quindi che:     <ul class="list-container"><li class="list-item">il bit <span class="math-span">\( BA[19]\)</span> (evidenziato in rosso) è necessario per identificare la seconda metà dello spazio di indirizzamento;         </li><li class="list-item">il bit <span class="math-span">\( BA[18]\)</span> (evidenziato in arancione) è necessario per distinguere tra i dispositivi RAM (<span class="math-span">\( BA[18]\)</span>) e i comandi (<span class="math-span">\( BA[18]'\)</span>);         </li><li class="list-item">il bit <span class="math-span">\( BA[15]\)</span> (evidenziato in blu) è necessario per distinguere tra le due RAM (<span class="math-span">\( BA[15]\)</span> per <span class="math-span">\( RAM\_1\)</span>, <span class="math-span">\( BA[15]'\)</span> per <span class="math-span">\( RAM\_2\)</span>);         </li><li class="list-item">i bit <span class="math-span">\( BA[1]\)</span> e <span class="math-span">\( BA[0]\)</span> (evidenziati in verde) sono necessari per distinguere i vari comandi.     </li></ul>     Si avrà quindi che i chip select saranno uguali a:     <ul class="list-container"><li class="list-item">il chip select della <span class="math-span">\( RAM\_1\)</span> sarà         <span class="math-block">\[             CS\_RAM\_1 = BA[19] \cdot BA[18] \cdot BA[15]           \]</span></li><li class="list-item">il chip select della <span class="math-span">\( RAM\_2\)</span> sarà         <span class="math-block">\[             CS\_RAM\_1 = BA[19] \cdot BA[18] \cdot BA[15]'           \]</span></li><li class="list-item">il chip select del comando di lettura sincrono sarà         <span class="math-block">\[             CS\_READ = BA[19] \cdot BA[18]' \cdot BA[1]' \cdot BA[0]' \cdot MEMREAD         \]</span>         Oltre all'espressione di decodifica è presente anche il comando di <span class="math-span">\( MEMREAD\)</span> per evitare malfunzionamenti durante i transitori;         </li><li class="list-item">il chip select del comando di scrittura sincrono sarà         <span class="math-block">\[             CS\_READ = BA[19] \cdot BA[18]' \cdot BA[1]' \cdot BA[0]         \]</span></li><li class="list-item">il chip select del comando di reset asincrono sarà         <span class="math-block">\[             CS\_RESET\_ASYNC = BA[19] \cdot BA[18]' \cdot BA[1] \cdot BA[0]' \cdot MEMWRITE         \]</span>         Oltre all'espressione di decodifica è presente anche il comando di <span class="math-span">\( MEMWRITE\)</span> per evitare malfunzionamenti durante i transitori;         </li><li class="list-item">il chip select del comando di set asincrono sarà         <span class="math-block">\[             CS\_SET\_ASYNC = BA[19] \cdot BA[18]' \cdot BA[1] \cdot BA[0] \cdot MEMWRITE         \]</span>         Oltre all'espressione di decodifica è presente anche il comando di <span class="math-span">\( MEMWRITE\)</span> per evitare malfunzionamenti durante i transitori;     </li></ul></div></div>
            </article>
            <nav class="buttons-container content-width">
                <a class="navigation-button previous" href="index.html" rel="nofollow"><span>La CPU</span></a>
                
            </nav>
        </section>
        <div class="scroll-to-bottom-button" onclick="scroll_to_bottom()">
            <span class="material-symbols-outlined">
                keyboard_double_arrow_down
            </span>
        </div>
        <footer class="footer-wrapper">
            <div class="copyright-wrapper">
                <span> &copy; Copyright 2023</span> /
                <span>made by lorenzoarlo</span>
            </div>
            /
            <div class="privacy-wrapper">
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/" rel="nofollow">Pannello preferenze cookie</a></span> /
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/privacy-policy.html" rel="nofollow" target="_blank" >Privacy Policy</a></span>
            </div>
        </footer>
    </div>
</body>
</html>