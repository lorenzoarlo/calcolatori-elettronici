<!DOCTYPE html>
<html lang="IT">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="stylesheet" href="../styles/style.css" />
    <link rel="stylesheet" href="../styles/index-style.css" />
    <link rel="stylesheet" href="../styles/content-style.css" />
    <link rel="icon" type="image/x-icon" href="../resources/favicon.ico">
    <meta name="application-name" content="Calcolatori elettronici" />
    <meta name="apple-mobile-web-app-title" content="Calcolatori elettronici" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="#FFD700" />
    <link rel="apple-touch-icon" href="../resources/favicon.png" />
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-78NHLXDQD8"></script>
    <script src="../scripts/script.js"></script>
    <style>:root { --bg-clr: #FFD700; --fg-clr: #262626; }</style>
    <meta name="theme-color" content="#FFD700" />
    <meta name="keywords" content="calcolatori elettronici" />
    <meta name="description" content="Il seguente sito contiene gli appunti e le definizioni del corso 'Calcolatori elettronici T'.">
    <meta name="robots" content="index">
    <script defer async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <title>Calcolatori elettronici - Gestione eventi - Protocollo di comunicazione handshake</title>
</head>
<body>
    <div class="container">
        <header class="header-wrapper">
            <div class="title-wrapper">
                <span class="title">
                    Calcolatori elettronici
                </span>
                <span class="subtitle">
                    by lorenzoarlo
                </span>
            </div>
            <span class="page-title">
                Gestione eventi
            </span>
        </header>
        <section class="content-wrapper">
            <h1 class="section-title content-width">Protocollo di comunicazione handshake</h1>
            <article class="content-container content-width">
                <div class="definition environment" id="def3-11"><h2 class="environment-title">Definizione - Problemi di comunicazione gestita con buffer</h2><div class="environment-body">     Fino a questo momento, abbiamo considerato che la CPU gestisca la comunicazione con qualsiasi periferica esterna e che sia utilizzato come tramite un buffer.     Tale metodologia comporta tuttavia alcune problematiche, ad esempio     <ul class="list-container"><li class="list-item">nessuno garantisce (alla CPU) che la periferica esterna abbia scritto nel buffer, rendendo quindi necessario un continuo controllo dei dati sul buffer (cosa a cui è possibile porre rimedio implementando un segnale di interrupt);         </li><li class="list-item">nella fase di lettura (della CPU) nessuno garantisce (alla periferica) che la CPU abbia letto le informazioni nel buffer (informazione utile per evitare di sovrascrivere informazioni che andrebbero perse) e, analogamente, nessuno garantisce che la periferica abbia letto il dato nella fase di scrittura (della CPU).     </li></ul>     Per risolvere ciò è necessario adottare una forma di sincronizzazione tra produttore (del dato) e consumatore: una possibilità è adottare il protocollo handshake. </div></div><div class="definition environment" id="def3-12"><h2 class="environment-title">Definizione - Protocollo handshake - Porta per input</h2><div class="environment-body">     L'utilizzo del protocollo handshake in input necessita, oltre che entrambi i dispositivi rispettino le temporizzazioni, un dispositivo di interfaccia, ovvero una "porta".     <div class="image-environment"><div class="image-wrapper spaced-75"><img alt="Immagine" src="../resources/handshake-porta-input.png"/></div></div>     Il flusso del funzionamento di tale porta può essere suddiviso in fasi:     <ul class="list-container"><li class="list-item">una fase di "quiete", in cui il buffer interno alla porta non contiene alcun dato interessante.          In questa fase il segnale <span class="mono">IBF</span> (<i><strong>I</strong>nput <strong>B</strong>uffer <strong>F</strong>ull</i>) asserito dalla portà avrà valore <span class="mono">0</span>;         </li><li class="list-item">una fase di scrittura da parte dell'unità esterna nella porta (possibile solo se il buffer è "vuoto", ovvero <span class="mono">IBF = 0</span>) segnata dall'asserzione del segnale <span class="mono">STB</span> (<i><strong>St</strong>ro<strong>b</strong>e</i>).         Al fronte di salita di <span class="mono">STB</span> (ovvero nel momento in cui l'unità esterna sta "esprimendo la volontà" di voler scrivere il dato nel buffer), si ha che sarà asserito anche <span class="mono">IBF = 1</span> (per indicare la presenza di dati);         </li><li class="list-item">terminata la scrittura del dato nel buffer (al fronte di discesa di <span class="mono">STB</span>), la porta dovrà segnalare la presenza di un nuovo dato interno al buffer, asserendo quindi il segnale <span class="mono">INT_R</span> (<i><strong>Int</strong>errupt <strong>R</strong>equest</i>);         </li><li class="list-item">tale richiesta di interrupt rimarrà a valore alto fino a che non inizierà la lettura di questo dato (ovvero al fronte di salita di <span class="mono">RD</span>);         </li><li class="list-item">una volta terminata la lettura (al fronte di discesa di <span class="mono">RD</span>) si avrà che il buffer interno sarà vuoto, segnalando quindi <span class="mono">IBF = 0</span>.     </li></ul>     Riassumendo, si avrà che un tipico ciclo di lettura sarà caratterizzato dal seguente andamento dei segnali:     <div class="image-environment"><div class="image-wrapper spaced-80"><img alt="Immagine" src="../resources/generated-14.png"/></div></div><span class="inner-title">Realizzazione</span>     Realizzare la rete logica che ha questo comportamento risulta essere particolarmente complicato, in quanto è necessario gestire diversi fronti di salita e di discesa contemporaneamente.     Una realizzazione classica porterebbe infatti a clock gating (causato dalla presenza di gate sul clock) o alla necessità di utilizzare segnali asincroni, scelta non felice.     <br/>     Una metodologia per realizzare ciò, è riconoscere i diversi fronti di salita e discesa dato che:     <ul class="list-container"><li class="list-item">il segnale <span class="mono">IBF</span> dovrà avere valore <span class="mono">1</span> al fronte di salita di <span class="mono">STB</span> e valore <span class="mono">0</span> al fronte di discesa di <span class="mono">RD</span>;         </li><li class="list-item">il segnale <span class="mono">INT_R</span> dovrà avere valore <span class="mono">1</span> al fronte di discesa di <span class="mono">STB</span> e valore <span class="mono">0</span> al fronte di salita di <span class="mono">RD</span>.     </li></ul>     Un metodo per riconoscere tali comportamenti è utilizzare un flip-flop D per ogni fronte, ovvero     <div class="image-environment"><div class="image-wrapper spaced-75"><img alt="Immagine" src="../resources/hanshake-input-fronti.png"/></div></div>     In questo modo, tuttavia, si ha che alla fine di ogni "ciclo", i segnali logici rimangono tutti a livello "alto": è possibile ora però ragionare con logica negata per effettuare le relative attivazioni.     <div class="image-environment"><div class="image-wrapper spaced-80"><img alt="Immagine" src="../resources/generated-15.png"/></div></div>     Si avrà quindi che:     <ul class="list-container"><li class="list-item">il segnale <span class="mono">IBF</span> dovrà essere attivo al fronte di salita di <span class="mono">STB</span> ed essere attivo basso al fronte di discesa di <span class="mono">RD</span><div class="center"><span class="mono">IBF = STBSALITA <span class="math-span">\( \cdot\)</span> RDDISCESA' + STBSALITA' <span class="math-span">\( \cdot\)</span> RDDISCESA</span></div>         in quanto è necessario discriminare anche durante al secondo "ciclo" di lettura (in cui i segnali sono negati);         </li><li class="list-item">il segnale <span class="mono">INT_R</span> dovrà essere attivo al fronte di discesa di <span class="mono">STB</span> ed essere attivo basso al fronte di salita di <span class="mono">RD</span><div class="center"><span class="mono">INT_R = STBDISCESA <span class="math-span">\( \cdot\)</span> RDSALITA' + STBDISCESA' <span class="math-span">\( \cdot\)</span> RDSALITA</span></div>         in quanto è necessario discriminare anche durante al secondo "ciclo" di lettura (in cui i segnali sono negati);     </li></ul>     Per quanto riguarda il collegamento dati, si ha che i dati sono sicuramente presenti al fronte di discesa di <span class="mono">STB</span>, ovvero si avrà     <div class="image-environment"><div class="image-wrapper spaced-60"><img alt="Immagine" src="../resources/handshake-input-buffer.png"/></div></div></div></div><div class="definition environment" id="def3-13"><h2 class="environment-title">Definizione - Protocollo handshake - Porta per output</h2><div class="environment-body">     L'utilizzo del protocollo handshake in output necessita, oltre che entrambi i dispositivi rispettino le temporizzazioni, un dispositivo di interfaccia, ovvero una "porta".     <div class="image-environment"><div class="image-wrapper spaced-75"><img alt="Immagine" src="../resources/handshake-porta-output.png"/></div></div>     Il flusso del funzionamento di tale porta può essere suddiviso in fasi:     <ul class="list-container"><li class="list-item">una fase di "quiete", in cui il buffer interno alla porta non contiene alcun dato interessante.          In questa fase il segnale <span class="mono">OBF</span> (<i><strong>O</strong>utput <strong>B</strong>uffer <strong>F</strong>ull</i>) asserito dalla portà avrà valore <span class="mono">0</span>. Si avrà quindi che il segnale di <span class="mono">INT_R</span> avrà valore <span class="mono">1</span>, in quanto segnala la possibilità di ricevere un dato;         </li><li class="list-item">una fase di scrittura da parte del processore segnata dall'asserzione del segnale <span class="mono">WR</span>.         Al fronte di salita di <span class="mono">WR</span> (ovvero nel momento in cui il processore sta "esprimendo la volontà" di voler scrivere il dato nel buffer), si ha che sarà asserito anche <span class="mono">INT_R = 0</span>;         </li><li class="list-item">terminata la scrittura del dato nel buffer (al fronte di discesa di <span class="mono">WR</span>), la porta dovrà segnalare la presenza di un nuovo dato interno al buffer, asserendo quindi il segnale <span class="mono">OBF</span> (<i><strong>O</strong>utput <strong>B</strong>uffer <strong>F</strong>ull</i>);         </li><li class="list-item">in questo momento sarà quindi l'unità esterna a dover leggere il dato: tale lettura sarà confermata con il segnale <span class="mono">ACK</span> (<i><strong>Ack</strong>nowledge</i>). Si avrà quindi che al fronte di salita di <span class="mono">ACK</span> il segnale <span class="mono">OBF</span> sarà asserito a valore <span class="mono">0</span> (dato che l'unità esterna ne ha "preso coscienza");         </li><li class="list-item">al termine della lettura (ovvero al fronte di discesa di <span class="mono">ACK</span>) il buffer interno sarà vuoto, segnalando quindi <span class="mono">INT_R = 1</span>.     </li></ul>     Riassumendo, si avrà che un tipico ciclo di scrittura sarà caratterizzato dal seguente andamento dei segnali:     <div class="image-environment"><div class="image-wrapper spaced-80"><img alt="Immagine" src="../resources/generated-16.png"/></div></div><span class="inner-title">Realizzazione</span>     Realizzare la rete logica che ha questo comportamento risulta essere particolarmente complicato, in quanto è necessario gestire diversi fronti di salita e di discesa contemporaneamente.     Una realizzazione classica porterebbe infatti a clock gating (causato dalla presenza di gate sul clock) o alla necessità di utilizzare segnali asincroni, scelta non felice.     <br/>     Una metodologia per realizzare ciò, è riconoscere i diversi fronti di salita e discesa dato che:     <ul class="list-container"><li class="list-item">il segnale <span class="mono">INT_R</span> dovrà avere valore <span class="mono">1</span> di default, valore <span class="mono">0</span> al fronte di salita di <span class="mono">WR</span> e ritornare al valore <span class="mono">1</span> al fronte di salita di <span class="mono">ACK</span>;         </li><li class="list-item">il segnale <span class="mono">OBF</span> dovrà avere valore <span class="mono">1</span> al fronte di discesa di <span class="mono">WR</span> e valore <span class="mono">0</span> al fronte di salita di <span class="mono">ACK</span>.     </li></ul>     Un metodo per riconoscere tali comportamenti è utilizzare un flip-flop D per ogni fronte, ovvero     <div class="image-environment"><div class="image-wrapper spaced-75"><img alt="Immagine" src="../resources/hanshake-input-fronti.png"/></div></div>     In questo modo, tuttavia, si ha che alla fine di ogni "ciclo", i segnali logici rimangono tutti a livello "alto": è possibile ora però ragionare con logica negata per effettuare le relative attivazioni.     <div class="image-environment"><div class="image-wrapper spaced-80"><img alt="Immagine" src="../resources/generated-17.png"/></div></div>     Si avrà quindi che:     <ul class="list-container"><li class="list-item">il segnale <span class="mono">INT_R</span> dovrà essere attivo basso al fronte di salita di <span class="mono">WR</span> ed essere nuovamente attivo alto al fronte di discesa di <span class="mono">ACK</span><div class="center"><span class="mono">INT_R = ((WRSALITA <span class="math-span">\( \cdot\)</span> ACKDISCESA') + (WRSALITA <span class="math-span">\( \cdot\)</span> ACKDISCESA'))'</span><br/><span class="mono">INT_R = (WRSALITA <span class="math-span">\( \cdot\)</span> ACKDISCESA')' <span class="math-span">\( \cdot\)</span> (WRSALITA <span class="math-span">\( \cdot\)</span> ACKDISCESA')'</span><br/><span class="mono">INT_R = (WRSALITA' + ACKDISCESA) <span class="math-span">\( \cdot\)</span> (WRSALITA' + ACKDISCESA)</span></div>         (utilizzando le leggi di De Morgan);         </li><li class="list-item">il segnale <span class="mono">OBF</span> dovrà essere attivo alto al fronte di discesa di <span class="mono">WR</span> ed essere attivo basso al fronte di salita di <span class="mono">ACK</span><div class="center"><span class="mono">OBF = WRDISCESA <span class="math-span">\( \cdot\)</span> ACKSALITA' + WRDISCESA' <span class="math-span">\( \cdot\)</span> ACKSALITA</span></div>         in quanto è necessario discriminare anche durante al secondo "ciclo" di lettura (in cui i segnali sono negati);     </li></ul>     Per quanto riguarda il collegamento dati, si ha che i dati sono sicuramente presenti al fronte di discesa di <span class="mono">WR</span>, ovvero si avrà     <div class="image-environment"><div class="image-wrapper spaced-60"><img alt="Immagine" src="../resources/handshake-output-buffer.png"/></div></div></div></div>
            </article>
            <nav class="buttons-container content-width">
                <a class="navigation-button previous" href="eventi-e-interruzioni.html" rel="nofollow"><span>Eventi e interruzioni</span></a>
                
            </nav>
        </section>
        <div class="scroll-to-bottom-button" onclick="scroll_to_bottom()">
            <span class="material-symbols-outlined">
                keyboard_double_arrow_down
            </span>
        </div>
        <footer class="footer-wrapper">
            <div class="copyright-wrapper">
                <span> &copy; Copyright 2023</span> /
                <span>made by lorenzoarlo</span>
            </div>
            /
            <div class="privacy-wrapper">
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/" rel="nofollow">Pannello preferenze cookie</a></span> /
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/privacy-policy.html" rel="nofollow" target="_blank" >Privacy Policy</a></span>
            </div>
        </footer>
    </div>
</body>
</html>