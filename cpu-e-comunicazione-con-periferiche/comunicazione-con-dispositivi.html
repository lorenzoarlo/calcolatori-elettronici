<!DOCTYPE html>
<html lang="IT">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="stylesheet" href="../styles/style.css" />
    <link rel="stylesheet" href="../styles/index-style.css" />
    <link rel="stylesheet" href="../styles/content-style.css" />
    <link rel="icon" type="image/x-icon" href="../resources/favicon.ico">
    <meta name="application-name" content="Calcolatori elettronici" />
    <meta name="apple-mobile-web-app-title" content="Calcolatori elettronici" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="#FFD700" />
    <link rel="apple-touch-icon" href="../resources/favicon.png" />
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-78NHLXDQD8"></script>
    <script src="../scripts/script.js"></script>
    <style>:root { --bg-clr: #FFD700; --fg-clr: #262626; }</style>
    <meta name="theme-color" content="#FFD700" />
    <meta name="keywords" content="calcolatori elettronici" />
    <meta name="description" content="Il seguente sito contiene gli appunti e le definizioni del corso 'Calcolatori elettronici T'.">
    <meta name="robots" content="index">
    <script defer async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <title>Calcolatori elettronici - CPU e comunicazione con periferiche - Comunicazione con dispositivi</title>
</head>
<body>
    <div class="container">
        <header class="header-wrapper">
            <div class="title-wrapper">
                <span class="title">
                    Calcolatori elettronici
                </span>
                <span class="subtitle">
                    by lorenzoarlo
                </span>
            </div>
            <span class="page-title">
                CPU e comunicazione con periferiche
            </span>
        </header>
        <section class="content-wrapper">
            <h1 class="section-title content-width">Comunicazione con dispositivi</h1>
            <article class="content-container content-width">
                <div class="definition environment" id="def1-6"><h2 class="environment-title">Definizione - Comunicazione nel modello di Von-Neumann</h2><div class="environment-body">     Nel modello di Von-Neumann le istruzioni risiedono in memoria, ma per leggere (e scrivere) la CPU utilizza segnali predefiniti temporizzati da un preciso ciclo di bus.     <br/>     Esistono infatti tre tipi di bus di comunicazione tra CPU, Memoria e le varie periferiche:     <ul class="list-container"><li class="list-item">l'<strong>Address Bus</strong> (<span class="mono">BA[...]</span>) <strong>unidirezionale</strong> (da CPU a memoria e periferiche);         </li><li class="list-item">il <strong>Data Bus</strong> (<span class="mono">BD[...]</span>) <strong>bidirezionale</strong>;         </li><li class="list-item">il <strong>Control Bus</strong> composto dai segnali:         <ul class="list-container"><li class="list-item"><strong>Read</strong> e <strong>Write</strong> (da CPU a memoria e periferiche), per indicare la volontà di lettura o scrittura verso le periferiche;             </li><li class="list-item"><strong>Ready</strong> e <strong>Int</strong> (da memoria e periferiche a CPU), per indicare il momento in cui la periferica è "pronta" a ricevere o fornire i dati (il segnale <strong>Ready</strong>) e per allertare la CPU di qualcosa che è accaduto (il segnale <strong>Int</strong>, <strong>Interrupt</strong>) .         </li></ul></li></ul><div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Ad esempio - Segnale di Interrupt</h3><div class="environment-body">         Un utilizzo del segnale di Interrupt può essere legato alla gestione di segnali temporali (ad esempio una sveglia).          Si evita infatti di far "contare il tempo che passa" al processore ma si "delega" tale compito, per esempio, ad un contatore esterno che una volta terminato il conteggio invierà un segnale di Interrupt al processore, che verificherà poi il motivo di tale interruzione.     </div></div></div></div><div class="definition environment" id="def1-7"><h2 class="environment-title">Definizione - Ciclo di bus</h2><div class="environment-body">     L'<strong>evoluzione temporale</strong> di alcuni segnali che interagiscono con una CPU si definiscono come <strong>ciclo di bus</strong>.     <br/>     L'unico modo per interagire con un sistema di questo tipo, consiste nel seguire le <strong>regole descritte</strong> da tale ciclo ed indicate dal costruttore nel relativo data sheet.     <br/>     Ad ogni ciclo di bus si ha quindi che nell'Address Bus è presente l'<strong>indirizzo della memoria o della periferica</strong>, nel Data Bus le <strong>informazioni da leggere o da scrivere</strong> e il Control Bus fornisce <strong>informazioni sull'operazione da svolgere o sullo stato della periferiche</strong>.     <br/>     Un ciclo di bus può durare più cicli di clock e può anche terminare in maniera asincrona.      <div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Ad esempio - Ciclo di bus di lettura</h3><div class="environment-body">         Consideriamo un prototipo di ciclo di bus di lettura         <div class="image-environment"><div class="image-wrapper spaced-90"><img alt="Immagine" src="../resources/generated-0.png"/></div></div>         Si ha quindi che la CPU emette l'indirizzo sull'Address Bus e negli istanti successivi la sua intenzione di lettura (segnale <span class="mono">Read</span>).          A questo punto, la CPU aspetta il segnale di <span class="mono">Ready</span> per poter "ritirare" il dato immesso dalla periferica (sul Data Bus).     </div></div><div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Ad esempio - Ciclo di bus di scrittura</h3><div class="environment-body">         Consideriamo un prototipo di ciclo di bus di scrittura         <div class="image-environment"><div class="image-wrapper spaced-90"><img alt="Immagine" src="../resources/generated-1.png"/></div></div>         Si ha quindi che la CPU emette l'indirizzo sull'Address Bus e negli istanti successivi la sua intenzione di scrittura (segnale <span class="mono">Write</span>).          A questo punto, la CPU aspetta il segnale di <span class="mono">Ready</span> per poter "inserire" il dato nella periferica (già caricato in precedenza sul Data Bus).     </div></div></div></div><div class="definition environment" id="def1-8"><h2 class="environment-title">Definizione - Indirizzamento e spazio di indirizzamento</h2><div class="environment-body">     La CPU "emette" sull'Address Bus diversi indirizzi: in particolare si ha che se il bus è composto da <span class="math-span">\( 20\)</span> bit, lo spazio di indirizzamento sarà composto da <span class="math-span">\( 2^{20}\)</span> indirizzi.      Ipotizzando inoltre la grandezza del Data Bus di <span class="math-span">\( 1 \mathrm{ \, Byte }\)</span> (scelta anacronistica ma conveniente per i ragionamenti), si avrà (nel caso dei <span class="math-span">\( 20\)</span> bit di indirizzo) uno spazio di indirizzamento di <span class="math-span">\( 1 \mathrm{ \, MB }\)</span>.     <br/>     Dato tale spazio, affinchè un dispositivo fisico (ad esempio una memoria) possa essere accessibile, deve essere <strong>mappato nello spazio di indirizzamento</strong>, ovvero deve essergli assegnata una finestra di indirizzi.     <div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Ad esempio</h3><div class="environment-body">         Considerando di avere una memoria da <span class="math-span">\( 64 \mathrm{ \, MB }\)</span> (<span class="math-span">\( 2^6 \cdot 2^{20} \mathrm{ \, Byte }\)</span>, ovvero <span class="math-span">\( 2^36 \mathrm{ \, Byte }\)</span>) ed un Address Bus di <span class="math-span">\( 1 \mathrm{ \, Byte }\)</span>, per poter indirizzare tale memoria saranno necessari almeno <span class="math-span">\( 2^36\)</span> indirizzi (ad ogni "dato" un indirizzo).     </div></div></div></div><div class="definition environment" id="def1-9"><h2 class="environment-title">Definizione - Driver 3-state</h2><div class="environment-body">     Il <strong>driver 3-state</strong> è una rete logica     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/driver3state-disabled.png"/></div></div>     che è caratterizzata da:     <ul class="list-container"><li class="list-item">un ingresso <span class="mono">I</span>;         </li><li class="list-item">un ingresso <span class="mono">OE</span> (<i>Output Enable</i>);         </li><li class="list-item">un'uscita <span class="mono">U</span></li></ul>     Tale driver (un componente che non altera il segnale logico) permette l'introduzione di un "terzo stato", detto di "<strong>alta impedenza</strong>", che ha un effetto logico paragonabile "all'interruzione del cavo": a livello fisico, la tensione non assume un valore preciso ma rende il segnale in uscita "neutrale" rispetto al valore fornito da un altro componente.     <br/>     Esso è quindi descritto dalla seguente tabella della verità:     <div class="image-environment"><div class="image-wrapper spaced-20"><img alt="Immagine" src="../resources/generated-2.png"/></div></div>     dove <span class="mono">Z</span> indica lo stato di alta impedenza.     <br/>     Si ha quindi che con l'ingresso <span class="mono">OE = 1</span>, ovvero     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/driver3state-enabled.png"/></div></div>     tale componente diventa "trasparente", altrimenti "blocca" il segnale </div></div><div class="definition environment" id="def1-10"><h2 class="environment-title">Definizione - Decoder di I e II livello</h2><div class="environment-body">     La CPU per poter scrivere e leggere dei dati, emette l'indirizzo della cella di memoria interessata: a questo punto tale indirizzo viene fornito in input ad un decoder di I livello che in base al valore dei bit più significativi di tale indirizzo, abiliterà o disabiliterà (grazie ad un driver 3-state) un apposito ingresso del dispositivo (detto "Chip Select" o "Chip Enable", CS o CE).     <br/>     A questo punto, l'indirizzo è ulteriormente decodificato da un decoder di II livello (interno al dispositivo) che "collegherà" la parte corretta della memoria. </div></div><div class="definition environment" id="def1-11"><h2 class="environment-title">Definizione - Struttura di una generico dispositivo collegato alla CPU</h2><div class="environment-body">     Considerando un sistema caratterizzato da <span class="math-span">\( n\)</span> bit di dati, un generico dispositivo compatibile sarà caratterizzato da:     <ul class="list-container"><li class="list-item">un segnale di <span class="mono">Chip Select</span> (<strong>CS</strong>) del dispositivo;         </li><li class="list-item">un bus di <span class="math-span">\( k\)</span> bit utili per la decodifica di II livello;         </li><li class="list-item">un segnale di controllo per indicare la lettura ed uno per indicare la scrittura;         </li><li class="list-item">un bus di <span class="math-span">\( n\)</span> bit di dati.     </li></ul></div></div><div class="definition environment" id="def1-12"><h2 class="environment-title">Definizione - Memorie EPROM</h2><div class="environment-body">     Le memorie <strong>EPROM</strong> (<i>Erasable Programmable Read Only Memory</i>), sono memorie non volatili a sola lettura (durante l'utilizzo).     <br/>     Esse sono caratterizzate dai segnali:     <ul class="list-container"><li class="list-item"><span class="mono">CE</span> (<i>Chip Enable</i>), per abilitare o meno il dispositivo;         </li><li class="list-item"><span class="mono">OE</span> (<i>Output Enable</i>), per connettere "l'output" del dispositivo con il Bus Dati (sarà quindi attivo nel caso della lettura).     </li></ul>     Tali segnali devono variare seguendo i vari tempi indicati nel data-sheet.     <br/>     Per motivi storici, tali memorie hanno solitamente capacità il cui valore è multiplo di <span class="math-span">\( 2\)</span> (ad esempio <span class="math-span">\( 32\mathrm{ \, KB }\)</span>, <span class="math-span">\( 64\mathrm{ \, KB }\)</span>, <span class="math-span">\( 128\mathrm{ \, KB }\)</span>, eccetera). </div></div><div class="definition environment" id="def1-13"><h2 class="environment-title">Definizione - Memorie SRAM</h2><div class="environment-body">     Le memorie <strong>SRAM</strong> (<i>Static Random Access Memory</i>), sono memorie volatili leggibili e scrivibili.      Si differenziano dalle <strong>DRAM</strong> (<i>Dynamic RAM</i>) per la tecnologia impiegata (le DRAM utilizzano condensatori in modo da essere meno energivore).     <br/>     Esse sono caratterizzate dai segnali:     <ul class="list-container"><li class="list-item"><span class="mono">CE</span> (<i>Chip Enable</i>), per abilitare o meno il dispositivo;         </li><li class="list-item"><span class="mono">OE</span> (<i>Output Enable</i>), per connettere "l'output" del dispositivo con il Bus Dati (attivo quindi nel caso della lettura);         </li><li class="list-item"><span class="mono">WE</span> (<i>Write Enable</i>), per connettere "l'input" del dispositivo con il Bus Dati (attivo quindi nel caso della scrittura).     </li></ul>     Tali segnali devono variare seguendo i vari tempi indicati nel data-sheet.     <br/>     Per motivi storici, tali memorie hanno solitamente capacità distanti un multiplo di <span class="math-span">\( 4\)</span> (ad esempio <span class="math-span">\( 8\mathrm{ \, KB }\)</span>, <span class="math-span">\( 32\mathrm{ \, KB }\)</span>, <span class="math-span">\( 128\mathrm{ \, KB }\)</span>).     <br/>     A livello strutturale, una singolo bit di una SRAM (la <span class="math-span">\( j\)</span>-esima cella composta da <span class="math-span">\( k\)</span> bit) è così composto     <div class="image-environment"><div class="image-wrapper spaced-80"><img alt="Immagine" src="../resources/cella-sram.png"/></div></div>     in particolare si ha che     <ul class="list-container"><li class="list-item">il segnale <span class="mono">DECODER II LIVELLO</span> sarà fornito dal decoder in base all'indirizzo e abiliterà le <span class="math-span">\( k\)</span> celle (dato che ad ogni indirizzo è composto da <span class="math-span">\( k\)</span> celle) del <span class="math-span">\( j\)</span>-esimo indirizzo.         </li><li class="list-item">il segnale <span class="mono">OE</span> rende (nel caso la cella sia all'indirizzo desiderato) il driver 3-state trasparente permettendo quindi l'inserimento sul Data Bus;         </li><li class="list-item">il segnale <span class="mono">WE</span> rende (nel caso la cella sia all'indirizzo desiderato) il driver 3-state bloccante e collega il dato presente sul Data Bus all'ingresso <span class="mono">D</span> del Latch (che sovrascriverà il dato presente in precedenza).     </li></ul></div></div>
            </article>
            <nav class="buttons-container content-width">
                <a class="navigation-button previous" href="il-modello-della-cpu.html" rel="nofollow"><span>Il modello della CPU</span></a>
                <a class="navigation-button next" href="reti-logiche-notevoli.html" rel="nofollow"><span>Reti logiche notevoli</span></a>
            </nav>
        </section>
        <div class="scroll-to-bottom-button" onclick="scroll_to_bottom()">
            <span class="material-symbols-outlined">
                keyboard_double_arrow_down
            </span>
        </div>
        <footer class="footer-wrapper">
            <div class="copyright-wrapper">
                <span> &copy; Copyright 2023</span> /
                <span>made by lorenzoarlo</span>
            </div>
            /
            <div class="privacy-wrapper">
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/" rel="nofollow">Pannello preferenze cookie</a></span> /
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/privacy-policy.html" rel="nofollow" target="_blank" >Privacy Policy</a></span>
            </div>
        </footer>
    </div>
</body>
</html>